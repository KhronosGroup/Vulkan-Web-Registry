<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<meta name="author" content="The Khronos® Vulkan Working Group">
<title>Vulkan® 1.1.169 - A Specification (with all registered Vulkan extensions)</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: #fff; color: #222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

object, svg { display: inline-block; vertical-align: middle; }

.center { margin-left: auto; margin-right: auto; }

.spread { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.4; color: black; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #0068b0; text-decoration: none; line-height: inherit; }
a:hover, a:focus { color: #333; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: Noto, sans-serif; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 0.75em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Noto, sans-serif; font-weight: normal; font-style: normal; color: black; text-rendering: optimizeLegibility; margin-top: 0.5em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #4d4d4d; line-height: 0; }

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid #ddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; color: #264357; }

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 0.75em; list-style-position: outside; font-family: Noto, sans-serif; }

ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3em; font-weight: bold; }
dl dd { margin-bottom: 0.75em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: black; border-bottom: 1px dotted #ddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 0.75em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #ddd; }
blockquote cite { display: block; font-size: 0.8125em; color: #5e93b8; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #5e93b8; }

blockquote, blockquote p { line-height: 1.6; color: #333; }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #ddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
/* Tables */
table { background: #fff; margin-bottom: 1.25em; border: solid 1px #d8d8ce; }
table thead, table tfoot { background: #eee; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #6d6e71; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f8f8f8; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.4; }

body { -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; tab-size: 4; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }

a:hover, a:focus { text-decoration: underline; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: inherit; font-style: normal !important; letter-spacing: 0; padding: 0; background-color: transparent; -webkit-border-radius: 0; border-radius: 0; line-height: inherit; word-wrap: break-word; }
*:not(pre) > code.nobreak { word-wrap: normal; }
*:not(pre) > code.nowrap { white-space: nowrap; }

pre, pre > code { line-height: 1.6; color: #264357; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }

em em { font-style: normal; }

strong strong { font-weight: normal; }

.keyseq { color: #333333; }

kbd { font-family: Consolas, "Liberation Mono", Courier, monospace; display: inline-block; color: black; font-size: 0.65em; line-height: 1.45; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -moz-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: 0 0.15em; padding: 0.2em 0.5em; vertical-align: middle; position: relative; top: -0.1em; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menuref { color: #000; }

.menuseq b:not(.caret), .menuref { font-weight: inherit; }

.menuseq { word-spacing: -0.02em; }
.menuseq b.caret { font-size: 1.25em; line-height: 0.8; }
.menuseq i.caret { font-weight: bold; text-align: center; width: 0.45em; }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 1.5em; padding-right: 1.5em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: black; margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #ddd; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #ddd; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #ddd; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: #5e93b8; display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: #333; }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: #333; }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: black; border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 0 solid #ddd; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: Noto, sans-serif; list-style-type: none; }
#toc li { line-height: 1.3334; margin-top: 0.3334em; }
#toc a { text-decoration: none; }
#toc a:active { text-decoration: underline; }

#toctitle { color: black; font-size: 1.2em; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
  body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { margin-top: 0 !important; background-color: #fff; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #ddd; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #ddd; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
  #toc.toc2 { width: 20em; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background-color: none; padding: 1.25em; }

#footer-text { color: black; line-height: 1.44; }

#content { margin-bottom: 0.625em; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { #content { margin-bottom: 1.25em; }
  .sect1 { padding-bottom: 1.25em; } }
.sect1:last-child { padding-bottom: 0; }

.sect1 + .sect1 { border-top: 0 solid #ddd; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: black; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: black; }

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; }

table.tableblock > caption.title { white-space: nowrap; overflow: visible; max-width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: black; }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: initial; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: Noto, sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #ddd; color: #5e93b8; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: black; margin-top: 0; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint { background: #eee; }
.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint { background: #f2f1f1; }

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { border: 1px hidden #666; -webkit-border-radius: 0; border-radius: 0; word-wrap: break-word; padding: 1.25em 1.5625em 1.125em 1.5625em; font-size: 0.8125em; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.90625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 1em; } }

.literalblock.output pre { color: #eee; background-color: #264357; }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1.25em 1.5625em 1.125em 1.5625em; -webkit-border-radius: 0; border-radius: 0; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: #999; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

table.pyhltable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; line-height: 1.6; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

pre.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #ddd; }

pre.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background: none !important; padding-right: 0 !important; }

.quoteblock { margin: 0 1em 0.75em 1.5em; display: table; }
.quoteblock > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock blockquote p { color: #333; font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: black; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.5em; margin-right: 0.5ex; text-align: right; }
.quoteblock .quoteblock { margin-left: 0; margin-right: 0; padding: 0.5em 0; border-left: 3px solid #5e93b8; }
.quoteblock .quoteblock blockquote { padding: 0 0 0 0.75em; }
.quoteblock .quoteblock blockquote:before { display: none; }

.verseblock { margin: 0 1em 0.75em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: #333; font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.8125em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.025em; color: #5e93b8; }

.quoteblock.abstract { margin: 0 0 0.75em 0; display: block; }
.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p { text-align: left; word-spacing: 0; }
.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before { display: none; }

table.tableblock { max-width: 100%; border-collapse: separate; }
table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid #d8d8ce; }

table.grid-all > thead > tr > .tableblock, table.grid-all > tbody > tr > .tableblock { border-width: 0 1px 1px 0; }

table.grid-all > tfoot > tr > .tableblock { border-width: 1px 1px 0 0; }

table.grid-cols > * > tr > .tableblock { border-width: 0 1px 0 0; }

table.grid-rows > thead > tr > .tableblock, table.grid-rows > tbody > tr > .tableblock { border-width: 0 0 1px 0; }

table.grid-rows > tfoot > tr > .tableblock { border-width: 1px 0 0 0; }

table.grid-all > * > tr > .tableblock:last-child, table.grid-cols > * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-all > tbody > tr:last-child > .tableblock, table.grid-all > thead:last-child > tr > .tableblock, table.grid-rows > tbody > tr:last-child > .tableblock, table.grid-rows > thead:last-child > tr > .tableblock { border-bottom-width: 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot { border-width: 1px 0; }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.4; background: #eee; }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: #222; font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 1em; }

td > div.verse { white-space: pre; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.375em; }

ul.checklist, ul.none, ol.none, ul.no-bullet, ol.no-bullet, ol.unnumbered, ul.unstyled, ol.unstyled { list-style-type: none; }

ul.no-bullet, ol.no-bullet, ol.unnumbered { margin-left: 0.625em; }

ul.unstyled, ol.unstyled { margin-left: 0; }

ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1.25em; font-size: 0.8em; position: relative; bottom: 0.125em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }

ul.inline { display: -ms-flexbox; display: -webkit-box; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; list-style: none; margin: 0 0 0.375em -0.75em; }

ul.inline > li { margin-left: 0.75em; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1, td.hdlist2 { vertical-align: top; padding: 0 0.625em; }

td.hdlist1 { font-weight: bold; padding-bottom: 0.75em; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0.4em 0.75em 0 0.75em; line-height: 1; vertical-align: top; }
.colist > table tr > td:first-of-type img { max-width: initial; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px #fff; -webkit-box-shadow: 0 0 0 1px #ddd; box-shadow: 0 0 0 1px #ddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; display: inline-block; }
a.image object { pointer-events: none; }

sup.footnote, sup.footnoteref { font-size: 0.875em; position: static; vertical-align: super; }
sup.footnote a, sup.footnoteref a { text-decoration: none; }
sup.footnote a:active, sup.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -0.25em 0 0.75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em 0 0.225em; line-height: 1.3334; font-size: 0.875em; margin-left: 1.2em; margin-bottom: 0.2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; margin-left: -1.05em; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }
a span.icon > .fa { cursor: inherit; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #29475c; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: black; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { border-bottom: 1px solid #ddd; }

.sect1 { padding-bottom: 0; }

#toctitle { color: #00406F; font-weight: normal; margin-top: 1.5em; }

.sidebarblock { border-color: #aaa; }

code { -webkit-border-radius: 4px; border-radius: 4px; }

p.tableblock.header { color: #6d6e71; }

.literalblock pre, .listingblock pre { background: #eee; }

/* From https://github.com/KhronosGroup/Vulkan-Docs/pull/901 */
a code { color: inherit; }

/* From https://github.com/KhronosGroup/Vulkan-Docs/pull/1157 */
/* Make VUID anchor handles*/
li > p > a[id^="VUID-"] { visibility: hidden; position: absolute; z-index: 1001; width: 2.2ex; margin-left: -2.2ex; display: block; text-decoration: none !important; text-align: center; font-weight: normal; }

li > p > a[id^="VUID-"]:before { content: "\00A7"; font-size: 1em; display: block; padding-top: 0em; background: #fff; }

li > p:hover > a[id^="VUID-"], li > p > a[id^="VUID-"]:hover { visibility: visible; }

li > p > a[id^="VUID-"].link { color: black; text-decoration: none; }

/* TODO: not quite sure what these two do */
li > p > a[id^="VUID-"].link:hover { color: black; }

.vuid { color: gray; font-family: monospace; }

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
pre.CodeRay{background:#f7f7f8}
.CodeRay .line-numbers{border-right:1px solid currentColor;opacity:.35;padding:0 .5em 0 0}
.CodeRay span.line-numbers{display:inline-block;margin-right:.75em}
.CodeRay .line-numbers strong{color:#000}
table.CodeRay{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.CodeRay td{vertical-align:top;line-height:inherit}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.code{padding:0 0 0 .75em}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>

<!-- dragged in by font-awesome css included by asciidoctor, but preloaded in this extension for convenience -->
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/fonts/fontawesome-webfont.woff2?v=4.7.0" as="font" type="font/woff2" crossorigin="">

<!-- Note: Chrome needs crossorigin="" even for same-origin fonts -->
<link rel="preload" href="../katex/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Main-Italic.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Typewriter-Regular.woff2" as="font" type="font/woff2" crossorigin=""><link rel="stylesheet" href="../katex/katex.min.css">
<!--ChunkedSearchJSMarker-->
<link href="chunked.css?4" rel="stylesheet">
<script>var searchindexurl = 'search.index.js?4' + (document.title.replace(/[^0-9.]/g, ''));</script>
<script src="chunked.js?4"></script>
<style>
    #loading_msg {
        width: 100%;
        margin-left: auto;
        margin-right: auto;
        margin-top: 1ex;
        margin-bottom: 1ex;
        max-width: 62.5em;
        position: relative;
        padding-left: 1.5em;
        padding-right: 1.5em;
    }
    .hidden {display: none;}
</style>
<script>
    function hideElement(e){
        e.setAttribute("hidden", "");
        e.classList.add("hidden");
    }

    function unhideElement(e){
        e.classList.remove("hidden");
        e.removeAttribute("hidden");
    }

    function hideLoadableContent(){
        unhideElement( document.getElementById("loading_msg") );
        for( var loadable of document.getElementsByClassName("loadable") ) hideElement(loadable);
    }

    function unhideLoadableContent(){
        hideElement( document.getElementById("loading_msg") );
        for( var loadable of document.getElementsByClassName("loadable") ) unhideElement(loadable);
    }

    window.addEventListener("load", unhideLoadableContent);
</script>
</head>
<body class="book toc2 toc-left">
<div id="header" style="max-width: 100%;">
<h1>Vulkan<sup>®</sup> 1.1.169 - A Specification (with all registered Vulkan extensions)</h1>
<div class="details">
<span id="author" class="author">The Khronos<sup>®</sup> Vulkan Working Group</span><br>
<span id="revnumber">version 1.1.169,</span>
<span id="revdate">2021-02-02 07:08:01Z</span>
<br><span id="revremark">from git branch: github-main commit: 1eae55f4c780fb0f0aa990071fe158d2a70e7429</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="chap2.html#preamble">1. Preamble</a></li>
<li><a href="chap3.html#introduction">2. Introduction</a>
<ul class="sectlevel2">
<li><a href="chap3.html#introduction-conventions">2.1. Document Conventions</a></li>
</ul>
</li>
<li><a href="chap4.html#fundamentals">3. Fundamentals</a>
<ul class="sectlevel2">
<li><a href="chap4.html#fundamentals-host-environment">3.1. Host and Device Environment</a></li>
<li><a href="chap4.html#fundamentals-execmodel">3.2. Execution Model</a></li>
<li><a href="chap4.html#fundamentals-objectmodel-overview">3.3. Object Model</a></li>
<li><a href="chap4.html#fundamentals-abi">3.4. Application Binary Interface</a></li>
<li><a href="chap4.html#fundamentals-commandsyntax">3.5. Command Syntax and Duration</a></li>
<li><a href="chap4.html#fundamentals-threadingbehavior">3.6. Threading Behavior</a></li>
<li><a href="chap4.html#fundamentals-errors">3.7. Errors</a></li>
<li><a href="chap4.html#fundamentals-numerics">3.8. Numeric Representation and Computation</a></li>
<li><a href="chap4.html#fundamentals-fixedconv">3.9. Fixed-Point Data Conversions</a></li>
<li><a href="chap4.html#fundamentals-common-objects">3.10. Common Object Types</a></li>
</ul>
</li>
<li><a href="chap5.html#initialization">4. Initialization</a>
<ul class="sectlevel2">
<li><a href="chap5.html#initialization-functionpointers">4.1. Command Function Pointers</a></li>
<li><a href="chap5.html#initialization-instances">4.2. Instances</a></li>
</ul>
</li>
<li><a href="chap6.html#devsandqueues">5. Devices and Queues</a>
<ul class="sectlevel2">
<li><a href="chap6.html#devsandqueues-physical-device-enumeration">5.1. Physical Devices</a></li>
<li><a href="chap6.html#devsandqueues-devices">5.2. Devices</a></li>
<li><a href="chap6.html#devsandqueues-queues">5.3. Queues</a></li>
</ul>
</li>
<li><a href="chap7.html#commandbuffers">6. Command Buffers</a>
<ul class="sectlevel2">
<li><a href="chap7.html#commandbuffers-lifecycle">6.1. Command Buffer Lifecycle</a></li>
<li><a href="chap7.html#commandbuffers-pools">6.2. Command Pools</a></li>
<li><a href="chap7.html#commandbuffer-allocation">6.3. Command Buffer Allocation and Management</a></li>
<li><a href="chap7.html#commandbuffers-recording">6.4. Command Buffer Recording</a></li>
<li><a href="chap7.html#commandbuffers-submission">6.5. Command Buffer Submission</a></li>
<li><a href="chap7.html#commandbuffers-submission-progress">6.6. Queue Forward Progress</a></li>
<li><a href="chap7.html#commandbuffers-secondary">6.7. Secondary Command Buffer Execution</a></li>
<li><a href="chap7.html#commandbuffers-devicemask">6.8. Command Buffer Device Mask</a></li>
</ul>
</li>
<li><a href="chap8.html#synchronization">7. Synchronization and Cache Control</a>
<ul class="sectlevel2">
<li><a href="chap8.html#synchronization-dependencies">7.1. Execution and Memory Dependencies</a></li>
<li><a href="chap8.html#synchronization-implicit">7.2. Implicit Synchronization Guarantees</a></li>
<li><a href="chap8.html#synchronization-fences">7.3. Fences</a></li>
<li><a href="chap8.html#synchronization-semaphores">7.4. Semaphores</a></li>
<li><a href="chap8.html#synchronization-events">7.5. Events</a></li>
<li><a href="chap8.html#synchronization-pipeline-barriers">7.6. Pipeline Barriers</a></li>
<li><a href="chap8.html#synchronization-memory-barriers">7.7. Memory Barriers</a></li>
<li><a href="chap8.html#synchronization-wait-idle">7.8. Wait Idle Operations</a></li>
<li><a href="chap8.html#synchronization-submission-host-writes">7.9. Host Write Ordering Guarantees</a></li>
<li><a href="chap8.html#synchronization-device-group">7.10. Synchronization and Multiple Physical Devices</a></li>
<li><a href="chap8.html#calibrated-timestamps">7.11. Calibrated timestamps</a></li>
</ul>
</li>
<li><a href="chap9.html#renderpass">8. Render Pass</a>
<ul class="sectlevel2">
<li><a href="chap9.html#renderpass-creation">8.1. Render Pass Creation</a></li>
<li><a href="chap9.html#renderpass-compatibility">8.2. Render Pass Compatibility</a></li>
<li><a href="chap9.html#_framebuffers">8.3. Framebuffers</a></li>
<li><a href="chap9.html#renderpass-commands">8.4. Render Pass Commands</a></li>
</ul>
</li>
<li><a href="chap10.html#shaders">9. Shaders</a>
<ul class="sectlevel2">
<li><a href="chap10.html#shader-modules">9.1. Shader Modules</a></li>
<li><a href="chap10.html#shaders-execution">9.2. Shader Execution</a></li>
<li><a href="chap10.html#shaders-execution-memory-ordering">9.3. Shader Memory Access Ordering</a></li>
<li><a href="chap10.html#shaders-inputs">9.4. Shader Inputs and Outputs</a></li>
<li><a href="chap10.html#shaders-task">9.5. Task Shaders</a></li>
<li><a href="chap10.html#shaders-mesh">9.6. Mesh Shaders</a></li>
<li><a href="chap10.html#shaders-vertex">9.7. Vertex Shaders</a></li>
<li><a href="chap10.html#shaders-tessellation-control">9.8. Tessellation Control Shaders</a></li>
<li><a href="chap10.html#shaders-tessellation-evaluation">9.9. Tessellation Evaluation Shaders</a></li>
<li><a href="chap10.html#shaders-geometry">9.10. Geometry Shaders</a></li>
<li><a href="chap10.html#shaders-fragment">9.11. Fragment Shaders</a></li>
<li><a href="chap10.html#shaders-compute">9.12. Compute Shaders</a></li>
<li><a href="chap10.html#shaders-ray-generation">9.13. Ray Generation Shaders</a></li>
<li><a href="chap10.html#shaders-intersection">9.14. Intersection Shaders</a></li>
<li><a href="chap10.html#shaders-any-hit">9.15. Any-Hit Shaders</a></li>
<li><a href="chap10.html#shaders-closest-hit">9.16. Closest Hit Shaders</a></li>
<li><a href="chap10.html#shaders-miss">9.17. Miss Shaders</a></li>
<li><a href="chap10.html#shaders-callable">9.18. Callable Shaders</a></li>
<li><a href="chap10.html#shaders-interpolation-decorations">9.19. Interpolation Decorations</a></li>
<li><a href="chap10.html#shaders-staticuse">9.20. Static Use</a></li>
<li><a href="chap10.html#shaders-scope">9.21. Scope</a></li>
<li><a href="chap10.html#shaders-group-operations">9.22. Group Operations</a></li>
<li><a href="chap10.html#shaders-quad-operations">9.23. Quad Group Operations</a></li>
<li><a href="chap10.html#shaders-derivative-operations">9.24. Derivative Operations</a></li>
<li><a href="chap10.html#shaders-helper-invocations">9.25. Helper Invocations</a></li>
<li><a href="chap10.html#_cooperative_matrices">9.26. Cooperative Matrices</a></li>
<li><a href="chap10.html#shaders-validation-cache">9.27. Validation Cache</a></li>
</ul>
</li>
<li><a href="chap11.html#pipelines">10. Pipelines</a>
<ul class="sectlevel2">
<li><a href="chap11.html#pipelines-compute">10.1. Compute Pipelines</a></li>
<li><a href="chap11.html#pipelines-graphics">10.2. Graphics Pipelines</a></li>
<li><a href="chap11.html#pipelines-ray-tracing">10.3. Ray Tracing Pipelines</a></li>
<li><a href="chap11.html#pipelines-destruction">10.4. Pipeline Destruction</a></li>
<li><a href="chap11.html#pipelines-multiple">10.5. Multiple Pipeline Creation</a></li>
<li><a href="chap11.html#pipelines-pipeline-derivatives">10.6. Pipeline Derivatives</a></li>
<li><a href="chap11.html#pipelines-cache">10.7. Pipeline Cache</a></li>
<li><a href="chap11.html#pipelines-specialization-constants">10.8. Specialization Constants</a></li>
<li><a href="chap11.html#pipeline-library">10.9. Pipeline Libraries</a></li>
<li><a href="chap11.html#pipelines-binding">10.10. Pipeline Binding</a></li>
<li><a href="chap11.html#pipelines-dynamic-state">10.11. Dynamic State</a></li>
<li><a href="chap11.html#pipelines-shader-information">10.12. Pipeline Shader Information</a></li>
<li><a href="chap11.html#pipelines-compiler-control">10.13. Pipeline Compiler Control</a></li>
<li><a href="chap11.html#pipelines-creation-feedback">10.14. Pipeline Creation Feedback</a></li>
</ul>
</li>
<li><a href="chap12.html#memory">11. Memory Allocation</a>
<ul class="sectlevel2">
<li><a href="chap12.html#memory-host">11.1. Host Memory</a></li>
<li><a href="chap12.html#memory-device">11.2. Device Memory</a></li>
</ul>
</li>
<li><a href="chap13.html#resources">12. Resource Creation</a>
<ul class="sectlevel2">
<li><a href="chap13.html#resources-buffers">12.1. Buffers</a></li>
<li><a href="chap13.html#resources-buffer-views">12.2. Buffer Views</a></li>
<li><a href="chap13.html#resources-images">12.3. Images</a></li>
<li><a href="chap13.html#resources-image-layouts">12.4. Image Layouts</a></li>
<li><a href="chap13.html#resources-image-views">12.5. Image Views</a></li>
<li><a href="chap13.html#resources-acceleration-structures">12.6. Acceleration Structures</a></li>
<li><a href="chap13.html#resources-association">12.7. Resource Memory Association</a></li>
<li><a href="chap13.html#resources-sharing">12.8. Resource Sharing Mode</a></li>
<li><a href="chap13.html#resources-memory-aliasing">12.9. Memory Aliasing</a></li>
</ul>
</li>
<li><a href="chap14.html#samplers">13. Samplers</a>
<ul class="sectlevel2">
<li><a href="chap14.html#samplers-YCbCr-conversion">13.1. Sampler Y′C<sub>B</sub>C<sub>R</sub> conversion</a></li>
</ul>
</li>
<li><a href="#descriptorsets">14. Resource Descriptors</a>
<ul class="sectlevel2">
<li><a href="#descriptorsets-types">14.1. Descriptor Types</a></li>
<li><a href="#descriptorsets-sets">14.2. Descriptor Sets</a></li>
<li><a href="#_physical_storage_buffer_access">14.3. Physical Storage Buffer Access</a></li>
</ul>
</li>
<li><a href="chap16.html#interfaces">15. Shader Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap16.html#interfaces-iointerfaces">15.1. Shader Input and Output Interfaces</a></li>
<li><a href="chap16.html#interfaces-vertexinput">15.2. Vertex Input Interface</a></li>
<li><a href="chap16.html#interfaces-fragmentoutput">15.3. Fragment Output Interface</a></li>
<li><a href="chap16.html#interfaces-inputattachment">15.4. Fragment Input Attachment Interface</a></li>
<li><a href="chap16.html#interfaces-raypipeline">15.5. Ray Tracing Pipeline Interface</a></li>
<li><a href="chap16.html#interfaces-resources">15.6. Shader Resource Interface</a></li>
<li><a href="chap16.html#interfaces-builtin-variables">15.7. Built-In Variables</a></li>
</ul>
</li>
<li><a href="chap17.html#textures">16. Image Operations</a>
<ul class="sectlevel2">
<li><a href="chap17.html#_image_operations_overview">16.1. Image Operations Overview</a></li>
<li><a href="chap17.html#_conversion_formulas">16.2. Conversion Formulas</a></li>
<li><a href="chap17.html#_texel_input_operations">16.3. Texel Input Operations</a></li>
<li><a href="chap17.html#_texel_output_operations">16.4. Texel Output Operations</a></li>
<li><a href="chap17.html#textures-normalized-operations">16.5. Normalized Texel Coordinate Operations</a></li>
<li><a href="chap17.html#_unnormalized_texel_coordinate_operations">16.6. Unnormalized Texel Coordinate Operations</a></li>
<li><a href="chap17.html#textures-integer-coordinate-operations">16.7. Integer Texel Coordinate Operations</a></li>
<li><a href="chap17.html#textures-sample-operations">16.8. Image Sample Operations</a></li>
<li><a href="chap17.html#textures-footprint">16.9. Texel Footprint Evaluation</a></li>
<li><a href="chap17.html#textures-instructions">16.10. Image Operation Steps</a></li>
<li><a href="chap17.html#textures-queries">16.11. Image Query Instructions</a></li>
</ul>
</li>
<li><a href="chap18.html#fragmentdensitymapops">17. Fragment Density Map Operations</a>
<ul class="sectlevel2">
<li><a href="chap18.html#_fragment_density_map_operations_overview">17.1. Fragment Density Map Operations Overview</a></li>
<li><a href="chap18.html#fragmentdensitymap-fetch-density-value">17.2. Fetch Density Value</a></li>
<li><a href="chap18.html#fragmentdensitymap-conversion-to-fragment-area">17.3. Fragment Area Conversion</a></li>
</ul>
</li>
<li><a href="chap19.html#queries">18. Queries</a>
<ul class="sectlevel2">
<li><a href="chap19.html#queries-pools">18.1. Query Pools</a></li>
<li><a href="chap19.html#queries-operation">18.2. Query Operation</a></li>
<li><a href="chap19.html#queries-occlusion">18.3. Occlusion Queries</a></li>
<li><a href="chap19.html#queries-pipestats">18.4. Pipeline Statistics Queries</a></li>
<li><a href="chap19.html#queries-timestamps">18.5. Timestamp Queries</a></li>
<li><a href="chap19.html#queries-performance">18.6. Performance Queries</a></li>
<li><a href="chap19.html#queries-transform-feedback">18.7. Transform Feedback Queries</a></li>
<li><a href="chap19.html#queries-performance-intel">18.8. Intel performance queries</a></li>
</ul>
</li>
<li><a href="chap20.html#clears">19. Clear Commands</a>
<ul class="sectlevel2">
<li><a href="chap20.html#clears-outside">19.1. Clearing Images Outside A Render Pass Instance</a></li>
<li><a href="chap20.html#clears-inside">19.2. Clearing Images Inside A Render Pass Instance</a></li>
<li><a href="chap20.html#clears-values">19.3. Clear Values</a></li>
<li><a href="chap20.html#clears-filling-buffers">19.4. Filling Buffers</a></li>
<li><a href="chap20.html#clears-updating-buffers">19.5. Updating Buffers</a></li>
</ul>
</li>
<li><a href="chap21.html#copies">20. Copy Commands</a>
<ul class="sectlevel2">
<li><a href="chap21.html#_common_operation">20.1. Common Operation</a></li>
<li><a href="chap21.html#copies-buffers">20.2. Copying Data Between Buffers</a></li>
<li><a href="chap21.html#copies-images">20.3. Copying Data Between Images</a></li>
<li><a href="chap21.html#copies-buffers-images">20.4. Copying Data Between Buffers and Images</a></li>
<li><a href="chap21.html#copies-imagescaling">20.5. Image Copies with Scaling</a></li>
<li><a href="chap21.html#copies-resolve">20.6. Resolving Multisample Images</a></li>
<li><a href="chap21.html#copies-buffer-markers">20.7. Buffer Markers</a></li>
</ul>
</li>
<li><a href="chap22.html#drawing">21. Drawing Commands</a>
<ul class="sectlevel2">
<li><a href="chap22.html#drawing-primitive-topologies">21.1. Primitive Topologies</a></li>
<li><a href="chap22.html#drawing-primitive-order">21.2. Primitive Order</a></li>
<li><a href="chap22.html#drawing-primitive-shading">21.3. Programmable Primitive Shading</a></li>
<li><a href="chap22.html#drawing-conditional-rendering">21.4. Conditional Rendering</a></li>
<li><a href="chap22.html#drawing-mesh-shading">21.5. Programmable Mesh Shading</a></li>
</ul>
</li>
<li><a href="chap23.html#fxvertex">22. Fixed-Function Vertex Processing</a>
<ul class="sectlevel2">
<li><a href="chap23.html#fxvertex-attrib">22.1. Vertex Attributes</a></li>
<li><a href="chap23.html#fxvertex-input">22.2. Vertex Input Description</a></li>
<li><a href="chap23.html#_vertex_attribute_divisor_in_instanced_rendering">22.3. Vertex Attribute Divisor in Instanced Rendering</a></li>
</ul>
</li>
<li><a href="chap24.html#tessellation">23. Tessellation</a>
<ul class="sectlevel2">
<li><a href="chap24.html#_tessellator">23.1. Tessellator</a></li>
<li><a href="chap24.html#_tessellator_patch_discard">23.2. Tessellator Patch Discard</a></li>
<li><a href="chap24.html#tessellation-tessellator-spacing">23.3. Tessellator Spacing</a></li>
<li><a href="chap24.html#tessellation-primitive-order">23.4. Tessellation Primitive Ordering</a></li>
<li><a href="chap24.html#tessellation-vertex-winding-order">23.5. Tessellator Vertex Winding Order</a></li>
<li><a href="chap24.html#tessellation-triangle-tessellation">23.6. Triangle Tessellation</a></li>
<li><a href="chap24.html#tessellation-quad-tessellation">23.7. Quad Tessellation</a></li>
<li><a href="chap24.html#tessellation-isoline-tessellation">23.8. Isoline Tessellation</a></li>
<li><a href="chap24.html#tessellation-point-mode">23.9. Tessellation Point Mode</a></li>
<li><a href="chap24.html#_tessellation_pipeline_state">23.10. Tessellation Pipeline State</a></li>
</ul>
</li>
<li><a href="chap25.html#geometry">24. Geometry Shading</a>
<ul class="sectlevel2">
<li><a href="chap25.html#geometry-input">24.1. Geometry Shader Input Primitives</a></li>
<li><a href="chap25.html#geometry-output">24.2. Geometry Shader Output Primitives</a></li>
<li><a href="chap25.html#geometry-invocations">24.3. Multiple Invocations of Geometry Shaders</a></li>
<li><a href="chap25.html#geometry-ordering">24.4. Geometry Shader Primitive Ordering</a></li>
<li><a href="chap25.html#geometry-passthrough">24.5. Geometry Shader Passthrough</a></li>
</ul>
</li>
<li><a href="chap26.html#mesh">25. Mesh Shading</a>
<ul class="sectlevel2">
<li><a href="chap26.html#mesh-task-input">25.1. Task Shader Input</a></li>
<li><a href="chap26.html#mesh-task-output">25.2. Task Shader Output</a></li>
<li><a href="chap26.html#mesh-generation">25.3. Mesh Generation</a></li>
<li><a href="chap26.html#mesh-input">25.4. Mesh Shader Input</a></li>
<li><a href="chap26.html#mesh-output">25.5. Mesh Shader Output Primitives</a></li>
<li><a href="chap26.html#mesh-output-perview">25.6. Mesh Shader Per-View Outputs</a></li>
<li><a href="chap26.html#mesh-ordering">25.7. Mesh Shader Primitive Ordering</a></li>
</ul>
</li>
<li><a href="chap27.html#vertexpostproc">26. Fixed-Function Vertex Post-Processing</a>
<ul class="sectlevel2">
<li><a href="chap27.html#vertexpostproc-transform-feedback">26.1. Transform Feedback</a></li>
<li><a href="chap27.html#vertexpostproc-viewport-swizzle">26.2. Viewport Swizzle</a></li>
<li><a href="chap27.html#vertexpostproc-flatshading">26.3. Flat Shading</a></li>
<li><a href="chap27.html#vertexpostproc-clipping">26.4. Primitive Clipping</a></li>
<li><a href="chap27.html#vertexpostproc-clipping-shader-outputs">26.5. Clipping Shader Outputs</a></li>
<li><a href="chap27.html#vertexpostproc-viewportwscaling">26.6. Controlling Viewport W Scaling</a></li>
<li><a href="chap27.html#vertexpostproc-coord-transform">26.7. Coordinate Transformations</a></li>
<li><a href="chap27.html#vertexpostproc-renderpass-transform">26.8. Render Pass Transform</a></li>
<li><a href="chap27.html#vertexpostproc-viewport">26.9. Controlling the Viewport</a></li>
</ul>
</li>
<li><a href="chap28.html#primsrast">27. Rasterization</a>
<ul class="sectlevel2">
<li><a href="chap28.html#primsrast-discard">27.1. Discarding Primitives Before Rasterization</a></li>
<li><a href="chap28.html#primsrast-stream">27.2. Controlling the Vertex Stream Used for Rasterization</a></li>
<li><a href="chap28.html#primrast-order">27.3. Rasterization Order</a></li>
<li><a href="chap28.html#primsrast-multisampling">27.4. Multisampling</a></li>
<li><a href="chap28.html#primrast-samplelocations">27.5. Custom Sample Locations</a></li>
<li><a href="chap28.html#primsrast-fragment-shading-rate">27.6. Fragment Shading Rates</a></li>
<li><a href="chap28.html#primsrast-shading-rate-image">27.7. Shading Rate Image</a></li>
<li><a href="chap28.html#primsrast-sampleshading">27.8. Sample Shading</a></li>
<li><a href="chap28.html#primsrast-barycentric">27.9. Barycentric Interpolation</a></li>
<li><a href="chap28.html#primsrast-points">27.10. Points</a></li>
<li><a href="chap28.html#primsrast-lines">27.11. Line Segments</a></li>
<li><a href="chap28.html#primsrast-polygons">27.12. Polygons</a></li>
</ul>
</li>
<li><a href="chap29.html#fragops">28. Fragment Operations</a>
<ul class="sectlevel2">
<li><a href="chap29.html#fragops-discard-rectangles">28.1. Discard Rectangles Test</a></li>
<li><a href="chap29.html#fragops-scissor">28.2. Scissor Test</a></li>
<li><a href="chap29.html#fragops-exclusive-scissor">28.3. Exclusive Scissor Test</a></li>
<li><a href="chap29.html#fragops-samplemask">28.4. Sample Mask Test</a></li>
<li><a href="chap29.html#fragops-covg">28.5. Multisample Coverage</a></li>
<li><a href="chap29.html#fragops-ds-state">28.6. Depth and Stencil Operations</a></li>
<li><a href="chap29.html#fragops-dbt">28.7. Depth Bounds Test</a></li>
<li><a href="chap29.html#fragops-stencil">28.8. Stencil Test</a></li>
<li><a href="chap29.html#fragops-depth">28.9. Depth Test</a></li>
<li><a href="chap29.html#fragops-rep-frag-test">28.10. Representative Fragment Test</a></li>
<li><a href="chap29.html#fragops-samplecount">28.11. Sample Counting</a></li>
<li><a href="chap29.html#fragops-coverage-to-color">28.12. Fragment Coverage To Color</a></li>
<li><a href="chap29.html#fragops-coverage-reduction">28.13. Coverage Reduction</a></li>
</ul>
</li>
<li><a href="chap30.html#framebuffer">29. The Framebuffer</a>
<ul class="sectlevel2">
<li><a href="chap30.html#framebuffer-blending">29.1. Blending</a></li>
<li><a href="chap30.html#framebuffer-logicop">29.2. Logical Operations</a></li>
<li><a href="chap30.html#framebuffer-color-write-mask">29.3. Color Write Mask</a></li>
</ul>
</li>
<li><a href="chap31.html#dispatch">30. Dispatching Commands</a></li>
<li><a href="chap32.html#device-generated-commands">31. Device-Generated Commands</a>
<ul class="sectlevel2">
<li><a href="chap32.html#indirectmdslayout">31.1. Indirect Commands Layout</a></li>
<li><a href="chap32.html#_indirect_commands_generation_and_execution">31.2. Indirect Commands Generation And Execution</a></li>
</ul>
</li>
<li><a href="chap33.html#sparsememory">32. Sparse Resources</a>
<ul class="sectlevel2">
<li><a href="chap33.html#sparsememory-sparseresourcefeatures">32.1. Sparse Resource Features</a></li>
<li><a href="chap33.html#sparsememory-fully-resident">32.2. Sparse Buffers and Fully-Resident Images</a></li>
<li><a href="chap33.html#sparsememory-partially-resident-buffers">32.3. Sparse Partially-Resident Buffers</a></li>
<li><a href="chap33.html#sparsememory-partially-resident-images">32.4. Sparse Partially-Resident Images</a></li>
<li><a href="chap33.html#sparsememory-sparse-memory-aliasing">32.5. Sparse Memory Aliasing</a></li>
<li><a href="chap33.html#_sparse_resource_implementation_guidelines_informative">32.6. Sparse Resource Implementation Guidelines (Informative)</a></li>
<li><a href="chap33.html#sparsememory-resourceapi">32.7. Sparse Resource API</a></li>
</ul>
</li>
<li><a href="chap34.html#wsi">33. Window System Integration (WSI)</a>
<ul class="sectlevel2">
<li><a href="chap34.html#_wsi_platform">33.1. WSI Platform</a></li>
<li><a href="chap34.html#_wsi_surface">33.2. WSI Surface</a></li>
<li><a href="chap34.html#display">33.3. Presenting Directly to Display Devices</a></li>
<li><a href="chap34.html#_querying_for_wsi_support">33.4. Querying for WSI Support</a></li>
<li><a href="chap34.html#_surface_queries">33.5. Surface Queries</a></li>
<li><a href="chap34.html#_full_screen_exclusive_control">33.6. Full Screen Exclusive Control</a></li>
<li><a href="chap34.html#_device_group_queries">33.7. Device Group Queries</a></li>
<li><a href="chap34.html#_display_timing_queries">33.8. Display Timing Queries</a></li>
<li><a href="chap34.html#_wsi_swapchain">33.9. WSI Swapchain</a></li>
<li><a href="chap34.html#_hdr_metadata">33.10. Hdr Metadata</a></li>
</ul>
</li>
<li><a href="chap35.html#deferred-host-operations">34. Deferred Host Operations</a>
<ul class="sectlevel2">
<li><a href="chap35.html#deferred-host-operations-requesting">34.1. Requesting Deferral</a></li>
<li><a href="chap35.html#_deferred_host_operations_api">34.2. Deferred Host Operations API</a></li>
</ul>
</li>
<li><a href="chap36.html#private-data">35. Private Data</a></li>
<li><a href="chap37.html#acceleration-structure">36. Acceleration Structures</a>
<ul class="sectlevel2">
<li><a href="chap37.html#acceleration-structure-def">36.1. Acceleration Structures</a></li>
<li><a href="chap37.html#host-acceleration-structure">36.2. Host Acceleration Structure Operations</a></li>
</ul>
</li>
<li><a href="chap38.html#ray-traversal">37. Ray Traversal</a>
<ul class="sectlevel2">
<li><a href="chap38.html#ray-intersection-candidate-determination">37.1. Ray Intersection Candidate Determination</a></li>
<li><a href="chap38.html#ray-intersection-culling">37.2. Ray Intersection Culling</a></li>
<li><a href="chap38.html#ray-intersection-confirmation">37.3. Ray Intersection Confirmation</a></li>
<li><a href="chap38.html#ray-closest-hit-determination">37.4. Ray Closest Hit Determination</a></li>
<li><a href="chap38.html#ray-result-determination">37.5. Ray Result Determination</a></li>
</ul>
</li>
<li><a href="chap39.html#ray-tracing">38. Ray Tracing</a>
<ul class="sectlevel2">
<li><a href="chap39.html#ray-tracing-shader-call">38.1. Shader Call Instructions</a></li>
<li><a href="chap39.html#ray-tracing-commands">38.2. Ray Tracing Commands</a></li>
<li><a href="chap39.html#shader-binding-table">38.3. Shader Binding Table</a></li>
<li><a href="chap39.html#ray-tracing-pipeline-stack">38.4. Ray Tracing Pipeline Stack</a></li>
</ul>
</li>
<li><a href="chap40.html#extendingvulkan">39. Extending Vulkan</a>
<ul class="sectlevel2">
<li><a href="chap40.html#extendingvulkan-instanceanddevicefunctionality">39.1. Instance and Device Functionality</a></li>
<li><a href="chap40.html#extendingvulkan-coreversions">39.2. Core Versions</a></li>
<li><a href="chap40.html#extendingvulkan-layers">39.3. Layers</a></li>
<li><a href="chap40.html#extendingvulkan-extensions">39.4. Extensions</a></li>
<li><a href="chap40.html#extendingvulkan-extensions-extensiondependencies">39.5. Extension Dependencies</a></li>
<li><a href="chap40.html#_compatibility_guarantees_informative">39.6. Compatibility Guarantees (Informative)</a></li>
</ul>
</li>
<li><a href="chap41.html#features">40. Features</a>
<ul class="sectlevel2">
<li><a href="chap41.html#features-requirements">40.1. Feature Requirements</a></li>
</ul>
</li>
<li><a href="chap42.html#limits">41. Limits</a>
<ul class="sectlevel2">
<li><a href="chap42.html#limits-minmax">41.1. Limit Requirements</a></li>
<li><a href="chap42.html#limits-multisample">41.2. Additional Multisampling Capabilities</a></li>
</ul>
</li>
<li><a href="chap43.html#formats">42. Formats</a>
<ul class="sectlevel2">
<li><a href="chap43.html#formats-definition">42.1. Format Definition</a></li>
<li><a href="chap43.html#formats-properties">42.2. Format Properties</a></li>
<li><a href="chap43.html#features-required-format-support">42.3. Required Format Support</a></li>
</ul>
</li>
<li><a href="chap44.html#capabilities">43. Additional Capabilities</a>
<ul class="sectlevel2">
<li><a href="chap44.html#capabilities-image">43.1. Additional Image Capabilities</a></li>
<li><a href="chap44.html#capabilities-buffer">43.2. Additional Buffer Capabilities</a></li>
<li><a href="chap44.html#capabilities-semaphore">43.3. Optional Semaphore Capabilities</a></li>
<li><a href="chap44.html#capabilities-fence">43.4. Optional Fence Capabilities</a></li>
<li><a href="chap44.html#features-timestamp-calibration">43.5. Timestamp Calibration Capabilities</a></li>
</ul>
</li>
<li><a href="chap45.html#_debugging">44. Debugging</a>
<ul class="sectlevel2">
<li><a href="chap45.html#debugging-debug-utils">44.1. Debug Utilities</a></li>
<li><a href="chap45.html#debugging-debug-markers">44.2. Debug Markers</a></li>
<li><a href="chap45.html#debugging-debug-report-callbacks">44.3. Debug Report Callbacks</a></li>
<li><a href="chap45.html#_device_loss_debugging">44.4. Device Loss Debugging</a></li>
<li><a href="chap45.html#debugging-tooling-info">44.5. Active Tooling Information</a></li>
</ul>
</li>
<li><a href="chap46.html#spirvenv">Appendix A: Vulkan Environment for SPIR-V</a>
<ul class="sectlevel2">
<li><a href="chap46.html#_versions_and_formats">Versions and Formats</a></li>
<li><a href="chap46.html#spirvenv-capabilities">Capabilities</a></li>
<li><a href="chap46.html#spirvenv-module-validation">Validation Rules within a Module</a></li>
<li><a href="chap46.html#spirvenv-precision-operation">Precision and Operation of SPIR-V Instructions</a></li>
<li><a href="chap46.html#spirvenv-format-type-matching">Image Format and Type Matching</a></li>
<li><a href="chap46.html#spirvenv-image-formats">Compatibility Between SPIR-V Image Formats And Vulkan Formats</a></li>
</ul>
</li>
<li><a href="chap47.html#memory-model">Appendix B: Memory Model</a>
<ul class="sectlevel2">
<li><a href="chap47.html#memory-model-agent">Agent</a></li>
<li><a href="chap47.html#memory-model-memory-location">Memory Location</a></li>
<li><a href="chap47.html#memory-model-allocation">Allocation</a></li>
<li><a href="chap47.html#memory-model-memory-operation">Memory Operation</a></li>
<li><a href="chap47.html#memory-model-references">Reference</a></li>
<li><a href="chap47.html#memory-model-program-order">Program-Order</a></li>
<li><a href="chap47.html#shader-call-related">Shader Call Related</a></li>
<li><a href="chap47.html#shader-call-order">Shader Call Order</a></li>
<li><a href="chap47.html#memory-model-scope">Scope</a></li>
<li><a href="chap47.html#memory-model-atomic-operation">Atomic Operation</a></li>
<li><a href="chap47.html#memory-model-scoped-modification-order">Scoped Modification Order</a></li>
<li><a href="chap47.html#memory-model-memory-semantics">Memory Semantics</a></li>
<li><a href="chap47.html#memory-model-release-sequence">Release Sequence</a></li>
<li><a href="chap47.html#memory-model-synchronizes-with">Synchronizes-With</a></li>
<li><a href="chap47.html#memory-model-system-synchronizes-with">System-Synchronizes-With</a></li>
<li><a href="chap47.html#memory-model-non-private">Private vs. Non-Private</a></li>
<li><a href="chap47.html#memory-model-inter-thread-happens-before">Inter-Thread-Happens-Before</a></li>
<li><a href="chap47.html#memory-model-happens-before">Happens-Before</a></li>
<li><a href="chap47.html#memory-model-availability-visibility">Availability and Visibility</a></li>
<li><a href="chap47.html#memory-model-vulkan-availability-visibility">Availability, Visibility, and Domain Operations</a></li>
<li><a href="chap47.html#memory-model-availability-visibility-semantics">Availability and Visibility Semantics</a></li>
<li><a href="chap47.html#memory-model-instruction-av-vis">Per-Instruction Availability and Visibility Semantics</a></li>
<li><a href="chap47.html#memory-model-location-ordered">Location-Ordered</a></li>
<li><a href="chap47.html#memory-model-access-data-race">Data Race</a></li>
<li><a href="chap47.html#memory-model-visible-to">Visible-To</a></li>
<li><a href="chap47.html#memory-model-acyclicity">Acyclicity</a></li>
<li><a href="chap47.html#memory-model-shader-io">Shader I/O</a></li>
<li><a href="chap47.html#memory-model-deallocation">Deallocation</a></li>
<li><a href="chap47.html#memory-model-informative-descriptions">Descriptions (Informative)</a></li>
<li><a href="chap47.html#memory-model-tessellation-output-ordering">Tessellation Output Ordering</a></li>
<li><a href="chap47.html#memory-model-cooperative-matrix">Cooperative Matrix Memory Access</a></li>
</ul>
</li>
<li><a href="chap48.html#_compressed_image_formats">Appendix C: Compressed Image Formats</a>
<ul class="sectlevel2">
<li><a href="chap48.html#appendix-compressedtex-bc">Block-Compressed Image Formats</a></li>
<li><a href="chap48.html#appendix-compressedtex-etc2">ETC Compressed Image Formats</a></li>
<li><a href="chap48.html#appendix-compressedtex-astc">ASTC Compressed Image Formats</a></li>
<li><a href="chap48.html#appendix-compressedtex-pvrtc">PVRTC Compressed Image Formats</a></li>
</ul>
</li>
<li><a href="chap49.html#versions">Appendix D: Core Revisions (Informative)</a>
<ul class="sectlevel2">
<li><a href="chap49.html#versions-1.1">Version 1.1</a></li>
</ul>
</li>
<li><a href="chap50.html#extensions">Appendix E: Layers &amp; Extensions (Informative)</a>
<ul class="sectlevel2">
<li><a href="chap50.html#extension-appendices-list">List of Current Extensions</a></li>
<li><a href="chap50.html#provisional-extension-appendices-list">List of Provisional Extensions</a></li>
<li><a href="chap50.html#deprecated-extension-appendices-list">List of Deprecated Extensions</a></li>
</ul>
</li>
<li><a href="chap51.html#boilerplate">Appendix F: API Boilerplate</a>
<ul class="sectlevel2">
<li><a href="chap51.html#boilerplate-headers">Vulkan Header Files</a></li>
<li><a href="chap51.html#boilerplate-wsi-header">Window System-Specific Header Control (Informative)</a></li>
<li><a href="chap51.html#boilerplate-provisional-header">Provisional Extension Header Control (Informative)</a></li>
</ul>
</li>
<li><a href="chap52.html#invariance">Appendix G: Invariance</a>
<ul class="sectlevel2">
<li><a href="chap52.html#_repeatability">Repeatability</a></li>
<li><a href="chap52.html#_multi_pass_algorithms">Multi-pass Algorithms</a></li>
<li><a href="chap52.html#_invariance_rules">Invariance Rules</a></li>
<li><a href="chap52.html#_tessellation_invariance">Tessellation Invariance</a></li>
</ul>
</li>
<li><a href="chap53.html#lexicon">Appendix H: Lexicon</a>
<ul class="sectlevel2">
<li><a href="chap53.html#glossary">Glossary</a></li>
<li><a href="chap53.html#lexicon-common-abbreviations">Common Abbreviations</a></li>
<li><a href="chap53.html#lexicon-prefixes">Prefixes</a></li>
</ul>
</li>
<li><a href="chap54.html#credits">Appendix I: Credits (Informative)</a>
<ul class="sectlevel2">
<li><a href="chap54.html#_working_group_contributors_to_vulkan">Working Group Contributors to Vulkan</a></li>
<li><a href="chap54.html#_other_credits">Other Credits</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="loading_msg" class="hidden" hidden=""><p>Loading… please wait.</p></div>
<!--ChunkedSearchboxMarker-->
<div class="searchbox"><label for="searchbox">Search: </label><input id="searchbox" type="text" disabled="disabled" value="Loading Search Data"><div id="resultsdiv"><ol id="results"></ol></div></div>
<div id="content"><div class="sect1">
<h2 id="descriptorsets"><a class="anchor" href="#descriptorsets"></a>14. Resource Descriptors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <em>descriptor</em> is an opaque data structure representing a shader resource
such as a buffer, buffer view, image view, sampler, or combined image
sampler.
Descriptors are organised into <em>descriptor sets</em>, which are bound during
command recording for use in subsequent draw commands.
The arrangement of content in each descriptor set is determined by a
<em>descriptor set layout</em>, which determines what descriptors can be stored
within it.
The sequence of descriptor set layouts that <strong class="purple">can</strong> be used by a pipeline is
specified in a <em>pipeline layout</em>.
Each pipeline object <strong class="purple">can</strong> use up to <code>maxBoundDescriptorSets</code> (see
<a href="chap42.html#limits">Limits</a>) descriptor sets.</p>
</div>
<div class="paragraph">
<p>Shaders access resources via variables decorated with a descriptor set and
binding number that link them to a descriptor in a descriptor set.
The shader interface mapping to bound descriptor sets is described in the
<a href="chap16.html#interfaces-resources">Shader Resource Interface</a> section.</p>
</div>
<div class="paragraph">
<p>Shaders <strong class="purple">can</strong> also access buffers without going through descriptors by using
<a href="#descriptorsets-physical-storage-buffer">Physical Storage Buffer Access</a> to
access them through 64-bit addresses.</p>
</div>
<div class="sect2">
<h3 id="descriptorsets-types"><a class="anchor" href="#descriptorsets-types"></a>14.1. Descriptor Types</h3>
<div class="paragraph">
<p>There are a number of different types of descriptor supported by Vulkan,
corresponding to different resources or usage.
The following sections describe the API definitions of each descriptor type.
The mapping of each type to SPIR-V is listed in the
<a href="chap16.html#interfaces-resources-correspondence">Shader Resource and Descriptor Type
Correspondence</a> and <a href="chap16.html#interfaces-resources-storage-class-correspondence">Shader Resource and Storage Class Correspondence</a> tables in the
<a href="chap16.html#interfaces">Shader Interfaces</a> chapter.</p>
</div>
<div class="sect3">
<h4 id="descriptorsets-storageimage"><a class="anchor" href="#descriptorsets-storageimage"></a>14.1.1. Storage Image</h4>
<div class="paragraph">
<p>A <em>storage image</em> (<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>) is a descriptor
type associated with an <a href="chap13.html#resources-images">image resource</a> via an
<a href="chap13.html#resources-image-views">image view</a> that load, store, and atomic
operations <strong class="purple">can</strong> be performed on.</p>
</div>
<div class="paragraph">
<p>Storage image loads are supported in all shader stages for image views whose
<a href="chap13.html#resources-image-view-format-features">format features</a> contain
<a href="chap43.html#formats-properties"><code>VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT</code></a>.</p>
</div>
<div class="paragraph">
<p>Stores to storage images are supported in compute shaders for image views
whose <a href="chap13.html#resources-image-view-format-features">format features</a> contain
<a href="chap43.html#formats-properties"><code>VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT</code></a>.</p>
</div>
<div class="paragraph">
<p>Atomic operations on storage images are supported in compute shaders for
image views whose <a href="chap13.html#resources-image-view-format-features">format features</a>
contain
<a href="chap43.html#formats-properties"><code>VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT</code></a>.</p>
</div>
<div class="paragraph">
<p>When the <a href="chap41.html#features-fragmentStoresAndAtomics"><code>fragmentStoresAndAtomics</code></a> feature is enabled, stores and atomic
operations are also supported for storage images in fragment shaders with
the same set of image formats as supported in compute shaders.
When the <a href="chap41.html#features-vertexPipelineStoresAndAtomics"><code>vertexPipelineStoresAndAtomics</code></a> feature is enabled, stores and atomic
operations are also supported in vertex, tessellation, and geometry shaders
with the same set of image formats as supported in compute shaders.</p>
</div>
<div class="paragraph">
<p>The image subresources for a storage image <strong class="purple">must</strong> be in the
<code>VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR</code> or
<code>VK_IMAGE_LAYOUT_GENERAL</code> layout in order to access its data in a
shader.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-sampler"><a class="anchor" href="#descriptorsets-sampler"></a>14.1.2. Sampler</h4>
<div class="paragraph">
<p>A <em>sampler descriptor</em> (<code>VK_DESCRIPTOR_TYPE_SAMPLER</code>) is a descriptor
type associated with a <a href="chap14.html#samplers">sampler</a> object, used to control the
behavior of <a href="chap17.html#textures">sampling operations</a> performed on a
<a href="#descriptorsets-sampledimage">sampled image</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-sampledimage"><a class="anchor" href="#descriptorsets-sampledimage"></a>14.1.3. Sampled Image</h4>
<div class="paragraph">
<p>A <em>sampled image</em> (<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>) is a descriptor
type associated with an <a href="chap13.html#resources-images">image resource</a> via an
<a href="chap13.html#resources-image-views">image view</a> that <a href="chap17.html#textures">sampling operations</a>
<strong class="purple">can</strong> be performed on.</p>
</div>
<div class="paragraph">
<p>Shaders combine a sampled image variable and a sampler variable to perform
sampling operations.</p>
</div>
<div class="paragraph">
<p>Sampled images are supported in all shader stages for image views whose
<a href="chap13.html#resources-image-view-format-features">format features</a> contain
<a href="chap43.html#formats-properties"><code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</code></a>.</p>
</div>
<div class="paragraph">
<p>The image subresources for a sampled image <strong class="purple">must</strong> be in the
<code>VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>, or
<code>VK_IMAGE_LAYOUT_GENERAL</code> layout in order to access its data in a
shader.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-combinedimagesampler"><a class="anchor" href="#descriptorsets-combinedimagesampler"></a>14.1.4. Combined Image Sampler</h4>
<div class="paragraph">
<p>A <em>combined image sampler</em> (<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>)
is a single descriptor type associated with both a <a href="chap14.html#samplers">sampler</a> and
an <a href="chap13.html#resources-images">image resource</a>, combining both a
<a href="#descriptorsets-sampler">sampler</a> and <a href="#descriptorsets-sampledimage">sampled image</a> descriptor into a single descriptor.</p>
</div>
<div class="paragraph">
<p>If the descriptor refers to a sampler that performs
<a href="chap14.html#samplers-YCbCr-conversion">Y′C<sub>B</sub>C<sub>R</sub> conversion</a> or samples a
<a href="chap14.html#samplers-subsamplesampler">subsampled image</a>,
the sampler <strong class="purple">must</strong> only be used to sample the image in the same descriptor.
Otherwise, the
sampler and image in this type of descriptor <strong class="purple">can</strong> be used freely with any
other samplers and images.</p>
</div>
<div class="paragraph">
<p>The image subresources for a combined image sampler <strong class="purple">must</strong> be in the
<code>VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>, or
<code>VK_IMAGE_LAYOUT_GENERAL</code> layout in order to access its data in a
shader.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>On some implementations, it <strong class="purple">may</strong> be more efficient to sample from an image
using a combination of sampler and sampled image that are stored together in
the descriptor set in a combined descriptor.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-uniformtexelbuffer"><a class="anchor" href="#descriptorsets-uniformtexelbuffer"></a>14.1.5. Uniform Texel Buffer</h4>
<div class="paragraph">
<p>A <em>uniform texel buffer</em> (<code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>) is
a descriptor type associated with a <a href="chap13.html#resources-buffers">buffer resource</a>
via a <a href="chap13.html#resources-buffer-views">buffer view</a> that <a href="chap17.html#textures">formatted load
operations</a> <strong class="purple">can</strong> be performed on.</p>
</div>
<div class="paragraph">
<p>Uniform texel buffers define a tightly-packed 1-dimensional linear array of
texels, with texels going through format conversion when read in a shader in
the same way as they are for an image.</p>
</div>
<div class="paragraph">
<p>Load operations from uniform texel buffers are supported in all shader
stages for image formats which report support for the
<a href="chap43.html#formats-properties"><code>VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT</code></a>
feature bit via <a href="chap43.html#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a> in
<a href="chap43.html#VkFormatProperties">VkFormatProperties</a>::<code>bufferFeatures</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-storagetexelbuffer"><a class="anchor" href="#descriptorsets-storagetexelbuffer"></a>14.1.6. Storage Texel Buffer</h4>
<div class="paragraph">
<p>A <em>storage texel buffer</em> (<code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>) is
a descriptor type associated with a <a href="chap13.html#resources-buffers">buffer resource</a>
via a <a href="chap13.html#resources-buffer-views">buffer view</a> that <a href="chap17.html#textures">formatted
load, store, and atomic operations</a> <strong class="purple">can</strong> be performed on.</p>
</div>
<div class="paragraph">
<p>Storage texel buffers define a tightly-packed 1-dimensional linear array of
texels, with texels going through format conversion when read in a shader in
the same way as they are for an image.
Unlike <a href="#descriptorsets-uniformtexelbuffer">uniform texel buffers</a>, these
buffers can also be written to in the same way as for
<a href="#descriptorsets-storageimage">storage images</a>.</p>
</div>
<div class="paragraph">
<p>Storage texel buffer loads are supported in all shader stages for texel
buffer formats which report support for the
<a href="chap43.html#formats-properties"><code>VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT</code></a>
feature bit via <a href="chap43.html#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a> in
<a href="chap43.html#VkFormatProperties">VkFormatProperties</a>::<code>bufferFeatures</code>.</p>
</div>
<div class="paragraph">
<p>Stores to storage texel buffers are supported in compute shaders for texel
buffer formats which report support for the
<code>VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT</code> feature via
<a href="chap43.html#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a> in
<a href="chap43.html#VkFormatProperties">VkFormatProperties</a>::<code>bufferFeatures</code>.</p>
</div>
<div class="paragraph">
<p>Atomic operations on storage texel buffers are supported in compute shaders
for texel buffer formats which report support for the
<a href="chap43.html#formats-properties"><code>VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT</code></a>
feature via <a href="chap43.html#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a> in
<a href="chap43.html#VkFormatProperties">VkFormatProperties</a>::<code>bufferFeatures</code>.</p>
</div>
<div class="paragraph">
<p>When the <a href="chap41.html#features-fragmentStoresAndAtomics"><code>fragmentStoresAndAtomics</code></a> feature is enabled, stores and atomic
operations are also supported for storage texel buffers in fragment shaders
with the same set of texel buffer formats as supported in compute shaders.
When the <a href="chap41.html#features-vertexPipelineStoresAndAtomics"><code>vertexPipelineStoresAndAtomics</code></a> feature is enabled, stores and atomic
operations are also supported in vertex, tessellation, and geometry shaders
with the same set of texel buffer formats as supported in compute shaders.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-storagebuffer"><a class="anchor" href="#descriptorsets-storagebuffer"></a>14.1.7. Storage Buffer</h4>
<div class="paragraph">
<p>A <em>storage buffer</em> (<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>) is a descriptor
type associated with a <a href="chap13.html#resources-buffers">buffer resource</a> directly,
described in a shader as a structure with various members that load, store,
and atomic operations <strong class="purple">can</strong> be performed on.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Atomic operations <strong class="purple">can</strong> only be performed on members of certain types as
defined in the <a href="chap46.html#spirvenv">SPIR-V environment appendix</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-uniformbuffer"><a class="anchor" href="#descriptorsets-uniformbuffer"></a>14.1.8. Uniform Buffer</h4>
<div class="paragraph">
<p>A <em>uniform buffer</em> (<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>) is a descriptor
type associated with a <a href="chap13.html#resources-buffers">buffer resource</a> directly,
described in a shader as a structure with various members that load
operations <strong class="purple">can</strong> be performed on.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-uniformbufferdynamic"><a class="anchor" href="#descriptorsets-uniformbufferdynamic"></a>14.1.9. Dynamic Uniform Buffer</h4>
<div class="paragraph">
<p>A <em>dynamic uniform buffer</em> (<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>)
is almost identical to a <a href="#descriptorsets-uniformbuffer">uniform buffer</a>,
and differs only in how the offset into the buffer is specified.
The base offset calculated by the <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a> when
initially <a href="#descriptorsets-updates">updating the descriptor set</a> is added
to a <a href="#descriptorsets-binding-dynamicoffsets">dynamic offset</a> when binding
the descriptor set.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-storagebufferdynamic"><a class="anchor" href="#descriptorsets-storagebufferdynamic"></a>14.1.10. Dynamic Storage Buffer</h4>
<div class="paragraph">
<p>A <em>dynamic storage buffer</em> (<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>)
is almost identical to a <a href="#descriptorsets-storagebuffer">storage buffer</a>,
and differs only in how the offset into the buffer is specified.
The base offset calculated by the <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a> when
initially <a href="#descriptorsets-updates">updating the descriptor set</a> is added
to a <a href="#descriptorsets-binding-dynamicoffsets">dynamic offset</a> when binding
the descriptor set.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-inlineuniformblock"><a class="anchor" href="#descriptorsets-inlineuniformblock"></a>14.1.11. Inline Uniform Block</h4>
<div class="paragraph">
<p>An <em>inline uniform block</em>
(<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>) is almost identical to a
<a href="#descriptorsets-uniformbuffer">uniform buffer</a>, and differs only in taking
its storage directly from the encompassing descriptor set instead of being
backed by buffer memory.
It is typically used to access a small set of constant data that does not
require the additional flexibility provided by the indirection enabled when
using a uniform buffer where the descriptor and the referenced buffer memory
are decoupled.
Compared to push constants, they allow reusing the same set of constant data
across multiple disjoint sets of draw and dispatch commands.</p>
</div>
<div class="paragraph">
<p>Inline uniform block descriptors <strong class="purple">cannot</strong> be aggregated into arrays.
Instead, the array size specified for an inline uniform block descriptor
binding specifies the binding’s capacity in bytes.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-inputattachment"><a class="anchor" href="#descriptorsets-inputattachment"></a>14.1.12. Input Attachment</h4>
<div class="paragraph">
<p>An <em>input attachment</em> (<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>) is a
descriptor type associated with an <a href="chap13.html#resources-images">image resource</a> via
an <a href="chap13.html#resources-image-views">image view</a> that <strong class="purple">can</strong> be used for
<a href="chap8.html#synchronization-framebuffer-regions">framebuffer local</a> load operations in
fragment shaders.</p>
</div>
<div class="paragraph">
<p>All image formats that are supported for color attachments
(<code>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</code>) or depth/stencil attachments
(<code>VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</code>) for a given image
tiling mode are also supported for input attachments.</p>
</div>
<div class="paragraph">
<p>The image subresources for an input attachment <strong class="purple">must</strong> be in a
<a href="chap9.html#attachment-type-imagelayout">valid image layout</a> in order to access its
data in a shader.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-accelerationstructure"><a class="anchor" href="#descriptorsets-accelerationstructure"></a>14.1.13. Acceleration Structure</h4>
<div class="paragraph">
<p>An <em>acceleration structure</em> (
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code>
or
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV</code>
) is a descriptor type that is used to retrieve scene geometry from within
shaders that are used for ray traversal.
Shaders have read-only access to the memory.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-mutable"><a class="anchor" href="#descriptorsets-mutable"></a>14.1.14. Mutable</h4>
<div class="paragraph">
<p>A descriptor of <em>mutable</em> (<code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>) type
indicates that this descriptor <strong class="purple">can</strong> mutate to any of the descriptor types
given in the
<a href="#VkMutableDescriptorTypeCreateInfoVALVE">VkMutableDescriptorTypeCreateInfoVALVE</a>::<code>pDescriptorTypes</code> list of
descriptor types in the pNext chain of <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>
for this binding.
At any point, each individual descriptor of mutable type has an active
descriptor type.
The active descriptor type <strong class="purple">can</strong> be any one of the declared types in
<code>pDescriptorTypes</code>.
Additionally, a mutable descriptor’s active descriptor type <strong class="purple">can</strong> be of the
<code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code> type, which is the initial active
descriptor type.
The active descriptor type <strong class="purple">can</strong> change when the descriptor is updated.
When a descriptor is consumed by binding a descriptor set, the active
descriptor type is considered, not <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>.</p>
</div>
<div class="paragraph">
<p>An active descriptor type of <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code> is
considered an undefined descriptor.
If a descriptor is consumed where the active descriptor type does not match
what the shader expects, the descriptor is considered an undefined
descriptor.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>To find which descriptor types are supported as
<code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>, the application <strong class="purple">can</strong> use
<a href="#vkGetDescriptorSetLayoutSupport">vkGetDescriptorSetLayoutSupport</a> with an
<code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code> binding, with the list of descriptor
types to query in the
<a href="#VkMutableDescriptorTypeCreateInfoVALVE">VkMutableDescriptorTypeCreateInfoVALVE</a>::<code>pDescriptorTypes</code> array
for that binding.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>The intention of a mutable descriptor type is that implementations allocate
N bytes per descriptor, where N is determined by the maximum descriptor size
for a given descriptor binding.
Implementations are not expected to keep track of the active descriptor
type, and it should be considered a C-like union type.</p>
</div>
<div class="paragraph">
<p>A mutable descriptor type is not considered as efficient in terms of
run-time performance as using a non-mutable descriptor type, and
applications are not encouraged to use them outside API layering efforts.
Mutable descriptor types can be more efficient if the alternative is using
many different descriptors to emulate mutable descriptor types.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="descriptorsets-sets"><a class="anchor" href="#descriptorsets-sets"></a>14.2. Descriptor Sets</h3>
<div class="paragraph">
<p>Descriptors are grouped together into descriptor set objects.
A descriptor set object is an opaque object containing storage for a set of
descriptors, where the types and number of descriptors is defined by a
descriptor set layout.
The layout object <strong class="purple">may</strong> be used to define the association of each descriptor
binding with memory or other implementation resources.
The layout is used both for determining the resources that need to be
associated with the descriptor set, and determining the interface between
shader stages and shader resources.</p>
</div>
<div class="sect3">
<h4 id="descriptorsets-setlayout"><a class="anchor" href="#descriptorsets-setlayout"></a>14.2.1. Descriptor Set Layout</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>A descriptor set layout object is defined by an array of zero or more
descriptor bindings.
Each individual descriptor binding is specified by a descriptor type, a
count (array size) of the number of descriptors in the binding, a set of
shader stages that <strong class="purple">can</strong> access the binding, and (if using immutable
samplers) an array of sampler descriptors.</p>
</div>
<div class="paragraph">
<p>Descriptor set layout objects are represented by <code>VkDescriptorSetLayout</code>
handles:</p>
</div>
<div id="VkDescriptorSetLayout" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create descriptor set layout objects, call:</p>
</div>
<div id="vkCreateDescriptorSetLayout" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
VkResult vkCreateDescriptorSetLayout(
    VkDevice                                    device,
    <span class="directive">const</span> VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkDescriptorSetLayout*                      pSetLayout);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that creates the descriptor set
layout.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to a
<a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a> structure specifying the state of
the descriptor set layout object.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap12.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
<li>
<p><code>pSetLayout</code> is a pointer to a <a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a> handle in
which the resulting descriptor set layout object is returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateDescriptorSetLayout-device-parameter" href="#VUID-vkCreateDescriptorSetLayout-device-parameter"></a> <span class="vuid">VUID-vkCreateDescriptorSetLayout-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorSetLayout-pCreateInfo-parameter" href="#VUID-vkCreateDescriptorSetLayout-pCreateInfo-parameter"></a> <span class="vuid">VUID-vkCreateDescriptorSetLayout-pCreateInfo-parameter</span><br>
 <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorSetLayout-pAllocator-parameter" href="#VUID-vkCreateDescriptorSetLayout-pAllocator-parameter"></a> <span class="vuid">VUID-vkCreateDescriptorSetLayout-pAllocator-parameter</span><br>
 If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap12.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorSetLayout-pSetLayout-parameter" href="#VUID-vkCreateDescriptorSetLayout-pSetLayout-parameter"></a> <span class="vuid">VUID-vkCreateDescriptorSetLayout-pSetLayout-parameter</span><br>
 <code>pSetLayout</code> <strong class="purple">must</strong> be a valid pointer to a <a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap4.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap4.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Information about the descriptor set layout is passed in a
<code>VkDescriptorSetLayoutCreateInfo</code> structure:</p>
</div>
<div id="VkDescriptorSetLayoutCreateInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorSetLayoutCreateInfo {
    VkStructureType                        sType;
    <span class="directive">const</span> <span class="directive">void</span>*                            pNext;
    VkDescriptorSetLayoutCreateFlags       flags;
    uint32_t                               bindingCount;
    <span class="directive">const</span> VkDescriptorSetLayoutBinding*    pBindings;
} VkDescriptorSetLayoutCreateInfo;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>flags</code> is a bitmask
of <a href="#VkDescriptorSetLayoutCreateFlagBits">VkDescriptorSetLayoutCreateFlagBits</a>
specifying options for descriptor set layout creation.</p>
</li>
<li>
<p><code>bindingCount</code> is the number of elements in <code>pBindings</code>.</p>
</li>
<li>
<p><code>pBindings</code> is a pointer to an array of
<a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a> structures.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-binding-00279" href="#VUID-VkDescriptorSetLayoutCreateInfo-binding-00279"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-binding-00279</span><br>

The <a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a>::<code>binding</code> members of the
elements of the <code>pBindings</code> array <strong class="purple">must</strong> each have different values</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-flags-00280" href="#VUID-VkDescriptorSetLayoutCreateInfo-flags-00280"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-flags-00280</span><br>

If <code>flags</code> contains
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code>, then all
elements of <code>pBindings</code> <strong class="purple">must</strong> not have a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-flags-02208" href="#VUID-VkDescriptorSetLayoutCreateInfo-flags-02208"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-flags-02208</span><br>

If <code>flags</code> contains
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code>, then all
elements of <code>pBindings</code> <strong class="purple">must</strong> not have a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-flags-00281" href="#VUID-VkDescriptorSetLayoutCreateInfo-flags-00281"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-flags-00281</span><br>

If <code>flags</code> contains
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code>, then the
total number of elements of all bindings <strong class="purple">must</strong> be less than or equal to
<a href="chap42.html#VkPhysicalDevicePushDescriptorPropertiesKHR">VkPhysicalDevicePushDescriptorPropertiesKHR</a>::<code>maxPushDescriptors</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-flags-04590" href="#VUID-VkDescriptorSetLayoutCreateInfo-flags-04590"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-flags-04590</span><br>

If <code>flags</code> contains
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code>,
<code>flags</code> <strong class="purple">must</strong> not contain
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-flags-04591" href="#VUID-VkDescriptorSetLayoutCreateInfo-flags-04591"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-flags-04591</span><br>

If <code>flags</code> contains
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code>,
<code>pBindings</code> <strong class="purple">must</strong> not have a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-flags-03000" href="#VUID-VkDescriptorSetLayoutCreateInfo-flags-03000"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-flags-03000</span><br>

If any binding has the <code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code>
bit set, <code>flags</code> <strong class="purple">must</strong> include
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-03001" href="#VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-03001"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-03001</span><br>

If any binding has the <code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code>
bit set, then all bindings <strong class="purple">must</strong> not have <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-flags-04592" href="#VUID-VkDescriptorSetLayoutCreateInfo-flags-04592"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-flags-04592</span><br>

If <code>flags</code> contains
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code>,
<code>flags</code> <strong class="purple">must</strong> not contain
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-04593" href="#VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-04593"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-04593</span><br>

If any binding has a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>, then a
<a href="#VkMutableDescriptorTypeCreateInfoVALVE">VkMutableDescriptorTypeCreateInfoVALVE</a> <strong class="purple">must</strong> be present in the
<code>pNext</code> chain</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-04594" href="#VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-04594"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-04594</span><br>

If a binding has a <code>descriptorType</code> value of
<code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>, then <code>pImmutableSamplers</code>
<strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-mutableDescriptorType-04595" href="#VUID-VkDescriptorSetLayoutCreateInfo-mutableDescriptorType-04595"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-mutableDescriptorType-04595</span><br>

If
<a href="chap41.html#VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE">VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE</a>::<code>mutableDescriptorType</code>
is not enabled, <code>pBindings</code> <strong class="purple">must</strong> not contain a <code>descriptorType</code>
of <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-flags-04596" href="#VUID-VkDescriptorSetLayoutCreateInfo-flags-04596"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-flags-04596</span><br>

If <code>flags</code> contains
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE</code>,
<a href="chap41.html#VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE">VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE</a>::<code>mutableDescriptorType</code>
<strong class="purple">must</strong> be enabled</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-sType-sType" href="#VUID-VkDescriptorSetLayoutCreateInfo-sType-sType"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext" href="#VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext</span><br>
 Each <code>pNext</code> member of any structure (including this one) in the <code>pNext</code> chain <strong class="purple">must</strong> be either <code>NULL</code> or a pointer to a valid instance of <a href="#VkDescriptorSetLayoutBindingFlagsCreateInfo">VkDescriptorSetLayoutBindingFlagsCreateInfo</a> or <a href="#VkMutableDescriptorTypeCreateInfoVALVE">VkMutableDescriptorTypeCreateInfoVALVE</a></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-sType-unique" href="#VUID-VkDescriptorSetLayoutCreateInfo-sType-unique"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-sType-unique</span><br>
 The <code>sType</code> value of each struct in the <code>pNext</code> chain <strong class="purple">must</strong> be unique</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter" href="#VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter</span><br>
 <code>flags</code> <strong class="purple">must</strong> be a valid combination of <a href="#VkDescriptorSetLayoutCreateFlagBits">VkDescriptorSetLayoutCreateFlagBits</a> values</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter" href="#VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter"></a> <span class="vuid">VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter</span><br>
 If <code>bindingCount</code> is not <code>0</code>, <code>pBindings</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>bindingCount</code> valid <a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a> structures</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Information about the possible descriptor types for mutable descriptor types
is passed in a <code>VkMutableDescriptorTypeCreateInfoVALVE</code> structure as a
<code>pNext</code> to a <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a> structure or a
<a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a> structure.</p>
</div>
<div class="paragraph">
<p>The <code>VkMutableDescriptorTypeCreateInfoVALVE</code> structure is defined as:</p>
</div>
<div id="VkMutableDescriptorTypeCreateInfoVALVE" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VALVE_mutable_descriptor_type</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkMutableDescriptorTypeCreateInfoVALVE {
    VkStructureType                            sType;
    <span class="directive">const</span> <span class="directive">void</span>*                                pNext;
    uint32_t                                   mutableDescriptorTypeListCount;
    <span class="directive">const</span> VkMutableDescriptorTypeListVALVE*    pMutableDescriptorTypeLists;
} VkMutableDescriptorTypeCreateInfoVALVE;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>mutableDescriptorTypeListCount</code> is the number of elements in
<code>pMutableDescriptorTypeLists</code>.</p>
</li>
<li>
<p><code>pMutableDescriptorTypeLists</code> is a pointer to an array of
<code>VkMutableDescriptorTypeListVALVE</code> structures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>mutableDescriptorTypeListCount</code> is zero or if this structure is not
included in the <code>pNext</code> chain, the
<a href="#VkMutableDescriptorTypeListVALVE">VkMutableDescriptorTypeListVALVE</a> for each element is considered to be
zero or <code>NULL</code> for each member.
Otherwise, the descriptor set layout binding at
<a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>::<code>pBindings</code>[i] uses the
descriptor type lists in
<a href="#VkMutableDescriptorTypeCreateInfoVALVE">VkMutableDescriptorTypeCreateInfoVALVE</a>::<code>pMutableDescriptorTypeLists</code>[i].</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkMutableDescriptorTypeCreateInfoVALVE-sType-sType" href="#VUID-VkMutableDescriptorTypeCreateInfoVALVE-sType-sType"></a> <span class="vuid">VUID-VkMutableDescriptorTypeCreateInfoVALVE-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE</code></p>
</li>
<li>
<p><a id="VUID-VkMutableDescriptorTypeCreateInfoVALVE-pMutableDescriptorTypeLists-parameter" href="#VUID-VkMutableDescriptorTypeCreateInfoVALVE-pMutableDescriptorTypeLists-parameter"></a> <span class="vuid">VUID-VkMutableDescriptorTypeCreateInfoVALVE-pMutableDescriptorTypeLists-parameter</span><br>
 If <code>mutableDescriptorTypeListCount</code> is not <code>0</code>, <code>pMutableDescriptorTypeLists</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>mutableDescriptorTypeListCount</code> valid <a href="#VkMutableDescriptorTypeListVALVE">VkMutableDescriptorTypeListVALVE</a> structures</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The list of potential descriptor types a given mutable descriptor <strong class="purple">can</strong>
mutate to is passed in a <code>VkMutableDescriptorTypeListVALVE</code> structure.</p>
</div>
<div class="paragraph">
<p>The <code>VkMutableDescriptorTypeListVALVE</code> structure is defined as:</p>
</div>
<div id="VkMutableDescriptorTypeListVALVE" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VALVE_mutable_descriptor_type</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkMutableDescriptorTypeListVALVE {
    uint32_t                   descriptorTypeCount;
    <span class="directive">const</span> VkDescriptorType*    pDescriptorTypes;
} VkMutableDescriptorTypeListVALVE;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>descriptorTypeCount</code> is the number of elements in
<code>pDescriptorTypes</code>.</p>
</li>
<li>
<p><code>pDescriptorTypes</code> is <code>NULL</code> or a pointer to an array of
<code>descriptorTypeCount</code> <a href="#VkDescriptorType">VkDescriptorType</a> values which define
which descriptor types a given binding may mutate to.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkMutableDescriptorTypeListVALVE-descriptorTypeCount-04597" href="#VUID-VkMutableDescriptorTypeListVALVE-descriptorTypeCount-04597"></a> <span class="vuid">VUID-VkMutableDescriptorTypeListVALVE-descriptorTypeCount-04597</span><br>

<code>descriptorTypeCount</code> <strong class="purple">must</strong> not be <code>0</code> if the corresponding binding
is of <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code></p>
</li>
<li>
<p><a id="VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04598" href="#VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04598"></a> <span class="vuid">VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04598</span><br>

<code>pDescriptorTypes</code> <strong class="purple">must</strong> be a valid pointer to an array of
<code>descriptorTypeCount</code> valid, unique <a href="#VkDescriptorType">VkDescriptorType</a> values if
the given binding is of <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code> type</p>
</li>
<li>
<p><a id="VUID-VkMutableDescriptorTypeListVALVE-descriptorTypeCount-04599" href="#VUID-VkMutableDescriptorTypeListVALVE-descriptorTypeCount-04599"></a> <span class="vuid">VUID-VkMutableDescriptorTypeListVALVE-descriptorTypeCount-04599</span><br>

<code>descriptorTypeCount</code> <strong class="purple">must</strong> be <code>0</code> if the corresponding binding is
not of <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code></p>
</li>
<li>
<p><a id="VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04600" href="#VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04600"></a> <span class="vuid">VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04600</span><br>

<code>pDescriptorTypes</code> <strong class="purple">must</strong> not contain
<code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code></p>
</li>
<li>
<p><a id="VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04601" href="#VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04601"></a> <span class="vuid">VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04601</span><br>

<code>pDescriptorTypes</code> <strong class="purple">must</strong> not contain
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code></p>
</li>
<li>
<p><a id="VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04602" href="#VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04602"></a> <span class="vuid">VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04602</span><br>

<code>pDescriptorTypes</code> <strong class="purple">must</strong> not contain
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code></p>
</li>
<li>
<p><a id="VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04603" href="#VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04603"></a> <span class="vuid">VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-04603</span><br>

<code>pDescriptorTypes</code> <strong class="purple">must</strong> not contain
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-parameter" href="#VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-parameter"></a> <span class="vuid">VUID-VkMutableDescriptorTypeListVALVE-pDescriptorTypes-parameter</span><br>
 If <code>descriptorTypeCount</code> is not <code>0</code>, <code>pDescriptorTypes</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorTypeCount</code> valid <a href="#VkDescriptorType">VkDescriptorType</a> values</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Bits which <strong class="purple">can</strong> be set in <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>::<code>flags</code>
to specify options for descriptor set layout are:</p>
</div>
<div id="VkDescriptorSetLayoutCreateFlagBits" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> <span class="keyword">enum</span> VkDescriptorSetLayoutCreateFlagBits {
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = <span class="hex">0x00000002</span>,
  <span class="comment">// Provided by VK_KHR_push_descriptor</span>
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = <span class="hex">0x00000001</span>,
  <span class="comment">// Provided by VK_VALVE_mutable_descriptor_type</span>
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE = <span class="hex">0x00000004</span>,
  <span class="comment">// Provided by VK_EXT_descriptor_indexing</span>
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,
} VkDescriptorSetLayoutCreateFlagBits;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code> specifies
that descriptor sets <strong class="purple">must</strong> not be allocated using this layout, and
descriptors are instead pushed by <a href="#vkCmdPushDescriptorSetKHR">vkCmdPushDescriptorSetKHR</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code>
specifies that descriptor sets using this layout <strong class="purple">must</strong> be allocated from
a descriptor pool created with the
<code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT</code> bit set.
Descriptor set layouts created with this bit set have alternate limits
for the maximum number of descriptors per-stage and per-pipeline layout.
The non-UpdateAfterBind limits only count descriptors in sets created
without this flag.
The UpdateAfterBind limits count all descriptors, but the limits <strong class="purple">may</strong> be
higher than the non-UpdateAfterBind limits.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE</code> specifies
that descriptor sets using this layout <strong class="purple">must</strong> be allocated from a
descriptor pool created with the
<code>VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE</code> bit set.
Descriptor set layouts created with this bit have no expressable limit
for maximum number of descriptors per-stage.
Host descriptor sets are limited only by available host memory, but <strong class="purple">may</strong>
be limited for implementation specific reasons.
Implementations <strong class="purple">may</strong> limit the number of supported descriptors to
UpdateAfterBind limits or non-UpdateAfterBind limits, whichever is
larger.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkDescriptorSetLayoutCreateFlags" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> VkFlags VkDescriptorSetLayoutCreateFlags;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkDescriptorSetLayoutCreateFlags</code> is a bitmask type for setting a mask
of zero or more <a href="#VkDescriptorSetLayoutCreateFlagBits">VkDescriptorSetLayoutCreateFlagBits</a>.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDescriptorSetLayoutBinding</code> structure is defined as:</p>
</div>
<div id="VkDescriptorSetLayoutBinding" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorSetLayoutBinding {
    uint32_t              binding;
    VkDescriptorType      descriptorType;
    uint32_t              descriptorCount;
    VkShaderStageFlags    stageFlags;
    <span class="directive">const</span> VkSampler*      pImmutableSamplers;
} VkDescriptorSetLayoutBinding;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>binding</code> is the binding number of this entry and corresponds to a
resource of the same binding number in the shader stages.</p>
</li>
<li>
<p><code>descriptorType</code> is a <a href="#VkDescriptorType">VkDescriptorType</a> specifying which type
of resource descriptors are used for this binding.</p>
</li>
<li>
<p><code>descriptorCount</code> is the number of descriptors contained in the
binding, accessed in a shader as an array
, except if <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> in which case
<code>descriptorCount</code> is the size in bytes of the inline uniform block
.
If <code>descriptorCount</code> is zero this binding entry is reserved and the
resource <strong class="purple">must</strong> not be accessed from any stage via this binding within
any pipeline using the set layout.</p>
</li>
<li>
<p><code>stageFlags</code> member is a bitmask of <a href="chap11.html#VkShaderStageFlagBits">VkShaderStageFlagBits</a>
specifying which pipeline shader stages <strong class="purple">can</strong> access a resource for this
binding.
<code>VK_SHADER_STAGE_ALL</code> is a shorthand specifying that all defined
shader stages, including any additional stages defined by extensions,
<strong class="purple">can</strong> access the resource.</p>
<div class="paragraph">
<p>If a shader stage is not included in <code>stageFlags</code>, then a resource <strong class="purple">must</strong>
not be accessed from that stage via this binding within any pipeline using
the set layout.
Other than input attachments which are limited to the fragment shader, there
are no limitations on what combinations of stages <strong class="purple">can</strong> use a descriptor
binding, and in particular a binding <strong class="purple">can</strong> be used by both graphics stages
and the compute stage.</p>
</div>
</li>
<li>
<p><code>pImmutableSamplers</code> affects initialization of samplers.
If <code>descriptorType</code> specifies a <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> or
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> type descriptor, then
<code>pImmutableSamplers</code> <strong class="purple">can</strong> be used to initialize a set of <em>immutable
samplers</em>.
Immutable samplers are permanently bound into the set layout and <strong class="purple">must</strong>
not be changed; updating a <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> descriptor
with immutable samplers is not allowed and updates to a
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> descriptor with
immutable samplers does not modify the samplers (the image views are
updated, but the sampler updates are ignored).
If <code>pImmutableSamplers</code> is not <code>NULL</code>, then it points to an array of
sampler handles that will be copied into the set layout and used for the
corresponding binding.
Only the sampler handles are copied; the sampler objects <strong class="purple">must</strong> not be
destroyed before the final use of the set layout and any descriptor
pools and sets created using it.
If <code>pImmutableSamplers</code> is <code>NULL</code>, then the sampler slots are
dynamic and sampler handles <strong class="purple">must</strong> be bound into descriptor sets using
this layout.
If <code>descriptorType</code> is not one of these descriptor types, then
<code>pImmutableSamplers</code> is ignored.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The above layout definition allows the descriptor bindings to be specified
sparsely such that not all binding numbers between 0 and the maximum binding
number need to be specified in the <code>pBindings</code> array.
Bindings that are not specified have a <code>descriptorCount</code> and
<code>stageFlags</code> of zero, and the value of <code>descriptorType</code> is
undefined.
However, all binding numbers between 0 and the maximum binding number in the
<a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>::<code>pBindings</code> array <strong class="purple">may</strong> consume
memory in the descriptor set layout even if not all descriptor bindings are
used, though it <strong class="purple">should</strong> not consume additional memory from the descriptor
pool.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>The maximum binding number specified <strong class="purple">should</strong> be as compact as possible to
avoid wasted memory.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBinding-descriptorType-00282" href="#VUID-VkDescriptorSetLayoutBinding-descriptorType-00282"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBinding-descriptorType-00282</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> or
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and
<code>descriptorCount</code> is not <code>0</code> and <code>pImmutableSamplers</code> is not
<code>NULL</code>, <code>pImmutableSamplers</code> <strong class="purple">must</strong> be a valid pointer to an array of
<code>descriptorCount</code> valid <code>VkSampler</code> handles</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBinding-descriptorType-04604" href="#VUID-VkDescriptorSetLayoutBinding-descriptorType-04604"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBinding-descriptorType-04604</span><br>

If the <a href="chap41.html#features-inlineUniformBlock">inlineUniformBlock</a> feature is not
enabled, <code>descriptorType</code> <strong class="purple">must</strong> not be
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBinding-descriptorType-02209" href="#VUID-VkDescriptorSetLayoutBinding-descriptorType-02209"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBinding-descriptorType-02209</span><br>

If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> then
<code>descriptorCount</code> <strong class="purple">must</strong> be a multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBinding-descriptorType-02210" href="#VUID-VkDescriptorSetLayoutBinding-descriptorType-02210"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBinding-descriptorType-02210</span><br>

If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> then
<code>descriptorCount</code> <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceInlineUniformBlockPropertiesEXT</code>::<code>maxInlineUniformBlockSize</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBinding-descriptorCount-00283" href="#VUID-VkDescriptorSetLayoutBinding-descriptorCount-00283"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBinding-descriptorCount-00283</span><br>

If <code>descriptorCount</code> is not <code>0</code>, <code>stageFlags</code> <strong class="purple">must</strong> be a valid
combination of <a href="chap11.html#VkShaderStageFlagBits">VkShaderStageFlagBits</a> values</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBinding-descriptorType-01510" href="#VUID-VkDescriptorSetLayoutBinding-descriptorType-01510"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBinding-descriptorType-01510</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> and
<code>descriptorCount</code> is not <code>0</code>, then <code>stageFlags</code> <strong class="purple">must</strong> be <code>0</code> or
<code>VK_SHADER_STAGE_FRAGMENT_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBinding-pImmutableSamplers-04009" href="#VUID-VkDescriptorSetLayoutBinding-pImmutableSamplers-04009"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBinding-pImmutableSamplers-04009</span><br>

The sampler objects indicated by <code>pImmutableSamplers</code> <strong class="purple">must</strong> not have
a <code>borderColor</code> with one of the values
<code>VK_BORDER_COLOR_FLOAT_CUSTOM_EXT</code> or
<code>VK_BORDER_COLOR_INT_CUSTOM_EXT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBinding-descriptorType-04605" href="#VUID-VkDescriptorSetLayoutBinding-descriptorType-04605"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBinding-descriptorType-04605</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>, then
<code>pImmutableSamplers</code> <strong class="purple">must</strong> be <code>NULL</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter" href="#VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter</span><br>
 <code>descriptorType</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorType">VkDescriptorType</a> value</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>If the <code>pNext</code> chain of a <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>
structure includes a <a href="#VkDescriptorSetLayoutBindingFlagsCreateInfo">VkDescriptorSetLayoutBindingFlagsCreateInfo</a>
structure, then that structure includes an array of flags, one for each
descriptor set layout binding.</p>
</div>
<div class="paragraph">
<p>The <a href="#VkDescriptorSetLayoutBindingFlagsCreateInfo">VkDescriptorSetLayoutBindingFlagsCreateInfo</a> structure is defined
as:</p>
</div>
<div id="VkDescriptorSetLayoutBindingFlagsCreateInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorSetLayoutBindingFlagsCreateInfo {
    VkStructureType                    sType;
    <span class="directive">const</span> <span class="directive">void</span>*                        pNext;
    uint32_t                           bindingCount;
    <span class="directive">const</span> VkDescriptorBindingFlags*    pBindingFlags;
} VkDescriptorSetLayoutBindingFlagsCreateInfo;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorSetLayoutBindingFlagsCreateInfoEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_EXT_descriptor_indexing</span>
<span class="keyword">typedef</span> VkDescriptorSetLayoutBindingFlagsCreateInfo VkDescriptorSetLayoutBindingFlagsCreateInfoEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>bindingCount</code> is zero or the number of elements in
<code>pBindingFlags</code>.</p>
</li>
<li>
<p><code>pBindingFlags</code> is a pointer to an array of
<a href="#VkDescriptorBindingFlags">VkDescriptorBindingFlags</a> bitfields, one for each descriptor set
layout binding.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>bindingCount</code> is zero or if this structure is not included in the
<code>pNext</code> chain, the <a href="#VkDescriptorBindingFlags">VkDescriptorBindingFlags</a> for each descriptor
set layout binding is considered to be zero.
Otherwise, the descriptor set layout binding at
<a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>::<code>pBindings</code>[i] uses the flags in
<code>pBindingFlags</code>[i].</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-bindingCount-03002" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-bindingCount-03002"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-bindingCount-03002</span><br>

If <code>bindingCount</code> is not zero, <code>bindingCount</code> <strong class="purple">must</strong> equal
<a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>::<code>bindingCount</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-flags-03003" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-flags-03003"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-flags-03003</span><br>

If <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>::<code>flags</code> includes
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code>, then all
elements of <code>pBindingFlags</code> <strong class="purple">must</strong> not include
<code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code>,
<code>VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT</code>, or
<code>VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-03004" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-03004"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-03004</span><br>

If an element of <code>pBindingFlags</code> includes
<code>VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT</code>, then all
other elements of <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>::<code>pBindings</code>
<strong class="purple">must</strong> have a smaller value of <code>binding</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingUniformBufferUpdateAfterBind-03005" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingUniformBufferUpdateAfterBind-03005"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingUniformBufferUpdateAfterBind-03005</span><br>

If
<a href="chap41.html#VkPhysicalDeviceDescriptorIndexingFeatures">VkPhysicalDeviceDescriptorIndexingFeatures</a>::<code>descriptorBindingUniformBufferUpdateAfterBind</code>
is not enabled, all bindings with descriptor type
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> <strong class="purple">must</strong> not use
<code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingSampledImageUpdateAfterBind-03006" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingSampledImageUpdateAfterBind-03006"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingSampledImageUpdateAfterBind-03006</span><br>

If
<a href="chap41.html#VkPhysicalDeviceDescriptorIndexingFeatures">VkPhysicalDeviceDescriptorIndexingFeatures</a>::<code>descriptorBindingSampledImageUpdateAfterBind</code>
is not enabled, all bindings with descriptor type
<code>VK_DESCRIPTOR_TYPE_SAMPLER</code>,
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, or
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code> <strong class="purple">must</strong> not use
<code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingStorageImageUpdateAfterBind-03007" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingStorageImageUpdateAfterBind-03007"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingStorageImageUpdateAfterBind-03007</span><br>

If
<a href="chap41.html#VkPhysicalDeviceDescriptorIndexingFeatures">VkPhysicalDeviceDescriptorIndexingFeatures</a>::<code>descriptorBindingStorageImageUpdateAfterBind</code>
is not enabled, all bindings with descriptor type
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code> <strong class="purple">must</strong> not use
<code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingStorageBufferUpdateAfterBind-03008" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingStorageBufferUpdateAfterBind-03008"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingStorageBufferUpdateAfterBind-03008</span><br>

If
<a href="chap41.html#VkPhysicalDeviceDescriptorIndexingFeatures">VkPhysicalDeviceDescriptorIndexingFeatures</a>::<code>descriptorBindingStorageBufferUpdateAfterBind</code>
is not enabled, all bindings with descriptor type
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> <strong class="purple">must</strong> not use
<code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingUniformTexelBufferUpdateAfterBind-03009" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingUniformTexelBufferUpdateAfterBind-03009"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingUniformTexelBufferUpdateAfterBind-03009</span><br>

If
<a href="chap41.html#VkPhysicalDeviceDescriptorIndexingFeatures">VkPhysicalDeviceDescriptorIndexingFeatures</a>::<code>descriptorBindingUniformTexelBufferUpdateAfterBind</code>
is not enabled, all bindings with descriptor type
<code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> <strong class="purple">must</strong> not use
<code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingStorageTexelBufferUpdateAfterBind-03010" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingStorageTexelBufferUpdateAfterBind-03010"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingStorageTexelBufferUpdateAfterBind-03010</span><br>

If
<a href="chap41.html#VkPhysicalDeviceDescriptorIndexingFeatures">VkPhysicalDeviceDescriptorIndexingFeatures</a>::<code>descriptorBindingStorageTexelBufferUpdateAfterBind</code>
is not enabled, all bindings with descriptor type
<code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> <strong class="purple">must</strong> not use
<code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingInlineUniformBlockUpdateAfterBind-02211" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingInlineUniformBlockUpdateAfterBind-02211"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingInlineUniformBlockUpdateAfterBind-02211</span><br>

If
<a href="chap41.html#VkPhysicalDeviceInlineUniformBlockFeaturesEXT">VkPhysicalDeviceInlineUniformBlockFeaturesEXT</a>::<code>descriptorBindingInlineUniformBlockUpdateAfterBind</code>
is not enabled, all bindings with descriptor type
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> <strong class="purple">must</strong> not use
<code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingAccelerationStructureUpdateAfterBind-03570" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingAccelerationStructureUpdateAfterBind-03570"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingAccelerationStructureUpdateAfterBind-03570</span><br>

If
<a href="chap41.html#VkPhysicalDeviceAccelerationStructureFeaturesKHR">VkPhysicalDeviceAccelerationStructureFeaturesKHR</a>::<code>descriptorBindingAccelerationStructureUpdateAfterBind</code>
is not enabled, all bindings with descriptor type
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code> or
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV</code> <strong class="purple">must</strong> not use
<code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-None-03011" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-None-03011"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-None-03011</span><br>

All bindings with descriptor type
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>,
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> <strong class="purple">must</strong> not use
<code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingUpdateUnusedWhilePending-03012" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingUpdateUnusedWhilePending-03012"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingUpdateUnusedWhilePending-03012</span><br>

If
<a href="chap41.html#VkPhysicalDeviceDescriptorIndexingFeatures">VkPhysicalDeviceDescriptorIndexingFeatures</a>::<code>descriptorBindingUpdateUnusedWhilePending</code>
is not enabled, all elements of <code>pBindingFlags</code> <strong class="purple">must</strong> not include
<code>VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingPartiallyBound-03013" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingPartiallyBound-03013"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingPartiallyBound-03013</span><br>

If
<a href="chap41.html#VkPhysicalDeviceDescriptorIndexingFeatures">VkPhysicalDeviceDescriptorIndexingFeatures</a>::<code>descriptorBindingPartiallyBound</code>
is not enabled, all elements of <code>pBindingFlags</code> <strong class="purple">must</strong> not include
<code>VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingVariableDescriptorCount-03014" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingVariableDescriptorCount-03014"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingVariableDescriptorCount-03014</span><br>

If
<a href="chap41.html#VkPhysicalDeviceDescriptorIndexingFeatures">VkPhysicalDeviceDescriptorIndexingFeatures</a>::<code>descriptorBindingVariableDescriptorCount</code>
is not enabled, all elements of <code>pBindingFlags</code> <strong class="purple">must</strong> not include
<code>VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-03015" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-03015"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-03015</span><br>

If an element of <code>pBindingFlags</code> includes
<code>VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT</code>, that
element’s <code>descriptorType</code> <strong class="purple">must</strong> not be
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-sType-sType" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-sType-sType"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-parameter" href="#VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-parameter"></a> <span class="vuid">VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-parameter</span><br>
 If <code>bindingCount</code> is not <code>0</code>, <code>pBindingFlags</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>bindingCount</code> valid combinations of <a href="#VkDescriptorBindingFlagBits">VkDescriptorBindingFlagBits</a> values</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Bits which <strong class="purple">can</strong> be set in each element of
<a href="#VkDescriptorSetLayoutBindingFlagsCreateInfo">VkDescriptorSetLayoutBindingFlagsCreateInfo</a>::<code>pBindingFlags</code> to
specify options for the corresponding descriptor set layout binding are:</p>
</div>
<div id="VkDescriptorBindingFlagBits" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">enum</span> VkDescriptorBindingFlagBits {
    VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = <span class="hex">0x00000001</span>,
    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = <span class="hex">0x00000002</span>,
    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = <span class="hex">0x00000004</span>,
    VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = <span class="hex">0x00000008</span>,
  <span class="comment">// Provided by VK_EXT_descriptor_indexing</span>
    VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT,
  <span class="comment">// Provided by VK_EXT_descriptor_indexing</span>
    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT,
  <span class="comment">// Provided by VK_EXT_descriptor_indexing</span>
    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT,
  <span class="comment">// Provided by VK_EXT_descriptor_indexing</span>
    VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT,
} VkDescriptorBindingFlagBits;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorBindingFlagBitsEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_EXT_descriptor_indexing</span>
<span class="keyword">typedef</span> VkDescriptorBindingFlagBits VkDescriptorBindingFlagBitsEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code> indicates that if
descriptors in this binding are updated between when the descriptor set
is bound in a command buffer and when that command buffer is submitted
to a queue, then the submission will use the most recently set
descriptors for this binding and the updates do not invalidate the
command buffer.
Descriptor bindings created with this flag are also partially exempt
from the external synchronization requirement in
<a href="#vkUpdateDescriptorSetWithTemplateKHR">vkUpdateDescriptorSetWithTemplateKHR</a> and
<a href="#vkUpdateDescriptorSets">vkUpdateDescriptorSets</a>.
Multiple descriptors with this flag set <strong class="purple">can</strong> be updated concurrently in
different threads, though the same descriptor <strong class="purple">must</strong> not be updated
concurrently by two threads.
Descriptors with this flag set <strong class="purple">can</strong> be updated concurrently with the set
being bound to a command buffer in another thread, but not concurrently
with the set being reset or freed.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT</code> indicates that
descriptors in this binding that are not <em>dynamically used</em> need not
contain valid descriptors at the time the descriptors are consumed.
A descriptor is dynamically used if any shader invocation executes an
instruction that performs any memory access using the descriptor.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT</code> indicates
that descriptors in this binding <strong class="purple">can</strong> be updated after a command buffer
has bound this descriptor set, or while a command buffer that uses this
descriptor set is pending execution, as long as the descriptors that are
updated are not used by those command buffers.
If <code>VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT</code> is also set, then
descriptors <strong class="purple">can</strong> be updated as long as they are not dynamically used by
any shader invocations.
If <code>VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT</code> is not set, then
descriptors <strong class="purple">can</strong> be updated as long as they are not statically used by
any shader invocations.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT</code> indicates that
this descriptor binding has a variable size that will be specified when
a descriptor set is allocated using this layout.
The value of <code>descriptorCount</code> is treated as an upper bound on the
size of the binding.
This <strong class="purple">must</strong> only be used for the last binding in the descriptor set
layout (i.e. the binding with the largest value of <code>binding</code>).
For the purposes of counting against limits such as
<code>maxDescriptorSet</code>* and <code>maxPerStageDescriptor</code>*, the full value
of <code>descriptorCount</code> is counted
, except for descriptor bindings with a descriptor type of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> where
<code>descriptorCount</code> specifies the upper bound on the byte size of the
binding, thus it counts against the <a href="chap42.html#limits-maxInlineUniformBlockSize"><code>maxInlineUniformBlockSize</code></a> limit instead.
.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Note that while <code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code> and
<code>VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT</code> both involve
updates to descriptor sets after they are bound,
<code>VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT</code> is a weaker
requirement since it is only about descriptors that are not used, whereas
<code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code> requires the
implementation to observe updates to descriptors that are used.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkDescriptorBindingFlags" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkFlags VkDescriptorBindingFlags;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorBindingFlagsEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_EXT_descriptor_indexing</span>
<span class="keyword">typedef</span> VkDescriptorBindingFlags VkDescriptorBindingFlagsEXT;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkDescriptorBindingFlags</code> is a bitmask type for setting a mask of zero
or more <a href="#VkDescriptorBindingFlagBits">VkDescriptorBindingFlagBits</a>.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query information about whether a descriptor set layout <strong class="purple">can</strong> be created,
call:</p>
</div>
<div id="vkGetDescriptorSetLayoutSupport" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_1</span>
<span class="directive">void</span> vkGetDescriptorSetLayoutSupport(
    VkDevice                                    device,
    <span class="directive">const</span> VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    VkDescriptorSetLayoutSupport*               pSupport);</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent command</p>
</div>
<div id="vkGetDescriptorSetLayoutSupportKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_maintenance3</span>
<span class="directive">void</span> vkGetDescriptorSetLayoutSupportKHR(
    VkDevice                                    device,
    <span class="directive">const</span> VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    VkDescriptorSetLayoutSupport*               pSupport);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that would create the descriptor set
layout.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to a
<a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a> structure specifying the state of
the descriptor set layout object.</p>
</li>
<li>
<p><code>pSupport</code> is a pointer to a <a href="#VkDescriptorSetLayoutSupport">VkDescriptorSetLayoutSupport</a>
structure, in which information about support for the descriptor set
layout object is returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some implementations have limitations on what fits in a descriptor set which
are not easily expressible in terms of existing limits like
<code>maxDescriptorSet</code>*, for example if all descriptor types share a limited
space in memory but each descriptor is a different size or alignment.
This command returns information about whether a descriptor set satisfies
this limit.
If the descriptor set layout satisfies the
<a href="chap42.html#VkPhysicalDeviceMaintenance3Properties">VkPhysicalDeviceMaintenance3Properties</a>::<code>maxPerSetDescriptors</code>
limit, this command is guaranteed to return <code>VK_TRUE</code> in
<a href="#VkDescriptorSetLayoutSupport">VkDescriptorSetLayoutSupport</a>::<code>supported</code>.
If the descriptor set layout exceeds the
<a href="chap42.html#VkPhysicalDeviceMaintenance3Properties">VkPhysicalDeviceMaintenance3Properties</a>::<code>maxPerSetDescriptors</code>
limit, whether the descriptor set layout is supported is
implementation-dependent and <strong class="purple">may</strong> depend on whether the descriptor sizes and
alignments cause the layout to exceed an internal limit.</p>
</div>
<div class="paragraph">
<p>This command does not consider other limits such as
<code>maxPerStageDescriptor</code>*, and so a descriptor set layout that is
supported according to this command <strong class="purple">must</strong> still satisfy the pipeline layout
limits such as <code>maxPerStageDescriptor</code>* in order to be used in a
pipeline layout.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>This is a <code>VkDevice</code> query rather than <code>VkPhysicalDevice</code> because
the answer <strong class="purple">may</strong> depend on enabled features.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetDescriptorSetLayoutSupport-device-parameter" href="#VUID-vkGetDescriptorSetLayoutSupport-device-parameter"></a> <span class="vuid">VUID-vkGetDescriptorSetLayoutSupport-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkGetDescriptorSetLayoutSupport-pCreateInfo-parameter" href="#VUID-vkGetDescriptorSetLayoutSupport-pCreateInfo-parameter"></a> <span class="vuid">VUID-vkGetDescriptorSetLayoutSupport-pCreateInfo-parameter</span><br>
 <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a> structure</p>
</li>
<li>
<p><a id="VUID-vkGetDescriptorSetLayoutSupport-pSupport-parameter" href="#VUID-vkGetDescriptorSetLayoutSupport-pSupport-parameter"></a> <span class="vuid">VUID-vkGetDescriptorSetLayoutSupport-pSupport-parameter</span><br>
 <code>pSupport</code> <strong class="purple">must</strong> be a valid pointer to a <a href="#VkDescriptorSetLayoutSupport">VkDescriptorSetLayoutSupport</a> structure</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Information about support for the descriptor set layout is returned in a
<code>VkDescriptorSetLayoutSupport</code> structure:</p>
</div>
<div id="VkDescriptorSetLayoutSupport" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_1</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorSetLayoutSupport {
    VkStructureType    sType;
    <span class="directive">void</span>*              pNext;
    VkBool32           supported;
} VkDescriptorSetLayoutSupport;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorSetLayoutSupportKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_maintenance3</span>
<span class="keyword">typedef</span> VkDescriptorSetLayoutSupport VkDescriptorSetLayoutSupportKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>supported</code> specifies whether the descriptor set layout <strong class="purple">can</strong> be
created.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>supported</code> is set to <code>VK_TRUE</code> if the descriptor set <strong class="purple">can</strong> be
created, or else is set to <code>VK_FALSE</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetLayoutSupport-sType-sType" href="#VUID-VkDescriptorSetLayoutSupport-sType-sType"></a> <span class="vuid">VUID-VkDescriptorSetLayoutSupport-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutSupport-pNext-pNext" href="#VUID-VkDescriptorSetLayoutSupport-pNext-pNext"></a> <span class="vuid">VUID-VkDescriptorSetLayoutSupport-pNext-pNext</span><br>
 <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code> or a pointer to a valid instance of <a href="#VkDescriptorSetVariableDescriptorCountLayoutSupport">VkDescriptorSetVariableDescriptorCountLayoutSupport</a></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutSupport-sType-unique" href="#VUID-VkDescriptorSetLayoutSupport-sType-unique"></a> <span class="vuid">VUID-VkDescriptorSetLayoutSupport-sType-unique</span><br>
 The <code>sType</code> value of each struct in the <code>pNext</code> chain <strong class="purple">must</strong> be unique</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>If the <code>pNext</code> chain of a <a href="#VkDescriptorSetLayoutSupport">VkDescriptorSetLayoutSupport</a> structure
includes a <code>VkDescriptorSetVariableDescriptorCountLayoutSupport</code>
structure, then that structure returns additional information about whether
the descriptor set layout is supported.</p>
</div>
<div id="VkDescriptorSetVariableDescriptorCountLayoutSupport" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorSetVariableDescriptorCountLayoutSupport {
    VkStructureType    sType;
    <span class="directive">void</span>*              pNext;
    uint32_t           maxVariableDescriptorCount;
} VkDescriptorSetVariableDescriptorCountLayoutSupport;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorSetVariableDescriptorCountLayoutSupportEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_EXT_descriptor_indexing</span>
<span class="keyword">typedef</span> VkDescriptorSetVariableDescriptorCountLayoutSupport VkDescriptorSetVariableDescriptorCountLayoutSupportEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>maxVariableDescriptorCount</code> indicates the maximum number of
descriptors supported in the highest numbered binding of the layout, if
that binding is variable-sized.
If the highest numbered binding of the layout has a descriptor type of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> then
<code>maxVariableDescriptorCount</code> indicates the maximum byte size
supported for the binding, if that binding is variable-sized.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the create info includes a variable-sized descriptor, then
<code>supported</code> is determined assuming the requested size of the
variable-sized descriptor, and <code>maxVariableDescriptorCount</code> is set to
the maximum size of that descriptor that <strong class="purple">can</strong> be successfully created (which
is greater than or equal to the requested size passed in).
If the create info does not include a variable-sized descriptor or if the
<a href="chap41.html#VkPhysicalDeviceDescriptorIndexingFeatures">VkPhysicalDeviceDescriptorIndexingFeatures</a>::<code>descriptorBindingVariableDescriptorCount</code>
feature is not enabled, then <code>maxVariableDescriptorCount</code> is set to
zero.
For the purposes of this command, a variable-sized descriptor binding with a
<code>descriptorCount</code> of zero is treated as if the <code>descriptorCount</code> is
one, and thus the binding is not ignored and the maximum descriptor count
will be returned.
If the layout is not supported, then the value written to
<code>maxVariableDescriptorCount</code> is undefined.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetVariableDescriptorCountLayoutSupport-sType-sType" href="#VUID-VkDescriptorSetVariableDescriptorCountLayoutSupport-sType-sType"></a> <span class="vuid">VUID-VkDescriptorSetVariableDescriptorCountLayoutSupport-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following examples show a shader snippet using two descriptor sets, and
application code that creates corresponding descriptor set layouts.</p>
</div>
<div class="listingblock">
<div class="title">GLSL example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="glsl">//
// binding to a single sampled image descriptor in set 0
//
layout (set=0, binding=0) uniform texture2D mySampledImage;

//
// binding to an array of sampled image descriptors in set 0
//
layout (set=0, binding=1) uniform texture2D myArrayOfSampledImages[12];

//
// binding to a single uniform buffer descriptor in set 1
//
layout (set=1, binding=0) uniform myUniformBuffer
{
    vec4 myElement[32];
};</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">SPIR-V example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="spirv">               ...
          %1 = OpExtInstImport &quot;GLSL.std.450&quot;
               ...
               OpName %9 &quot;mySampledImage&quot;
               OpName %14 &quot;myArrayOfSampledImages&quot;
               OpName %18 &quot;myUniformBuffer&quot;
               OpMemberName %18 0 &quot;myElement&quot;
               OpName %20 &quot;&quot;
               OpDecorate %9 DescriptorSet 0
               OpDecorate %9 Binding 0
               OpDecorate %14 DescriptorSet 0
               OpDecorate %14 Binding 1
               OpDecorate %17 ArrayStride 16
               OpMemberDecorate %18 0 Offset 0
               OpDecorate %18 Block
               OpDecorate %20 DescriptorSet 1
               OpDecorate %20 Binding 0
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 2D 0 0 0 1 Unknown
          %8 = OpTypePointer UniformConstant %7
          %9 = OpVariable %8 UniformConstant
         %10 = OpTypeInt 32 0
         %11 = OpConstant %10 12
         %12 = OpTypeArray %7 %11
         %13 = OpTypePointer UniformConstant %12
         %14 = OpVariable %13 UniformConstant
         %15 = OpTypeVector %6 4
         %16 = OpConstant %10 32
         %17 = OpTypeArray %15 %16
         %18 = OpTypeStruct %17
         %19 = OpTypePointer Uniform %18
         %20 = OpVariable %19 Uniform
               ...</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">API example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult myResult;

<span class="directive">const</span> VkDescriptorSetLayoutBinding myDescriptorSetLayoutBinding[] =
{
    <span class="comment">// binding to a single image descriptor</span>
    {
        <span class="integer">0</span>,                                      <span class="comment">// binding</span>
        VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,       <span class="comment">// descriptorType</span>
        <span class="integer">1</span>,                                      <span class="comment">// descriptorCount</span>
        VK_SHADER_STAGE_FRAGMENT_BIT,           <span class="comment">// stageFlags</span>
        <span class="predefined-constant">NULL</span>                                    <span class="comment">// pImmutableSamplers</span>
    },

    <span class="comment">// binding to an array of image descriptors</span>
    {
        <span class="integer">1</span>,                                      <span class="comment">// binding</span>
        VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,       <span class="comment">// descriptorType</span>
        <span class="integer">12</span>,                                     <span class="comment">// descriptorCount</span>
        VK_SHADER_STAGE_FRAGMENT_BIT,           <span class="comment">// stageFlags</span>
        <span class="predefined-constant">NULL</span>                                    <span class="comment">// pImmutableSamplers</span>
    },

    <span class="comment">// binding to a single uniform buffer descriptor</span>
    {
        <span class="integer">0</span>,                                      <span class="comment">// binding</span>
        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,      <span class="comment">// descriptorType</span>
        <span class="integer">1</span>,                                      <span class="comment">// descriptorCount</span>
        VK_SHADER_STAGE_FRAGMENT_BIT,           <span class="comment">// stageFlags</span>
        <span class="predefined-constant">NULL</span>                                    <span class="comment">// pImmutableSamplers</span>
    }
};

<span class="directive">const</span> VkDescriptorSetLayoutCreateInfo myDescriptorSetLayoutCreateInfo[] =
{
    <span class="comment">// Create info for first descriptor set with two descriptor bindings</span>
    {
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,    <span class="comment">// sType</span>
        <span class="predefined-constant">NULL</span>,                                                   <span class="comment">// pNext</span>
        <span class="integer">0</span>,                                                      <span class="comment">// flags</span>
        <span class="integer">2</span>,                                                      <span class="comment">// bindingCount</span>
        &amp;myDescriptorSetLayoutBinding[<span class="integer">0</span>]                        <span class="comment">// pBindings</span>
    },

    <span class="comment">// Create info for second descriptor set with one descriptor binding</span>
    {
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,    <span class="comment">// sType</span>
        <span class="predefined-constant">NULL</span>,                                                   <span class="comment">// pNext</span>
        <span class="integer">0</span>,                                                      <span class="comment">// flags</span>
        <span class="integer">1</span>,                                                      <span class="comment">// bindingCount</span>
        &amp;myDescriptorSetLayoutBinding[<span class="integer">2</span>]                        <span class="comment">// pBindings</span>
    }
};

VkDescriptorSetLayout myDescriptorSetLayout[<span class="integer">2</span>];

<span class="comment">//</span>
<span class="comment">// Create first descriptor set layout</span>
<span class="comment">//</span>
myResult = vkCreateDescriptorSetLayout(
    myDevice,
    &amp;myDescriptorSetLayoutCreateInfo[<span class="integer">0</span>],
    <span class="predefined-constant">NULL</span>,
    &amp;myDescriptorSetLayout[<span class="integer">0</span>]);

<span class="comment">//</span>
<span class="comment">// Create second descriptor set layout</span>
<span class="comment">//</span>
myResult = vkCreateDescriptorSetLayout(
    myDevice,
    &amp;myDescriptorSetLayoutCreateInfo[<span class="integer">1</span>],
    <span class="predefined-constant">NULL</span>,
    &amp;myDescriptorSetLayout[<span class="integer">1</span>]);</code></pre>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To destroy a descriptor set layout, call:</p>
</div>
<div id="vkDestroyDescriptorSetLayout" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="directive">void</span> vkDestroyDescriptorSetLayout(
    VkDevice                                    device,
    VkDescriptorSetLayout                       descriptorSetLayout,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that destroys the descriptor set
layout.</p>
</li>
<li>
<p><code>descriptorSetLayout</code> is the descriptor set layout to destroy.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap12.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00284" href="#VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00284"></a> <span class="vuid">VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00284</span><br>

If <code>VkAllocationCallbacks</code> were provided when
<code>descriptorSetLayout</code> was created, a compatible set of callbacks
<strong class="purple">must</strong> be provided here</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00285" href="#VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00285"></a> <span class="vuid">VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00285</span><br>

If no <code>VkAllocationCallbacks</code> were provided when
<code>descriptorSetLayout</code> was created, <code>pAllocator</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyDescriptorSetLayout-device-parameter" href="#VUID-vkDestroyDescriptorSetLayout-device-parameter"></a> <span class="vuid">VUID-vkDestroyDescriptorSetLayout-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parameter" href="#VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parameter"></a> <span class="vuid">VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parameter</span><br>
 If <code>descriptorSetLayout</code> is not <a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>descriptorSetLayout</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorSetLayout-pAllocator-parameter" href="#VUID-vkDestroyDescriptorSetLayout-pAllocator-parameter"></a> <span class="vuid">VUID-vkDestroyDescriptorSetLayout-pAllocator-parameter</span><br>
 If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap12.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parent" href="#VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parent"></a> <span class="vuid">VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parent</span><br>
 If <code>descriptorSetLayout</code> is a valid handle, it <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>descriptorSetLayout</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-pipelinelayout"><a class="anchor" href="#descriptorsets-pipelinelayout"></a>14.2.2. Pipeline Layouts</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Access to descriptor sets from a pipeline is accomplished through a
<em>pipeline layout</em>.
Zero or more descriptor set layouts and zero or more push constant ranges
are combined to form a pipeline layout object describing the complete set of
resources that <strong class="purple">can</strong> be accessed by a pipeline.
The pipeline layout represents a sequence of descriptor sets with each
having a specific layout.
This sequence of layouts is used to determine the interface between shader
stages and shader resources.
Each pipeline is created using a pipeline layout.</p>
</div>
<div class="paragraph">
<p>Pipeline layout objects are represented by <code>VkPipelineLayout</code> handles:</p>
</div>
<div id="VkPipelineLayout" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create a pipeline layout, call:</p>
</div>
<div id="vkCreatePipelineLayout" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
VkResult vkCreatePipelineLayout(
    VkDevice                                    device,
    <span class="directive">const</span> VkPipelineLayoutCreateInfo*           pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkPipelineLayout*                           pPipelineLayout);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that creates the pipeline layout.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to a <a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a>
structure specifying the state of the pipeline layout object.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap12.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
<li>
<p><code>pPipelineLayout</code> is a pointer to a <a href="#VkPipelineLayout">VkPipelineLayout</a> handle in
which the resulting pipeline layout object is returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreatePipelineLayout-device-parameter" href="#VUID-vkCreatePipelineLayout-device-parameter"></a> <span class="vuid">VUID-vkCreatePipelineLayout-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCreatePipelineLayout-pCreateInfo-parameter" href="#VUID-vkCreatePipelineLayout-pCreateInfo-parameter"></a> <span class="vuid">VUID-vkCreatePipelineLayout-pCreateInfo-parameter</span><br>
 <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreatePipelineLayout-pAllocator-parameter" href="#VUID-vkCreatePipelineLayout-pAllocator-parameter"></a> <span class="vuid">VUID-vkCreatePipelineLayout-pAllocator-parameter</span><br>
 If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap12.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreatePipelineLayout-pPipelineLayout-parameter" href="#VUID-vkCreatePipelineLayout-pPipelineLayout-parameter"></a> <span class="vuid">VUID-vkCreatePipelineLayout-pPipelineLayout-parameter</span><br>
 <code>pPipelineLayout</code> <strong class="purple">must</strong> be a valid pointer to a <a href="#VkPipelineLayout">VkPipelineLayout</a> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap4.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap4.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a> structure is defined as:</p>
</div>
<div id="VkPipelineLayoutCreateInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkPipelineLayoutCreateInfo {
    VkStructureType                 sType;
    <span class="directive">const</span> <span class="directive">void</span>*                     pNext;
    VkPipelineLayoutCreateFlags     flags;
    uint32_t                        setLayoutCount;
    <span class="directive">const</span> VkDescriptorSetLayout*    pSetLayouts;
    uint32_t                        pushConstantRangeCount;
    <span class="directive">const</span> VkPushConstantRange*      pPushConstantRanges;
} VkPipelineLayoutCreateInfo;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
<li>
<p><code>setLayoutCount</code> is the number of descriptor sets included in the
pipeline layout.</p>
</li>
<li>
<p><code>pSetLayouts</code> is a pointer to an array of
<code>VkDescriptorSetLayout</code> objects.</p>
</li>
<li>
<p><code>pushConstantRangeCount</code> is the number of push constant ranges
included in the pipeline layout.</p>
</li>
<li>
<p><code>pPushConstantRanges</code> is a pointer to an array of
<code>VkPushConstantRange</code> structures defining a set of push constant
ranges for use in a single pipeline layout.
In addition to descriptor set layouts, a pipeline layout also describes
how many push constants <strong class="purple">can</strong> be accessed by each stage of the pipeline.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Push constants represent a high speed path to modify constant data in
pipelines that is expected to outperform memory-backed resource updates.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-setLayoutCount-00286" href="#VUID-VkPipelineLayoutCreateInfo-setLayoutCount-00286"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-setLayoutCount-00286</span><br>

<code>setLayoutCount</code> <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxBoundDescriptorSets</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03016" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03016"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03016</span><br>

The total number of descriptors in descriptor set layouts created
without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit set
with a <code>descriptorType</code> of <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> and
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> accessible to any given
shader stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than
or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorSamplers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03017" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03017"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03017</span><br>

The total number of descriptors in descriptor set layouts created
without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit set
with a <code>descriptorType</code> of <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>
and <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> accessible to any
given shader stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be
less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorUniformBuffers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03018" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03018"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03018</span><br>

The total number of descriptors in descriptor set layouts created
without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit set
with a <code>descriptorType</code> of <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>
and <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> accessible to any
given shader stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be
less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorStorageBuffers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03019" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03019"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03019</span><br>

The total number of descriptors in descriptor set layouts created
without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit set
with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, and
<code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> accessible to any given
shader stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than
or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorSampledImages</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03020" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03020"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03020</span><br>

The total number of descriptors in descriptor set layouts created
without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit set
with a <code>descriptorType</code> of <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>,
and <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> accessible to any
given shader stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be
less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorStorageImages</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03021" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03021"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03021</span><br>

The total number of descriptors in descriptor set layouts created
without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit set
with a <code>descriptorType</code> of <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>
accessible to any given shader stage across all elements of
<code>pSetLayouts</code> <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorInputAttachments</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-02214" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-02214"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-02214</span><br>

The total number of bindings in descriptor set layouts created without
the <code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit
set with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> accessible to any
given shader stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be
less than or equal to
<code>VkPhysicalDeviceInlineUniformBlockPropertiesEXT</code>::<code>maxPerStageDescriptorInlineUniformBlocks</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03022" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03022"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03022</span><br>

The total number of descriptors with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_SAMPLER</code> and
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> accessible to any given
shader stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than
or equal to
<code>VkPhysicalDeviceDescriptorIndexingProperties</code>::<code>maxPerStageDescriptorUpdateAfterBindSamplers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03023" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03023"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03023</span><br>

The total number of descriptors with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> and
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> accessible to any given
shader stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than
or equal to
<code>VkPhysicalDeviceDescriptorIndexingProperties</code>::<code>maxPerStageDescriptorUpdateAfterBindUniformBuffers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03024" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03024"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03024</span><br>

The total number of descriptors with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> and
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> accessible to any given
shader stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than
or equal to
<code>VkPhysicalDeviceDescriptorIndexingProperties</code>::<code>maxPerStageDescriptorUpdateAfterBindStorageBuffers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03025" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03025"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03025</span><br>

The total number of descriptors with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, and
<code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> accessible to any given
shader stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than
or equal to
<code>VkPhysicalDeviceDescriptorIndexingProperties</code>::<code>maxPerStageDescriptorUpdateAfterBindSampledImages</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03026" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03026"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03026</span><br>

The total number of descriptors with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, and
<code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> accessible to any given
shader stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than
or equal to
<code>VkPhysicalDeviceDescriptorIndexingProperties</code>::<code>maxPerStageDescriptorUpdateAfterBindStorageImages</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03027" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03027"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03027</span><br>

The total number of descriptors with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> accessible to any given shader
stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than or
equal to
<code>VkPhysicalDeviceDescriptorIndexingProperties</code>::<code>maxPerStageDescriptorUpdateAfterBindInputAttachments</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-02215" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-02215"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-02215</span><br>

The total number of bindings with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> accessible to any
given shader stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be
less than or equal to
<code>VkPhysicalDeviceInlineUniformBlockPropertiesEXT</code>::<code>maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03028" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03028"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03028</span><br>

The total number of descriptors in descriptor set layouts created
without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit set
with a <code>descriptorType</code> of <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> and
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetSamplers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03029" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03029"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03029</span><br>

The total number of descriptors in descriptor set layouts created
without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit set
with a <code>descriptorType</code> of <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>
accessible across all shader stages and across all elements of
<code>pSetLayouts</code> <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetUniformBuffers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03030" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03030"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03030</span><br>

The total number of descriptors in descriptor set layouts created
without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit set
with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetUniformBuffersDynamic</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03031" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03031"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03031</span><br>

The total number of descriptors in descriptor set layouts created
without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit set
with a <code>descriptorType</code> of <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>
accessible across all shader stages and across all elements of
<code>pSetLayouts</code> <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetStorageBuffers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03032" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03032"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03032</span><br>

The total number of descriptors in descriptor set layouts created
without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit set
with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetStorageBuffersDynamic</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03033" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03033"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03033</span><br>

The total number of descriptors in descriptor set layouts created
without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit set
with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, and
<code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetSampledImages</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03034" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03034"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03034</span><br>

The total number of descriptors in descriptor set layouts created
without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit set
with a <code>descriptorType</code> of <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>,
and <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetStorageImages</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03035" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03035"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03035</span><br>

The total number of descriptors in descriptor set layouts created
without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit set
with a <code>descriptorType</code> of <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>
accessible across all shader stages and across all elements of
<code>pSetLayouts</code> <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetInputAttachments</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-02216" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-02216"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-02216</span><br>

The total number of bindings in descriptor set layouts created without
the <code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit
set with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceInlineUniformBlockPropertiesEXT</code>::<code>maxDescriptorSetInlineUniformBlocks</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03036" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03036"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03036</span><br>

The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_SAMPLER</code> and
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceDescriptorIndexingProperties</code>::<code>maxDescriptorSetUpdateAfterBindSamplers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03037" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03037"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03037</span><br>

The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> accessible across all shader
stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than
or equal to
<code>VkPhysicalDeviceDescriptorIndexingProperties</code>::<code>maxDescriptorSetUpdateAfterBindUniformBuffers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03038" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03038"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03038</span><br>

The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceDescriptorIndexingProperties</code>::<code>maxDescriptorSetUpdateAfterBindUniformBuffersDynamic</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03039" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03039"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03039</span><br>

The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> accessible across all shader
stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than
or equal to
<code>VkPhysicalDeviceDescriptorIndexingProperties</code>::<code>maxDescriptorSetUpdateAfterBindStorageBuffers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03040" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03040"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03040</span><br>

The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceDescriptorIndexingProperties</code>::<code>maxDescriptorSetUpdateAfterBindStorageBuffersDynamic</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03041" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03041"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03041</span><br>

The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, and
<code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceDescriptorIndexingProperties</code>::<code>maxDescriptorSetUpdateAfterBindSampledImages</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03042" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03042"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03042</span><br>

The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, and
<code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceDescriptorIndexingProperties</code>::<code>maxDescriptorSetUpdateAfterBindStorageImages</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03043" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03043"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03043</span><br>

The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> accessible across all shader
stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than
or equal to
<code>VkPhysicalDeviceDescriptorIndexingProperties</code>::<code>maxDescriptorSetUpdateAfterBindInputAttachments</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-02217" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-02217"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-02217</span><br>

The total number of bindings with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceInlineUniformBlockPropertiesEXT</code>::<code>maxDescriptorSetUpdateAfterBindInlineUniformBlocks</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-00292" href="#VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-00292"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-00292</span><br>

Any two elements of <code>pPushConstantRanges</code> <strong class="purple">must</strong> not include the same
stage in <code>stageFlags</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00293" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00293"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00293</span><br>

<code>pSetLayouts</code> <strong class="purple">must</strong> not contain more than one descriptor set layout
that was created with
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code> set</p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03571" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03571"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03571</span><br>

The total number of bindings in descriptor set layouts created without
the <code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit
set with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code> accessible to any
given shader stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be
less than or equal to
<a href="chap42.html#VkPhysicalDeviceAccelerationStructurePropertiesKHR">VkPhysicalDeviceAccelerationStructurePropertiesKHR</a>::<code>maxPerStageDescriptorAccelerationStructures</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03572" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03572"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03572</span><br>

The total number of bindings with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code> to any given shader
stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than or
equal to
<a href="chap42.html#VkPhysicalDeviceAccelerationStructurePropertiesKHR">VkPhysicalDeviceAccelerationStructurePropertiesKHR</a>::<code>maxPerStageDescriptorUpdateAfterBindAccelerationStructures</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03573" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03573"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03573</span><br>

The total number of bindings in descriptor set layouts created without
the <code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit
set with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code> accessible across
all shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be
less than or equal to
<a href="chap42.html#VkPhysicalDeviceAccelerationStructurePropertiesKHR">VkPhysicalDeviceAccelerationStructurePropertiesKHR</a>::<code>maxDescriptorSetAccelerationStructures</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-03574" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-03574"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-03574</span><br>

The total number of bindings with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code> accessible across
all shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be
less than or equal to
<a href="chap42.html#VkPhysicalDeviceAccelerationStructurePropertiesKHR">VkPhysicalDeviceAccelerationStructurePropertiesKHR</a>::<code>maxDescriptorSetUpdateAfterBindAccelerationStructures</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-02381" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-02381"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-descriptorType-02381</span><br>

The total number of bindings with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<a href="chap42.html#VkPhysicalDeviceRayTracingPropertiesNV">VkPhysicalDeviceRayTracingPropertiesNV</a>::<code>maxDescriptorSetAccelerationStructures</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pImmutableSamplers-03566" href="#VUID-VkPipelineLayoutCreateInfo-pImmutableSamplers-03566"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pImmutableSamplers-03566</span><br>

The total number of <code>pImmutableSamplers</code> created with <code>flags</code>
containing <code>VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT</code> or
<code>VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT</code> across
all shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be
less than or equal to
<a href="chap42.html#limits-maxDescriptorSetSubsampledSamplers"><code>VkPhysicalDeviceFragmentDensityMap2PropertiesEXT</code>::<code>maxDescriptorSetSubsampledSamplers</code></a></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-04606" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-04606"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pSetLayouts-04606</span><br>

Any element of <code>pSetLayouts</code> <strong class="purple">must</strong> not have been created with the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE</code> bit set</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-sType-sType" href="#VUID-VkPipelineLayoutCreateInfo-sType-sType"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pNext-pNext" href="#VUID-VkPipelineLayoutCreateInfo-pNext-pNext"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pNext-pNext</span><br>
 <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-flags-zerobitmask" href="#VUID-VkPipelineLayoutCreateInfo-flags-zerobitmask"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-flags-zerobitmask</span><br>
 <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-parameter" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-parameter"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pSetLayouts-parameter</span><br>
 If <code>setLayoutCount</code> is not <code>0</code>, <code>pSetLayouts</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>setLayoutCount</code> valid <a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a> handles</p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter" href="#VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter"></a> <span class="vuid">VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter</span><br>
 If <code>pushConstantRangeCount</code> is not <code>0</code>, <code>pPushConstantRanges</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pushConstantRangeCount</code> valid <a href="#VkPushConstantRange">VkPushConstantRange</a> structures</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkPipelineLayoutCreateFlags" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> VkFlags VkPipelineLayoutCreateFlags;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkPipelineLayoutCreateFlags</code> is a bitmask type for setting a mask, but
is currently reserved for future use.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkPushConstantRange</code> structure is defined as:</p>
</div>
<div id="VkPushConstantRange" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkPushConstantRange {
    VkShaderStageFlags    stageFlags;
    uint32_t              offset;
    uint32_t              size;
} VkPushConstantRange;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>stageFlags</code> is a set of stage flags describing the shader stages
that will access a range of push constants.
If a particular stage is not included in the range, then accessing
members of that range of push constants from the corresponding shader
stage will return undefined values.</p>
</li>
<li>
<p><code>offset</code> and <code>size</code> are the start offset and size, respectively,
consumed by the range.
Both <code>offset</code> and <code>size</code> are in units of bytes and <strong class="purple">must</strong> be a
multiple of 4.
The layout of the push constant variables is specified in the shader.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPushConstantRange-offset-00294" href="#VUID-VkPushConstantRange-offset-00294"></a> <span class="vuid">VUID-VkPushConstantRange-offset-00294</span><br>

<code>offset</code> <strong class="purple">must</strong> be less than
<code>VkPhysicalDeviceLimits</code>::<code>maxPushConstantsSize</code></p>
</li>
<li>
<p><a id="VUID-VkPushConstantRange-offset-00295" href="#VUID-VkPushConstantRange-offset-00295"></a> <span class="vuid">VUID-VkPushConstantRange-offset-00295</span><br>

<code>offset</code> <strong class="purple">must</strong> be a multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-VkPushConstantRange-size-00296" href="#VUID-VkPushConstantRange-size-00296"></a> <span class="vuid">VUID-VkPushConstantRange-size-00296</span><br>

<code>size</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkPushConstantRange-size-00297" href="#VUID-VkPushConstantRange-size-00297"></a> <span class="vuid">VUID-VkPushConstantRange-size-00297</span><br>

<code>size</code> <strong class="purple">must</strong> be a multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-VkPushConstantRange-size-00298" href="#VUID-VkPushConstantRange-size-00298"></a> <span class="vuid">VUID-VkPushConstantRange-size-00298</span><br>

<code>size</code> <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPushConstantsSize</code> minus
<code>offset</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPushConstantRange-stageFlags-parameter" href="#VUID-VkPushConstantRange-stageFlags-parameter"></a> <span class="vuid">VUID-VkPushConstantRange-stageFlags-parameter</span><br>
 <code>stageFlags</code> <strong class="purple">must</strong> be a valid combination of <a href="chap11.html#VkShaderStageFlagBits">VkShaderStageFlagBits</a> values</p>
</li>
<li>
<p><a id="VUID-VkPushConstantRange-stageFlags-requiredbitmask" href="#VUID-VkPushConstantRange-stageFlags-requiredbitmask"></a> <span class="vuid">VUID-VkPushConstantRange-stageFlags-requiredbitmask</span><br>
 <code>stageFlags</code> <strong class="purple">must</strong> not be <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Once created, pipeline layouts are used as part of pipeline creation (see
<a href="chap11.html#pipelines">Pipelines</a>), as part of binding descriptor sets (see
<a href="#descriptorsets-binding">Descriptor Set Binding</a>), and as part of setting
push constants (see <a href="#descriptorsets-push-constants">Push Constant
Updates</a>).
Pipeline creation accepts a pipeline layout as input, and the layout <strong class="purple">may</strong> be
used to map (set, binding, arrayElement) tuples to implementation resources
or memory locations within a descriptor set.
The assignment of implementation resources depends only on the bindings
defined in the descriptor sets that comprise the pipeline layout, and not on
any shader source.</p>
</div>
<div id="descriptorsets-pipelinelayout-consistency" class="paragraph">
<p>All resource variables <a href="chap10.html#shaders-staticuse">statically used</a> in all shaders
in a pipeline <strong class="purple">must</strong> be declared with a (set,binding,arrayElement) that
exists in the corresponding descriptor set layout and is of an appropriate
descriptor type and includes the set of shader stages it is used by in
<code>stageFlags</code>.
The pipeline layout <strong class="purple">can</strong> include entries that are not used by a particular
pipeline, or that are dead-code eliminated from any of the shaders.
The pipeline layout allows the application to provide a consistent set of
bindings across multiple pipeline compiles, which enables those pipelines to
be compiled in a way that the implementation <strong class="purple">may</strong> cheaply switch pipelines
without reprogramming the bindings.</p>
</div>
<div class="paragraph">
<p>Similarly, the push constant block declared in each shader (if present)
<strong class="purple">must</strong> only place variables at offsets that are each included in a push
constant range with <code>stageFlags</code> including the bit corresponding to the
shader stage that uses it.
The pipeline layout <strong class="purple">can</strong> include ranges or portions of ranges that are not
used by a particular pipeline, or for which the variables have been
dead-code eliminated from any of the shaders.</p>
</div>
<div class="paragraph">
<p>There is a limit on the total number of resources of each type that <strong class="purple">can</strong> be
included in bindings in all descriptor set layouts in a pipeline layout as
shown in <a href="#descriptorsets-pipelinelayout-limits">Pipeline Layout Resource
Limits</a>.
The “Total Resources Available” column gives the limit on the number of
each type of resource that <strong class="purple">can</strong> be included in bindings in all descriptor
sets in the pipeline layout.
Some resource types count against multiple limits.
Additionally, there are limits on the total number of each type of resource
that <strong class="purple">can</strong> be used in any pipeline stage as described in
<a href="chap16.html#interfaces-resources-limits">Shader Resource Limits</a>.</p>
</div>
<table id="descriptorsets-pipelinelayout-limits" class="tableblock frame-all grid-all" style="width: 80%;">
<caption class="title">Table 17. Pipeline Layout Resource Limits</caption>
<colgroup>
<col style="width: 62.7118%;">
<col style="width: 37.2882%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Total Resources Available</th>
<th class="tableblock halign-left valign-top">Resource Types</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle" rowspan="2"><p class="tableblock"><code>maxDescriptorSetSamplers</code>
or <code>maxDescriptorSetUpdateAfterBindSamplers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sampler</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">combined image sampler</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" rowspan="3"><p class="tableblock"><code>maxDescriptorSetSampledImages</code>
or <code>maxDescriptorSetUpdateAfterBindSampledImages</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sampled image</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">combined image sampler</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uniform texel buffer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" rowspan="2"><p class="tableblock"><code>maxDescriptorSetStorageImages</code>
or <code>maxDescriptorSetUpdateAfterBindStorageImages</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">storage image</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">storage texel buffer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" rowspan="2"><p class="tableblock"><code>maxDescriptorSetUniformBuffers</code>
or <code>maxDescriptorSetUpdateAfterBindUniformBuffers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uniform buffer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uniform buffer dynamic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxDescriptorSetUniformBuffersDynamic</code>
or <code>maxDescriptorSetUpdateAfterBindUniformBuffersDynamic</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uniform buffer dynamic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" rowspan="2"><p class="tableblock"><code>maxDescriptorSetStorageBuffers</code>
or <code>maxDescriptorSetUpdateAfterBindStorageBuffers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">storage buffer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">storage buffer dynamic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxDescriptorSetStorageBuffersDynamic</code>
or <code>maxDescriptorSetUpdateAfterBindStorageBuffersDynamic</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">storage buffer dynamic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxDescriptorSetInputAttachments</code>
or <code>maxDescriptorSetUpdateAfterBindInputAttachments</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">input attachment</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxDescriptorSetInlineUniformBlocks</code>
or <code>maxDescriptorSetUpdateAfterBindInlineUniformBlocks</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">inline uniform block</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxDescriptorSetAccelerationStructures</code>
or <code>maxDescriptorSetUpdateAfterBindAccelerationStructures</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">acceleration structure</p></td>
</tr>
</tbody>
</table>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To destroy a pipeline layout, call:</p>
</div>
<div id="vkDestroyPipelineLayout" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="directive">void</span> vkDestroyPipelineLayout(
    VkDevice                                    device,
    VkPipelineLayout                            pipelineLayout,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that destroys the pipeline layout.</p>
</li>
<li>
<p><code>pipelineLayout</code> is the pipeline layout to destroy.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap12.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyPipelineLayout-pipelineLayout-00299" href="#VUID-vkDestroyPipelineLayout-pipelineLayout-00299"></a> <span class="vuid">VUID-vkDestroyPipelineLayout-pipelineLayout-00299</span><br>

If <code>VkAllocationCallbacks</code> were provided when <code>pipelineLayout</code>
was created, a compatible set of callbacks <strong class="purple">must</strong> be provided here</p>
</li>
<li>
<p><a id="VUID-vkDestroyPipelineLayout-pipelineLayout-00300" href="#VUID-vkDestroyPipelineLayout-pipelineLayout-00300"></a> <span class="vuid">VUID-vkDestroyPipelineLayout-pipelineLayout-00300</span><br>

If no <code>VkAllocationCallbacks</code> were provided when
<code>pipelineLayout</code> was created, <code>pAllocator</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-vkDestroyPipelineLayout-pipelineLayout-02004" href="#VUID-vkDestroyPipelineLayout-pipelineLayout-02004"></a> <span class="vuid">VUID-vkDestroyPipelineLayout-pipelineLayout-02004</span><br>

<code>pipelineLayout</code> <strong class="purple">must</strong> not have been passed to any <code>vkCmd*</code>
command for any command buffers that are still in the
<a href="chap7.html#commandbuffers-lifecycle">recording state</a> when
<code>vkDestroyPipelineLayout</code> is called</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyPipelineLayout-device-parameter" href="#VUID-vkDestroyPipelineLayout-device-parameter"></a> <span class="vuid">VUID-vkDestroyPipelineLayout-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyPipelineLayout-pipelineLayout-parameter" href="#VUID-vkDestroyPipelineLayout-pipelineLayout-parameter"></a> <span class="vuid">VUID-vkDestroyPipelineLayout-pipelineLayout-parameter</span><br>
 If <code>pipelineLayout</code> is not <a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>pipelineLayout</code> <strong class="purple">must</strong> be a valid <a href="#VkPipelineLayout">VkPipelineLayout</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyPipelineLayout-pAllocator-parameter" href="#VUID-vkDestroyPipelineLayout-pAllocator-parameter"></a> <span class="vuid">VUID-vkDestroyPipelineLayout-pAllocator-parameter</span><br>
 If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap12.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkDestroyPipelineLayout-pipelineLayout-parent" href="#VUID-vkDestroyPipelineLayout-pipelineLayout-parent"></a> <span class="vuid">VUID-vkDestroyPipelineLayout-pipelineLayout-parent</span><br>
 If <code>pipelineLayout</code> is a valid handle, it <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>pipelineLayout</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="descriptorsets-compatibility"><a class="anchor" href="#descriptorsets-compatibility"></a>Pipeline Layout Compatibility</h5>
<div class="paragraph">
<p>Two pipeline layouts are defined to be “compatible for
<a href="#descriptorsets-push-constants">push constants</a>” if they were created
with identical push constant ranges.
Two pipeline layouts are defined to be “compatible for set N” if they were
created with <em>identically defined</em> descriptor set layouts for sets zero
through N, and if they were created with identical push constant ranges.</p>
</div>
<div class="paragraph">
<p>When binding a descriptor set (see <a href="#descriptorsets-binding">Descriptor Set
Binding</a>) to set number N, if the previously bound descriptor sets for sets
zero through N-1 were all bound using compatible pipeline layouts, then
performing this binding does not disturb any of the lower numbered sets.
If, additionally, the previous bound descriptor set for set N was bound
using a pipeline layout compatible for set N, then the bindings in sets
numbered greater than N are also not disturbed.</p>
</div>
<div class="paragraph">
<p>Similarly, when binding a pipeline, the pipeline <strong class="purple">can</strong> correctly access any
previously bound descriptor sets which were bound with compatible pipeline
layouts, as long as all lower numbered sets were also bound with compatible
layouts.</p>
</div>
<div class="paragraph">
<p>Layout compatibility means that descriptor sets <strong class="purple">can</strong> be bound to a command
buffer for use by any pipeline created with a compatible pipeline layout,
and without having bound a particular pipeline first.
It also means that descriptor sets <strong class="purple">can</strong> remain valid across a pipeline
change, and the same resources will be accessible to the newly bound
pipeline.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Implementor’s Note</div>
<div class="paragraph">
<p>A consequence of layout compatibility is that when the implementation
compiles a pipeline layout and maps pipeline resources to implementation
resources, the mechanism for set N <strong class="purple">should</strong> only be a function of sets
[0..N].</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Place the least frequently changing descriptor sets near the start of the
pipeline layout, and place the descriptor sets representing the most
frequently changing resources near the end.
When pipelines are switched, only the descriptor set bindings that have been
invalidated will need to be updated and the remainder of the descriptor set
bindings will remain in place.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The maximum number of descriptor sets that <strong class="purple">can</strong> be bound to a pipeline
layout is queried from physical device properties (see
<code>maxBoundDescriptorSets</code> in <a href="chap42.html#limits">Limits</a>).</p>
</div>
<div class="listingblock">
<div class="title">API example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">const</span> VkDescriptorSetLayout layouts[] = { layout1, layout2 };

<span class="directive">const</span> VkPushConstantRange ranges[] =
{
    {
        VK_SHADER_STAGE_VERTEX_BIT,    <span class="comment">// stageFlags</span>
        <span class="integer">0</span>,                             <span class="comment">// offset</span>
        <span class="integer">4</span>                              <span class="comment">// size</span>
    },

    {
        VK_SHADER_STAGE_FRAGMENT_BIT,  <span class="comment">// stageFlags</span>
        <span class="integer">4</span>,                             <span class="comment">// offset</span>
        <span class="integer">4</span>                              <span class="comment">// size</span>
    },
};

<span class="directive">const</span> VkPipelineLayoutCreateInfo createInfo =
{
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,  <span class="comment">// sType</span>
    <span class="predefined-constant">NULL</span>,                                           <span class="comment">// pNext</span>
    <span class="integer">0</span>,                                              <span class="comment">// flags</span>
    <span class="integer">2</span>,                                              <span class="comment">// setLayoutCount</span>
    layouts,                                        <span class="comment">// pSetLayouts</span>
    <span class="integer">2</span>,                                              <span class="comment">// pushConstantRangeCount</span>
    ranges                                          <span class="comment">// pPushConstantRanges</span>
};

VkPipelineLayout myPipelineLayout;
myResult = vkCreatePipelineLayout(
    myDevice,
    &amp;createInfo,
    <span class="predefined-constant">NULL</span>,
    &amp;myPipelineLayout);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-allocation"><a class="anchor" href="#descriptorsets-allocation"></a>14.2.3. Allocation of Descriptor Sets</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>A <em>descriptor pool</em> maintains a pool of descriptors, from which descriptor
sets are allocated.
Descriptor pools are externally synchronized, meaning that the application
<strong class="purple">must</strong> not allocate and/or free descriptor sets from the same pool in
multiple threads simultaneously.</p>
</div>
<div class="paragraph">
<p>Descriptor pools are represented by <code>VkDescriptorPool</code> handles:</p>
</div>
<div id="VkDescriptorPool" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create a descriptor pool object, call:</p>
</div>
<div id="vkCreateDescriptorPool" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
VkResult vkCreateDescriptorPool(
    VkDevice                                    device,
    <span class="directive">const</span> VkDescriptorPoolCreateInfo*           pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkDescriptorPool*                           pDescriptorPool);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that creates the descriptor pool.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to a <a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a>
structure specifying the state of the descriptor pool object.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap12.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
<li>
<p><code>pDescriptorPool</code> is a pointer to a <a href="#VkDescriptorPool">VkDescriptorPool</a> handle in
which the resulting descriptor pool object is returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap12.html#memory-allocation">Memory Allocation</a> chapter.</p>
</div>
<div class="paragraph">
<p>The created descriptor pool is returned in <code>pDescriptorPool</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateDescriptorPool-device-parameter" href="#VUID-vkCreateDescriptorPool-device-parameter"></a> <span class="vuid">VUID-vkCreateDescriptorPool-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorPool-pCreateInfo-parameter" href="#VUID-vkCreateDescriptorPool-pCreateInfo-parameter"></a> <span class="vuid">VUID-vkCreateDescriptorPool-pCreateInfo-parameter</span><br>
 <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorPool-pAllocator-parameter" href="#VUID-vkCreateDescriptorPool-pAllocator-parameter"></a> <span class="vuid">VUID-vkCreateDescriptorPool-pAllocator-parameter</span><br>
 If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap12.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorPool-pDescriptorPool-parameter" href="#VUID-vkCreateDescriptorPool-pDescriptorPool-parameter"></a> <span class="vuid">VUID-vkCreateDescriptorPool-pDescriptorPool-parameter</span><br>
 <code>pDescriptorPool</code> <strong class="purple">must</strong> be a valid pointer to a <a href="#VkDescriptorPool">VkDescriptorPool</a> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap4.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap4.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_FRAGMENTATION_EXT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Additional information about the pool is passed in a
<code>VkDescriptorPoolCreateInfo</code> structure:</p>
</div>
<div id="VkDescriptorPoolCreateInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorPoolCreateInfo {
    VkStructureType                sType;
    <span class="directive">const</span> <span class="directive">void</span>*                    pNext;
    VkDescriptorPoolCreateFlags    flags;
    uint32_t                       maxSets;
    uint32_t                       poolSizeCount;
    <span class="directive">const</span> VkDescriptorPoolSize*    pPoolSizes;
} VkDescriptorPoolCreateInfo;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>flags</code> is a bitmask of <a href="#VkDescriptorPoolCreateFlagBits">VkDescriptorPoolCreateFlagBits</a>
specifying certain supported operations on the pool.</p>
</li>
<li>
<p><code>maxSets</code> is the maximum number of descriptor sets that <strong class="purple">can</strong> be
allocated from the pool.</p>
</li>
<li>
<p><code>poolSizeCount</code> is the number of elements in <code>pPoolSizes</code>.</p>
</li>
<li>
<p><code>pPoolSizes</code> is a pointer to an array of <a href="#VkDescriptorPoolSize">VkDescriptorPoolSize</a>
structures, each containing a descriptor type and number of descriptors
of that type to be allocated in the pool.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If multiple <code>VkDescriptorPoolSize</code> structures appear in the
<code>pPoolSizes</code> array then the pool will be created with enough storage for
the total number of descriptors of each type.</p>
</div>
<div class="paragraph">
<p>Fragmentation of a descriptor pool is possible and <strong class="purple">may</strong> lead to descriptor
set allocation failures.
A failure due to fragmentation is defined as failing a descriptor set
allocation despite the sum of all outstanding descriptor set allocations
from the pool plus the requested allocation requiring no more than the total
number of descriptors requested at pool creation.
Implementations provide certain guarantees of when fragmentation <strong class="purple">must</strong> not
cause allocation failure, as described below.</p>
</div>
<div class="paragraph">
<p>If a descriptor pool has not had any descriptor sets freed since it was
created or most recently reset then fragmentation <strong class="purple">must</strong> not cause an
allocation failure (note that this is always the case for a pool created
without the <code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code> bit
set).
Additionally, if all sets allocated from the pool since it was created or
most recently reset use the same number of descriptors (of each type) and
the requested allocation also uses that same number of descriptors (of each
type), then fragmentation <strong class="purple">must</strong> not cause an allocation failure.</p>
</div>
<div class="paragraph">
<p>If an allocation failure occurs due to fragmentation, an application <strong class="purple">can</strong>
create an additional descriptor pool to perform further descriptor set
allocations.</p>
</div>
<div class="paragraph">
<p>If <code>flags</code> has the <code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT</code>
bit set, descriptor pool creation <strong class="purple">may</strong> fail with the error
<code>VK_ERROR_FRAGMENTATION</code> if the total number of descriptors across all
pools (including this one) created with this bit set exceeds
<code>maxUpdateAfterBindDescriptorsInAllPools</code>, or if fragmentation of the
underlying hardware resources occurs.</p>
</div>
<div class="paragraph">
<p>If a <code>pPoolSizes</code>[i]::<code>type</code> is
<code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>, a
<a href="#VkMutableDescriptorTypeCreateInfoVALVE">VkMutableDescriptorTypeCreateInfoVALVE</a> struct in the <code>pNext</code> chain
<strong class="purple">can</strong> be used to specify which mutable descriptor types <strong class="purple">can</strong> be allocated
from the pool.
If present in the <code>pNext</code> chain,
<a href="#VkMutableDescriptorTypeCreateInfoVALVE">VkMutableDescriptorTypeCreateInfoVALVE</a>::<code>pMutableDescriptorTypeLists</code>[i]
specifies which kind of <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code> descriptors
<strong class="purple">can</strong> be allocated from this pool entry.
If <a href="#VkMutableDescriptorTypeCreateInfoVALVE">VkMutableDescriptorTypeCreateInfoVALVE</a> does not exist in the
<code>pNext</code> chain, or
<a href="#VkMutableDescriptorTypeCreateInfoVALVE">VkMutableDescriptorTypeCreateInfoVALVE</a>::<code>pMutableDescriptorTypeLists</code>[i]
is out of range, the descriptor pool allocates enough memory to be able to
allocate a <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code> descriptor with any
supported <a href="#VkDescriptorType">VkDescriptorType</a> as a mutable descriptor.
A mutable descriptor <strong class="purple">can</strong> be allocated from a pool entry if the type list in
<a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a> is a subset of the type list declared
in the descriptor pool, or if the pool entry is created without a descriptor
type list.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-maxSets-00301" href="#VUID-VkDescriptorPoolCreateInfo-maxSets-00301"></a> <span class="vuid">VUID-VkDescriptorPoolCreateInfo-maxSets-00301</span><br>

<code>maxSets</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-flags-04607" href="#VUID-VkDescriptorPoolCreateInfo-flags-04607"></a> <span class="vuid">VUID-VkDescriptorPoolCreateInfo-flags-04607</span><br>

If <code>flags</code> has the
<code>VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE</code> bit set, then the
<code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT</code> bit <strong class="purple">must</strong> not be
set</p>
</li>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-mutableDescriptorType-04608" href="#VUID-VkDescriptorPoolCreateInfo-mutableDescriptorType-04608"></a> <span class="vuid">VUID-VkDescriptorPoolCreateInfo-mutableDescriptorType-04608</span><br>

If
<a href="chap41.html#VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE">VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE</a>::<code>mutableDescriptorType</code>
is not enabled, <code>pPoolSizes</code> <strong class="purple">must</strong> not contain a
<code>descriptorType</code> of <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-flags-04609" href="#VUID-VkDescriptorPoolCreateInfo-flags-04609"></a> <span class="vuid">VUID-VkDescriptorPoolCreateInfo-flags-04609</span><br>

If <code>flags</code> has the
<code>VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE</code> bit set,
<a href="chap41.html#VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE">VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE</a>::<code>mutableDescriptorType</code>
<strong class="purple">must</strong> be enabled</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-sType-sType" href="#VUID-VkDescriptorPoolCreateInfo-sType-sType"></a> <span class="vuid">VUID-VkDescriptorPoolCreateInfo-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-pNext-pNext" href="#VUID-VkDescriptorPoolCreateInfo-pNext-pNext"></a> <span class="vuid">VUID-VkDescriptorPoolCreateInfo-pNext-pNext</span><br>
 Each <code>pNext</code> member of any structure (including this one) in the <code>pNext</code> chain <strong class="purple">must</strong> be either <code>NULL</code> or a pointer to a valid instance of <a href="#VkDescriptorPoolInlineUniformBlockCreateInfoEXT">VkDescriptorPoolInlineUniformBlockCreateInfoEXT</a> or <a href="#VkMutableDescriptorTypeCreateInfoVALVE">VkMutableDescriptorTypeCreateInfoVALVE</a></p>
</li>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-sType-unique" href="#VUID-VkDescriptorPoolCreateInfo-sType-unique"></a> <span class="vuid">VUID-VkDescriptorPoolCreateInfo-sType-unique</span><br>
 The <code>sType</code> value of each struct in the <code>pNext</code> chain <strong class="purple">must</strong> be unique</p>
</li>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-flags-parameter" href="#VUID-VkDescriptorPoolCreateInfo-flags-parameter"></a> <span class="vuid">VUID-VkDescriptorPoolCreateInfo-flags-parameter</span><br>
 <code>flags</code> <strong class="purple">must</strong> be a valid combination of <a href="#VkDescriptorPoolCreateFlagBits">VkDescriptorPoolCreateFlagBits</a> values</p>
</li>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-pPoolSizes-parameter" href="#VUID-VkDescriptorPoolCreateInfo-pPoolSizes-parameter"></a> <span class="vuid">VUID-VkDescriptorPoolCreateInfo-pPoolSizes-parameter</span><br>
 <code>pPoolSizes</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>poolSizeCount</code> valid <a href="#VkDescriptorPoolSize">VkDescriptorPoolSize</a> structures</p>
</li>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-poolSizeCount-arraylength" href="#VUID-VkDescriptorPoolCreateInfo-poolSizeCount-arraylength"></a> <span class="vuid">VUID-VkDescriptorPoolCreateInfo-poolSizeCount-arraylength</span><br>
 <code>poolSizeCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>In order to be able to allocate descriptor sets having
<a href="#descriptorsets-inlineuniformblock">inline uniform block</a> bindings the
descriptor pool <strong class="purple">must</strong> be created with specifying the inline uniform block
binding capacity of the descriptor pool, in addition to the total inline
uniform data capacity in bytes which is specified through a
<a href="#VkDescriptorPoolSize">VkDescriptorPoolSize</a> structure with a <code>descriptorType</code> value of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>.
This <strong class="purple">can</strong> be done by adding a
<code>VkDescriptorPoolInlineUniformBlockCreateInfoEXT</code> structure to the
<code>pNext</code> chain of <a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a>.</p>
</div>
<div class="paragraph">
<p>The <code>VkDescriptorPoolInlineUniformBlockCreateInfoEXT</code> structure is
defined as:</p>
</div>
<div id="VkDescriptorPoolInlineUniformBlockCreateInfoEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_EXT_inline_uniform_block</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorPoolInlineUniformBlockCreateInfoEXT {
    VkStructureType    sType;
    <span class="directive">const</span> <span class="directive">void</span>*        pNext;
    uint32_t           maxInlineUniformBlockBindings;
} VkDescriptorPoolInlineUniformBlockCreateInfoEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>maxInlineUniformBlockBindings</code> is the number of inline uniform
block bindings to allocate.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorPoolInlineUniformBlockCreateInfoEXT-sType-sType" href="#VUID-VkDescriptorPoolInlineUniformBlockCreateInfoEXT-sType-sType"></a> <span class="vuid">VUID-VkDescriptorPoolInlineUniformBlockCreateInfoEXT-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Bits which <strong class="purple">can</strong> be set in <a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a>::<code>flags</code> to
enable operations on a descriptor pool are:</p>
</div>
<div id="VkDescriptorPoolCreateFlagBits" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> <span class="keyword">enum</span> VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = <span class="hex">0x00000001</span>,
    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = <span class="hex">0x00000002</span>,
  <span class="comment">// Provided by VK_VALVE_mutable_descriptor_type</span>
    VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE = <span class="hex">0x00000004</span>,
  <span class="comment">// Provided by VK_EXT_descriptor_indexing</span>
    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
} VkDescriptorPoolCreateFlagBits;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code> specifies that
descriptor sets <strong class="purple">can</strong> return their individual allocations to the pool,
i.e. all of <a href="#vkAllocateDescriptorSets">vkAllocateDescriptorSets</a>, <a href="#vkFreeDescriptorSets">vkFreeDescriptorSets</a>,
and <a href="#vkResetDescriptorPool">vkResetDescriptorPool</a> are allowed.
Otherwise, descriptor sets allocated from the pool <strong class="purple">must</strong> not be
individually freed back to the pool, i.e. only
<a href="#vkAllocateDescriptorSets">vkAllocateDescriptorSets</a> and <a href="#vkResetDescriptorPool">vkResetDescriptorPool</a> are
allowed.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT</code> specifies that
descriptor sets allocated from this pool <strong class="purple">can</strong> include bindings with the
<code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code> bit set.
It is valid to allocate descriptor sets that have bindings that do not
set the <code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code> bit from a
pool that has <code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT</code> set.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE</code> specifies that this
descriptor pool and the descriptor sets allocated from it reside
entirely in host memory and cannot be bound.
Descriptor sets allocated from this pool are partially exempt from the
external synchronization requirement in
<a href="#vkUpdateDescriptorSetWithTemplateKHR">vkUpdateDescriptorSetWithTemplateKHR</a> and
<a href="#vkUpdateDescriptorSets">vkUpdateDescriptorSets</a>.
Descriptor sets and their descriptors can be updated concurrently in
different threads, though the same descriptor <strong class="purple">must</strong> not be updated
concurrently by two threads.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkDescriptorPoolCreateFlags" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> VkFlags VkDescriptorPoolCreateFlags;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkDescriptorPoolCreateFlags</code> is a bitmask type for setting a mask of
zero or more <a href="#VkDescriptorPoolCreateFlagBits">VkDescriptorPoolCreateFlagBits</a>.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDescriptorPoolSize</code> structure is defined as:</p>
</div>
<div id="VkDescriptorPoolSize" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorPoolSize {
    VkDescriptorType    type;
    uint32_t            descriptorCount;
} VkDescriptorPoolSize;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>type</code> is the type of descriptor.</p>
</li>
<li>
<p><code>descriptorCount</code> is the number of descriptors of that type to
allocate.
If <code>type</code> is <code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> then
<code>descriptorCount</code> is the number of bytes to allocate for descriptors
of this type.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>When creating a descriptor pool that will contain descriptors for combined
image samplers of multi-planar formats, an application needs to account for
non-trivial descriptor consumption when choosing the <code>descriptorCount</code>
value, as indicated by
<a href="chap44.html#VkSamplerYcbcrConversionImageFormatProperties">VkSamplerYcbcrConversionImageFormatProperties</a>::<code>combinedImageSamplerDescriptorCount</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorPoolSize-descriptorCount-00302" href="#VUID-VkDescriptorPoolSize-descriptorCount-00302"></a> <span class="vuid">VUID-VkDescriptorPoolSize-descriptorCount-00302</span><br>

<code>descriptorCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorPoolSize-type-02218" href="#VUID-VkDescriptorPoolSize-type-02218"></a> <span class="vuid">VUID-VkDescriptorPoolSize-type-02218</span><br>

If <code>type</code> is <code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> then
<code>descriptorCount</code> <strong class="purple">must</strong> be a multiple of <code>4</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorPoolSize-type-parameter" href="#VUID-VkDescriptorPoolSize-type-parameter"></a> <span class="vuid">VUID-VkDescriptorPoolSize-type-parameter</span><br>
 <code>type</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorType">VkDescriptorType</a> value</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To destroy a descriptor pool, call:</p>
</div>
<div id="vkDestroyDescriptorPool" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="directive">void</span> vkDestroyDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that destroys the descriptor pool.</p>
</li>
<li>
<p><code>descriptorPool</code> is the descriptor pool to destroy.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap12.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a pool is destroyed, all descriptor sets allocated from the pool are
implicitly freed and become invalid.
Descriptor sets allocated from a given pool do not need to be freed before
destroying that descriptor pool.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyDescriptorPool-descriptorPool-00303" href="#VUID-vkDestroyDescriptorPool-descriptorPool-00303"></a> <span class="vuid">VUID-vkDestroyDescriptorPool-descriptorPool-00303</span><br>

All submitted commands that refer to <code>descriptorPool</code> (via any
allocated descriptor sets) <strong class="purple">must</strong> have completed execution</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorPool-descriptorPool-00304" href="#VUID-vkDestroyDescriptorPool-descriptorPool-00304"></a> <span class="vuid">VUID-vkDestroyDescriptorPool-descriptorPool-00304</span><br>

If <code>VkAllocationCallbacks</code> were provided when <code>descriptorPool</code>
was created, a compatible set of callbacks <strong class="purple">must</strong> be provided here</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorPool-descriptorPool-00305" href="#VUID-vkDestroyDescriptorPool-descriptorPool-00305"></a> <span class="vuid">VUID-vkDestroyDescriptorPool-descriptorPool-00305</span><br>

If no <code>VkAllocationCallbacks</code> were provided when
<code>descriptorPool</code> was created, <code>pAllocator</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyDescriptorPool-device-parameter" href="#VUID-vkDestroyDescriptorPool-device-parameter"></a> <span class="vuid">VUID-vkDestroyDescriptorPool-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorPool-descriptorPool-parameter" href="#VUID-vkDestroyDescriptorPool-descriptorPool-parameter"></a> <span class="vuid">VUID-vkDestroyDescriptorPool-descriptorPool-parameter</span><br>
 If <code>descriptorPool</code> is not <a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>descriptorPool</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorPool">VkDescriptorPool</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorPool-pAllocator-parameter" href="#VUID-vkDestroyDescriptorPool-pAllocator-parameter"></a> <span class="vuid">VUID-vkDestroyDescriptorPool-pAllocator-parameter</span><br>
 If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap12.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorPool-descriptorPool-parent" href="#VUID-vkDestroyDescriptorPool-descriptorPool-parent"></a> <span class="vuid">VUID-vkDestroyDescriptorPool-descriptorPool-parent</span><br>
 If <code>descriptorPool</code> is a valid handle, it <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>descriptorPool</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Descriptor sets are allocated from descriptor pool objects, and are
represented by <code>VkDescriptorSet</code> handles:</p>
</div>
<div id="VkDescriptorSet" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSet)</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To allocate descriptor sets from a descriptor pool, call:</p>
</div>
<div id="vkAllocateDescriptorSets" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
VkResult vkAllocateDescriptorSets(
    VkDevice                                    device,
    <span class="directive">const</span> VkDescriptorSetAllocateInfo*          pAllocateInfo,
    VkDescriptorSet*                            pDescriptorSets);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that owns the descriptor pool.</p>
</li>
<li>
<p><code>pAllocateInfo</code> is a pointer to a <a href="#VkDescriptorSetAllocateInfo">VkDescriptorSetAllocateInfo</a>
structure describing parameters of the allocation.</p>
</li>
<li>
<p><code>pDescriptorSets</code> is a pointer to an array of <a href="#VkDescriptorSet">VkDescriptorSet</a>
handles in which the resulting descriptor set objects are returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The allocated descriptor sets are returned in <code>pDescriptorSets</code>.</p>
</div>
<div class="paragraph">
<p>When a descriptor set is allocated, the initial state is largely
uninitialized and all descriptors are undefined.
Descriptors also become undefined if the underlying resource is destroyed.
Descriptor sets containing undefined descriptors <strong class="purple">can</strong> still be bound and
used, subject to the following conditions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For descriptor set bindings created with the
<code>VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT</code> bit set, all descriptors
in that binding that are dynamically used <strong class="purple">must</strong> have been populated
before the descriptor set is <a href="#descriptorsets-binding">consumed</a>.</p>
</li>
<li>
<p>For descriptor set bindings created without the
<code>VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT</code> bit set, all descriptors
in that binding that are statically used <strong class="purple">must</strong> have been populated
before the descriptor set is <a href="#descriptorsets-binding">consumed</a>.</p>
</li>
<li>
<p>Descriptor bindings with descriptor type of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> <strong class="purple">can</strong> be undefined
when the descriptor set is <a href="#descriptorsets-binding">consumed</a>; though
values in that block will be undefined.</p>
</li>
<li>
<p>Entries that are not used by a pipeline <strong class="purple">can</strong> have undefined
descriptors.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a call to <code>vkAllocateDescriptorSets</code> would cause the total number of
descriptor sets allocated from the pool to exceed the value of
<a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a>::<code>maxSets</code> used to create
<code>pAllocateInfo-&gt;descriptorPool</code>, then the allocation <strong class="purple">may</strong> fail due to
lack of space in the descriptor pool.
Similarly, the allocation <strong class="purple">may</strong> fail due to lack of space if the call to
<code>vkAllocateDescriptorSets</code> would cause the number of any given
descriptor type to exceed the sum of all the <code>descriptorCount</code> members
of each element of <a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a>::<code>pPoolSizes</code> with a
<code>member</code> equal to that type.</p>
</div>
<div class="paragraph">
<p>Additionally, the allocation <strong class="purple">may</strong> also fail if a call to
<code>vkAllocateDescriptorSets</code> would cause the total number of inline
uniform block bindings allocated from the pool to exceed the value of
<a href="#VkDescriptorPoolInlineUniformBlockCreateInfoEXT">VkDescriptorPoolInlineUniformBlockCreateInfoEXT</a>::<code>maxInlineUniformBlockBindings</code>
used to create the descriptor pool.</p>
</div>
<div class="paragraph">
<p>If the allocation fails due to no more space in the descriptor pool, and not
because of system or device memory exhaustion, then
<code>VK_ERROR_OUT_OF_POOL_MEMORY</code> <strong class="purple">must</strong> be returned.</p>
</div>
<div class="paragraph">
<p><code>vkAllocateDescriptorSets</code> <strong class="purple">can</strong> be used to create multiple descriptor
sets.
If the creation of any of those descriptor sets fails, then the
implementation <strong class="purple">must</strong> destroy all successfully created descriptor set objects
from this command, set all entries of the <code>pDescriptorSets</code> array to
<a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> and return the error.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkAllocateDescriptorSets-device-parameter" href="#VUID-vkAllocateDescriptorSets-device-parameter"></a> <span class="vuid">VUID-vkAllocateDescriptorSets-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkAllocateDescriptorSets-pAllocateInfo-parameter" href="#VUID-vkAllocateDescriptorSets-pAllocateInfo-parameter"></a> <span class="vuid">VUID-vkAllocateDescriptorSets-pAllocateInfo-parameter</span><br>
 <code>pAllocateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkDescriptorSetAllocateInfo">VkDescriptorSetAllocateInfo</a> structure</p>
</li>
<li>
<p><a id="VUID-vkAllocateDescriptorSets-pDescriptorSets-parameter" href="#VUID-vkAllocateDescriptorSets-pDescriptorSets-parameter"></a> <span class="vuid">VUID-vkAllocateDescriptorSets-pDescriptorSets-parameter</span><br>
 <code>pDescriptorSets</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pAllocateInfo-&gt;descriptorSetCount</code> <a href="#VkDescriptorSet">VkDescriptorSet</a> handles</p>
</li>
<li>
<p><a id="VUID-vkAllocateDescriptorSets-pAllocateInfo::descriptorSetCount-arraylength" href="#VUID-vkAllocateDescriptorSets-pAllocateInfo::descriptorSetCount-arraylength"></a> <span class="vuid">VUID-vkAllocateDescriptorSets-pAllocateInfo::descriptorSetCount-arraylength</span><br>
 <code>pAllocateInfo-&gt;descriptorSetCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>pAllocateInfo-&gt;descriptorPool</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap4.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap4.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_FRAGMENTED_POOL</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_POOL_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDescriptorSetAllocateInfo</code> structure is defined as:</p>
</div>
<div id="VkDescriptorSetAllocateInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorSetAllocateInfo {
    VkStructureType                 sType;
    <span class="directive">const</span> <span class="directive">void</span>*                     pNext;
    VkDescriptorPool                descriptorPool;
    uint32_t                        descriptorSetCount;
    <span class="directive">const</span> VkDescriptorSetLayout*    pSetLayouts;
} VkDescriptorSetAllocateInfo;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>descriptorPool</code> is the pool which the sets will be allocated from.</p>
</li>
<li>
<p><code>descriptorSetCount</code> determines the number of descriptor sets to be
allocated from the pool.</p>
</li>
<li>
<p><code>pSetLayouts</code> is a pointer to an array of descriptor set layouts,
with each member specifying how the corresponding descriptor set is
allocated.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-pSetLayouts-00308" href="#VUID-VkDescriptorSetAllocateInfo-pSetLayouts-00308"></a> <span class="vuid">VUID-VkDescriptorSetAllocateInfo-pSetLayouts-00308</span><br>

Each element of <code>pSetLayouts</code> <strong class="purple">must</strong> not have been created with
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code> set</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-pSetLayouts-03044" href="#VUID-VkDescriptorSetAllocateInfo-pSetLayouts-03044"></a> <span class="vuid">VUID-VkDescriptorSetAllocateInfo-pSetLayouts-03044</span><br>

If any element of <code>pSetLayouts</code> was created with the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> bit
set, <code>descriptorPool</code> <strong class="purple">must</strong> have been created with the
<code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT</code> flag set</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-pSetLayouts-04610" href="#VUID-VkDescriptorSetAllocateInfo-pSetLayouts-04610"></a> <span class="vuid">VUID-VkDescriptorSetAllocateInfo-pSetLayouts-04610</span><br>

If any element of <code>pSetLayouts</code> was created with the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE</code> bit set,
<code>descriptorPool</code> <strong class="purple">must</strong> have been created with the
<code>VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE</code> flag set</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-sType-sType" href="#VUID-VkDescriptorSetAllocateInfo-sType-sType"></a> <span class="vuid">VUID-VkDescriptorSetAllocateInfo-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-pNext-pNext" href="#VUID-VkDescriptorSetAllocateInfo-pNext-pNext"></a> <span class="vuid">VUID-VkDescriptorSetAllocateInfo-pNext-pNext</span><br>
 <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code> or a pointer to a valid instance of <a href="#VkDescriptorSetVariableDescriptorCountAllocateInfo">VkDescriptorSetVariableDescriptorCountAllocateInfo</a></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-sType-unique" href="#VUID-VkDescriptorSetAllocateInfo-sType-unique"></a> <span class="vuid">VUID-VkDescriptorSetAllocateInfo-sType-unique</span><br>
 The <code>sType</code> value of each struct in the <code>pNext</code> chain <strong class="purple">must</strong> be unique</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-descriptorPool-parameter" href="#VUID-VkDescriptorSetAllocateInfo-descriptorPool-parameter"></a> <span class="vuid">VUID-VkDescriptorSetAllocateInfo-descriptorPool-parameter</span><br>
 <code>descriptorPool</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorPool">VkDescriptorPool</a> handle</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-pSetLayouts-parameter" href="#VUID-VkDescriptorSetAllocateInfo-pSetLayouts-parameter"></a> <span class="vuid">VUID-VkDescriptorSetAllocateInfo-pSetLayouts-parameter</span><br>
 <code>pSetLayouts</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorSetCount</code> valid <a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a> handles</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-arraylength" href="#VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-arraylength"></a> <span class="vuid">VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-arraylength</span><br>
 <code>descriptorSetCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-commonparent" href="#VUID-VkDescriptorSetAllocateInfo-commonparent"></a> <span class="vuid">VUID-VkDescriptorSetAllocateInfo-commonparent</span><br>
 Both of <code>descriptorPool</code>, and the elements of <code>pSetLayouts</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap6.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>If the <code>pNext</code> chain of a <a href="#VkDescriptorSetAllocateInfo">VkDescriptorSetAllocateInfo</a> structure
includes a <code>VkDescriptorSetVariableDescriptorCountAllocateInfo</code>
structure, then that structure includes an array of descriptor counts for
variable descriptor count bindings, one for each descriptor set being
allocated.</p>
</div>
<div class="paragraph">
<p>The <code>VkDescriptorSetVariableDescriptorCountAllocateInfo</code> structure is
defined as:</p>
</div>
<div id="VkDescriptorSetVariableDescriptorCountAllocateInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorSetVariableDescriptorCountAllocateInfo {
    VkStructureType    sType;
    <span class="directive">const</span> <span class="directive">void</span>*        pNext;
    uint32_t           descriptorSetCount;
    <span class="directive">const</span> uint32_t*    pDescriptorCounts;
} VkDescriptorSetVariableDescriptorCountAllocateInfo;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorSetVariableDescriptorCountAllocateInfoEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_EXT_descriptor_indexing</span>
<span class="keyword">typedef</span> VkDescriptorSetVariableDescriptorCountAllocateInfo VkDescriptorSetVariableDescriptorCountAllocateInfoEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>descriptorSetCount</code> is zero or the number of elements in
<code>pDescriptorCounts</code>.</p>
</li>
<li>
<p><code>pDescriptorCounts</code> is a pointer to an array of descriptor counts,
with each member specifying the number of descriptors in a variable
descriptor count binding in the corresponding descriptor set being
allocated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>descriptorSetCount</code> is zero or this structure is not included in the
<code>pNext</code> chain, then the variable lengths are considered to be zero.
Otherwise, <code>pDescriptorCounts</code>[i] is the number of descriptors in the
variable count descriptor binding in the corresponding descriptor set
layout.
If the variable count descriptor binding in the corresponding descriptor set
layout has a descriptor type of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> then
<code>pDescriptorCounts</code>[i] specifies the binding’s capacity in bytes.
If <a href="#VkDescriptorSetAllocateInfo">VkDescriptorSetAllocateInfo</a>::<code>pSetLayouts</code>[i] does not include
a variable count descriptor binding, then <code>pDescriptorCounts</code>[i] is
ignored.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-descriptorSetCount-03045" href="#VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-descriptorSetCount-03045"></a> <span class="vuid">VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-descriptorSetCount-03045</span><br>

If <code>descriptorSetCount</code> is not zero, <code>descriptorSetCount</code> <strong class="purple">must</strong>
equal <a href="#VkDescriptorSetAllocateInfo">VkDescriptorSetAllocateInfo</a>::<code>descriptorSetCount</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-pSetLayouts-03046" href="#VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-pSetLayouts-03046"></a> <span class="vuid">VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-pSetLayouts-03046</span><br>

If <a href="#VkDescriptorSetAllocateInfo">VkDescriptorSetAllocateInfo</a>::<code>pSetLayouts</code>[i] has a
variable descriptor count binding, then <code>pDescriptorCounts</code>[i] <strong class="purple">must</strong>
be less than or equal to the descriptor count specified for that binding
when the descriptor set layout was created</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-sType-sType" href="#VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-sType-sType"></a> <span class="vuid">VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-pDescriptorCounts-parameter" href="#VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-pDescriptorCounts-parameter"></a> <span class="vuid">VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-pDescriptorCounts-parameter</span><br>
 If <code>descriptorSetCount</code> is not <code>0</code>, <code>pDescriptorCounts</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorSetCount</code> <code>uint32_t</code> values</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To free allocated descriptor sets, call:</p>
</div>
<div id="vkFreeDescriptorSets" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
VkResult vkFreeDescriptorSets(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    <span class="directive">const</span> VkDescriptorSet*                      pDescriptorSets);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that owns the descriptor pool.</p>
</li>
<li>
<p><code>descriptorPool</code> is the descriptor pool from which the descriptor
sets were allocated.</p>
</li>
<li>
<p><code>descriptorSetCount</code> is the number of elements in the
<code>pDescriptorSets</code> array.</p>
</li>
<li>
<p><code>pDescriptorSets</code> is a pointer to an array of handles to
<a href="#VkDescriptorSet">VkDescriptorSet</a> objects.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>After calling <code>vkFreeDescriptorSets</code>, all descriptor sets in
<code>pDescriptorSets</code> are invalid.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkFreeDescriptorSets-pDescriptorSets-00309" href="#VUID-vkFreeDescriptorSets-pDescriptorSets-00309"></a> <span class="vuid">VUID-vkFreeDescriptorSets-pDescriptorSets-00309</span><br>

All submitted commands that refer to any element of
<code>pDescriptorSets</code> <strong class="purple">must</strong> have completed execution</p>
</li>
<li>
<p><a id="VUID-vkFreeDescriptorSets-pDescriptorSets-00310" href="#VUID-vkFreeDescriptorSets-pDescriptorSets-00310"></a> <span class="vuid">VUID-vkFreeDescriptorSets-pDescriptorSets-00310</span><br>

<code>pDescriptorSets</code> <strong class="purple">must</strong> be a valid pointer to an array of
<code>descriptorSetCount</code> <code>VkDescriptorSet</code> handles, each element of
which <strong class="purple">must</strong> either be a valid handle or <a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a></p>
</li>
<li>
<p><a id="VUID-vkFreeDescriptorSets-descriptorPool-00312" href="#VUID-vkFreeDescriptorSets-descriptorPool-00312"></a> <span class="vuid">VUID-vkFreeDescriptorSets-descriptorPool-00312</span><br>

<code>descriptorPool</code> <strong class="purple">must</strong> have been created with the
<code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code> flag</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkFreeDescriptorSets-device-parameter" href="#VUID-vkFreeDescriptorSets-device-parameter"></a> <span class="vuid">VUID-vkFreeDescriptorSets-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkFreeDescriptorSets-descriptorPool-parameter" href="#VUID-vkFreeDescriptorSets-descriptorPool-parameter"></a> <span class="vuid">VUID-vkFreeDescriptorSets-descriptorPool-parameter</span><br>
 <code>descriptorPool</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorPool">VkDescriptorPool</a> handle</p>
</li>
<li>
<p><a id="VUID-vkFreeDescriptorSets-descriptorSetCount-arraylength" href="#VUID-vkFreeDescriptorSets-descriptorSetCount-arraylength"></a> <span class="vuid">VUID-vkFreeDescriptorSets-descriptorSetCount-arraylength</span><br>
 <code>descriptorSetCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-vkFreeDescriptorSets-descriptorPool-parent" href="#VUID-vkFreeDescriptorSets-descriptorPool-parent"></a> <span class="vuid">VUID-vkFreeDescriptorSets-descriptorPool-parent</span><br>
 <code>descriptorPool</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
<li>
<p><a id="VUID-vkFreeDescriptorSets-pDescriptorSets-parent" href="#VUID-vkFreeDescriptorSets-pDescriptorSets-parent"></a> <span class="vuid">VUID-vkFreeDescriptorSets-pDescriptorSets-parent</span><br>
 Each element of <code>pDescriptorSets</code> that is a valid handle <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>descriptorPool</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>descriptorPool</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to each member of <code>pDescriptorSets</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap4.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To return all descriptor sets allocated from a given pool to the pool,
rather than freeing individual descriptor sets, call:</p>
</div>
<div id="vkResetDescriptorPool" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
VkResult vkResetDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that owns the descriptor pool.</p>
</li>
<li>
<p><code>descriptorPool</code> is the descriptor pool to be reset.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Resetting a descriptor pool recycles all of the resources from all of the
descriptor sets allocated from the descriptor pool back to the descriptor
pool, and the descriptor sets are implicitly freed.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkResetDescriptorPool-descriptorPool-00313" href="#VUID-vkResetDescriptorPool-descriptorPool-00313"></a> <span class="vuid">VUID-vkResetDescriptorPool-descriptorPool-00313</span><br>

All uses of <code>descriptorPool</code> (via any allocated descriptor sets)
<strong class="purple">must</strong> have completed execution</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkResetDescriptorPool-device-parameter" href="#VUID-vkResetDescriptorPool-device-parameter"></a> <span class="vuid">VUID-vkResetDescriptorPool-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkResetDescriptorPool-descriptorPool-parameter" href="#VUID-vkResetDescriptorPool-descriptorPool-parameter"></a> <span class="vuid">VUID-vkResetDescriptorPool-descriptorPool-parameter</span><br>
 <code>descriptorPool</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorPool">VkDescriptorPool</a> handle</p>
</li>
<li>
<p><a id="VUID-vkResetDescriptorPool-flags-zerobitmask" href="#VUID-vkResetDescriptorPool-flags-zerobitmask"></a> <span class="vuid">VUID-vkResetDescriptorPool-flags-zerobitmask</span><br>
 <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
<li>
<p><a id="VUID-vkResetDescriptorPool-descriptorPool-parent" href="#VUID-vkResetDescriptorPool-descriptorPool-parent"></a> <span class="vuid">VUID-vkResetDescriptorPool-descriptorPool-parent</span><br>
 <code>descriptorPool</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>descriptorPool</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to any <code>VkDescriptorSet</code> objects allocated from <code>descriptorPool</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap4.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkDescriptorPoolResetFlags" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> VkFlags VkDescriptorPoolResetFlags;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkDescriptorPoolResetFlags</code> is a bitmask type for setting a mask, but
is currently reserved for future use.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-updates"><a class="anchor" href="#descriptorsets-updates"></a>14.2.4. Descriptor Set Updates</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Once allocated, descriptor sets <strong class="purple">can</strong> be updated with a combination of write
and copy operations.
To update descriptor sets, call:</p>
</div>
<div id="vkUpdateDescriptorSets" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="directive">void</span> vkUpdateDescriptorSets(
    VkDevice                                    device,
    uint32_t                                    descriptorWriteCount,
    <span class="directive">const</span> VkWriteDescriptorSet*                 pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    <span class="directive">const</span> VkCopyDescriptorSet*                  pDescriptorCopies);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that updates the descriptor sets.</p>
</li>
<li>
<p><code>descriptorWriteCount</code> is the number of elements in the
<code>pDescriptorWrites</code> array.</p>
</li>
<li>
<p><code>pDescriptorWrites</code> is a pointer to an array of
<a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> structures describing the descriptor sets to
write to.</p>
</li>
<li>
<p><code>descriptorCopyCount</code> is the number of elements in the
<code>pDescriptorCopies</code> array.</p>
</li>
<li>
<p><code>pDescriptorCopies</code> is a pointer to an array of
<a href="#VkCopyDescriptorSet">VkCopyDescriptorSet</a> structures describing the descriptor sets to
copy between.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The operations described by <code>pDescriptorWrites</code> are performed first,
followed by the operations described by <code>pDescriptorCopies</code>.
Within each array, the operations are performed in the order they appear in
the array.</p>
</div>
<div class="paragraph">
<p>Each element in the <code>pDescriptorWrites</code> array describes an operation
updating the descriptor set using descriptors for resources specified in the
structure.</p>
</div>
<div class="paragraph">
<p>Each element in the <code>pDescriptorCopies</code> array is a
<a href="#VkCopyDescriptorSet">VkCopyDescriptorSet</a> structure describing an operation copying
descriptors between sets.</p>
</div>
<div class="paragraph">
<p>If the <code>dstSet</code> member of any element of <code>pDescriptorWrites</code> or
<code>pDescriptorCopies</code> is bound, accessed, or modified by any command that
was recorded to a command buffer which is currently in the
<a href="chap7.html#commandbuffers-lifecycle">recording or executable state</a>,
and any of the descriptor bindings that are updated were not created with
the <code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code> or
<code>VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT</code> bits set,
that command buffer becomes <a href="chap7.html#commandbuffers-lifecycle">invalid</a>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkUpdateDescriptorSets-None-03047" href="#VUID-vkUpdateDescriptorSets-None-03047"></a> <span class="vuid">VUID-vkUpdateDescriptorSets-None-03047</span><br>

Descriptor bindings updated by this command which were created without
the <code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code> or
<code>VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT</code> bits set
<strong class="purple">must</strong> not be used by any command that was recorded to a command buffer
which is in the <a href="chap7.html#commandbuffers-lifecycle">pending state</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkUpdateDescriptorSets-device-parameter" href="#VUID-vkUpdateDescriptorSets-device-parameter"></a> <span class="vuid">VUID-vkUpdateDescriptorSets-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkUpdateDescriptorSets-pDescriptorWrites-parameter" href="#VUID-vkUpdateDescriptorSets-pDescriptorWrites-parameter"></a> <span class="vuid">VUID-vkUpdateDescriptorSets-pDescriptorWrites-parameter</span><br>
 If <code>descriptorWriteCount</code> is not <code>0</code>, <code>pDescriptorWrites</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorWriteCount</code> valid <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> structures</p>
</li>
<li>
<p><a id="VUID-vkUpdateDescriptorSets-pDescriptorCopies-parameter" href="#VUID-vkUpdateDescriptorSets-pDescriptorCopies-parameter"></a> <span class="vuid">VUID-vkUpdateDescriptorSets-pDescriptorCopies-parameter</span><br>
 If <code>descriptorCopyCount</code> is not <code>0</code>, <code>pDescriptorCopies</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorCopyCount</code> valid <a href="#VkCopyDescriptorSet">VkCopyDescriptorSet</a> structures</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>pDescriptorWrites</code>[].dstSet <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to <code>pDescriptorCopies</code>[].dstSet <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkWriteDescriptorSet</code> structure is defined as:</p>
</div>
<div id="VkWriteDescriptorSet" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkWriteDescriptorSet {
    VkStructureType                  sType;
    <span class="directive">const</span> <span class="directive">void</span>*                      pNext;
    VkDescriptorSet                  dstSet;
    uint32_t                         dstBinding;
    uint32_t                         dstArrayElement;
    uint32_t                         descriptorCount;
    VkDescriptorType                 descriptorType;
    <span class="directive">const</span> VkDescriptorImageInfo*     pImageInfo;
    <span class="directive">const</span> VkDescriptorBufferInfo*    pBufferInfo;
    <span class="directive">const</span> VkBufferView*              pTexelBufferView;
} VkWriteDescriptorSet;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>dstSet</code> is the destination descriptor set to update.</p>
</li>
<li>
<p><code>dstBinding</code> is the descriptor binding within that set.</p>
</li>
<li>
<p><code>dstArrayElement</code> is the starting element in that array.
If the descriptor binding identified by <code>dstSet</code> and
<code>dstBinding</code> has a descriptor type of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> then
<code>dstArrayElement</code> specifies the starting byte offset within the
binding.</p>
</li>
<li>
<p><code>descriptorCount</code> is the number of descriptors to update (the number
of elements in <code>pImageInfo</code>, <code>pBufferInfo</code>, or
<code>pTexelBufferView</code>
, or a value matching the <code>dataSize</code> member of a
<a href="#VkWriteDescriptorSetInlineUniformBlockEXT">VkWriteDescriptorSetInlineUniformBlockEXT</a> structure in the
<code>pNext</code> chain
, or a value matching the <code>accelerationStructureCount</code> of a
<a href="#VkWriteDescriptorSetAccelerationStructureKHR">VkWriteDescriptorSetAccelerationStructureKHR</a> structure in the
<code>pNext</code> chain
).
If the descriptor binding identified by <code>dstSet</code> and
<code>dstBinding</code> has a descriptor type of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> then
<code>descriptorCount</code> specifies the number of bytes to update.</p>
</li>
<li>
<p><code>descriptorType</code> is a <a href="#VkDescriptorType">VkDescriptorType</a> specifying the type of
each descriptor in <code>pImageInfo</code>, <code>pBufferInfo</code>, or
<code>pTexelBufferView</code>, as described below.
If <code>VkDescriptorSetLayoutBinding</code> for <code>dstSet</code> at
<code>dstBinding</code> is not equal to <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>,
<code>descriptorType</code> <strong class="purple">must</strong>
be the same type as that specified in <code>VkDescriptorSetLayoutBinding</code>
for <code>dstSet</code> at <code>dstBinding</code>.
The type of the descriptor also controls which array the descriptors are
taken from.</p>
</li>
<li>
<p><code>pImageInfo</code> is a pointer to an array of <a href="#VkDescriptorImageInfo">VkDescriptorImageInfo</a>
structures or is ignored, as described below.</p>
</li>
<li>
<p><code>pBufferInfo</code> is a pointer to an array of
<a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a> structures or is ignored, as described
below.</p>
</li>
<li>
<p><code>pTexelBufferView</code> is a pointer to an array of <a href="chap13.html#VkBufferView">VkBufferView</a>
handles as described in the <a href="chap13.html#resources-buffer-views">Buffer Views</a>
section or is ignored, as described below.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Only one of <code>pImageInfo</code>, <code>pBufferInfo</code>, or <code>pTexelBufferView</code>
members is used according to the descriptor type specified in the
<code>descriptorType</code> member of the containing <code>VkWriteDescriptorSet</code>
structure,
or none of them in case <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>, in which case the source
data for the descriptor writes is taken from the
<a href="#VkWriteDescriptorSetInlineUniformBlockEXT">VkWriteDescriptorSetInlineUniformBlockEXT</a> structure included in the
<code>pNext</code> chain of <code>VkWriteDescriptorSet</code>,
or if <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code>, in which case the
source data for the descriptor writes is taken from the
<a href="#VkWriteDescriptorSetAccelerationStructureKHR">VkWriteDescriptorSetAccelerationStructureKHR</a> structure in the
<code>pNext</code> chain of <code>VkWriteDescriptorSet</code>,
or if <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV</code>, in which case the source
data for the descriptor writes is taken from the
<a href="#VkWriteDescriptorSetAccelerationStructureNV">VkWriteDescriptorSetAccelerationStructureNV</a> structure in the
<code>pNext</code> chain of <code>VkWriteDescriptorSet</code>,
as specified below.</p>
</div>
<div class="paragraph">
<p>If the <a href="chap41.html#features-nullDescriptor">nullDescriptor</a> feature is enabled, the
buffer,
acceleration structure,
imageView, or bufferView <strong class="purple">can</strong> be <a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>.
Loads from a null descriptor return zero values and stores and atomics to a
null descriptor are discarded.
A null acceleration structure descriptor results in the miss shader being
invoked.</p>
</div>
<div class="paragraph">
<p>If the destination descriptor is a mutable descriptor, the active descriptor
type for the destination descriptor becomes <code>descriptorType</code>.</p>
</div>
<div id="descriptorsets-updates-consecutive" class="paragraph">
<p>If the <code>dstBinding</code> has fewer than <code>descriptorCount</code> array elements
remaining starting from <code>dstArrayElement</code>, then the remainder will be
used to update the subsequent binding - <span class="eq"><code>dstBinding</code>+1</span> starting at
array element zero.
If a binding has a <code>descriptorCount</code> of zero, it is skipped.
This behavior applies recursively, with the update affecting consecutive
bindings as needed to update all <code>descriptorCount</code> descriptors.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>The same behavior applies to bindings with a descriptor type of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> where
<code>descriptorCount</code> specifies the number of bytes to update while
<code>dstArrayElement</code> specifies the starting byte offset, thus in this case
if the <code>dstBinding</code> has a smaller byte size than the sum of
<code>dstArrayElement</code> and <code>descriptorCount</code>, then the remainder will be
used to update the subsequent binding - <span class="eq"><code>dstBinding</code>+1</span> starting at
offset zero.
This falls out as a special case of the above rule.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWriteDescriptorSet-dstBinding-00315" href="#VUID-VkWriteDescriptorSet-dstBinding-00315"></a> <span class="vuid">VUID-VkWriteDescriptorSet-dstBinding-00315</span><br>

<code>dstBinding</code> <strong class="purple">must</strong> be less than or equal to the maximum value of
<code>binding</code> of all <a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a> structures
specified when <code>dstSet</code>’s descriptor set layout was created</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-dstBinding-00316" href="#VUID-VkWriteDescriptorSet-dstBinding-00316"></a> <span class="vuid">VUID-VkWriteDescriptorSet-dstBinding-00316</span><br>

<code>dstBinding</code> <strong class="purple">must</strong> be a binding with a non-zero
<code>descriptorCount</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorCount-00317" href="#VUID-VkWriteDescriptorSet-descriptorCount-00317"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorCount-00317</span><br>

All consecutive bindings updated via a single <code>VkWriteDescriptorSet</code>
structure, except those with a <code>descriptorCount</code> of zero, <strong class="purple">must</strong> have
identical <code>descriptorType</code> and <code>stageFlags</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorCount-00318" href="#VUID-VkWriteDescriptorSet-descriptorCount-00318"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorCount-00318</span><br>

All consecutive bindings updated via a single <code>VkWriteDescriptorSet</code>
structure, except those with a <code>descriptorCount</code> of zero, <strong class="purple">must</strong> all
either use immutable samplers or <strong class="purple">must</strong> all not use immutable samplers</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00319" href="#VUID-VkWriteDescriptorSet-descriptorType-00319"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00319</span><br>

<code>descriptorType</code> <strong class="purple">must</strong> match the type of <code>dstBinding</code> within
<code>dstSet</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-dstSet-00320" href="#VUID-VkWriteDescriptorSet-dstSet-00320"></a> <span class="vuid">VUID-VkWriteDescriptorSet-dstSet-00320</span><br>

<code>dstSet</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorSet">VkDescriptorSet</a> handle</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-dstArrayElement-00321" href="#VUID-VkWriteDescriptorSet-dstArrayElement-00321"></a> <span class="vuid">VUID-VkWriteDescriptorSet-dstArrayElement-00321</span><br>

The sum of <code>dstArrayElement</code> and <code>descriptorCount</code> <strong class="purple">must</strong> be less
than or equal to the number of array elements in the descriptor set
binding specified by <code>dstBinding</code>, and all applicable consecutive
bindings, as described by <a href="#descriptorsets-updates-consecutive">consecutive binding updates</a></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-02219" href="#VUID-VkWriteDescriptorSet-descriptorType-02219"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-02219</span><br>

If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>, <code>dstArrayElement</code>
<strong class="purple">must</strong> be an integer multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-02220" href="#VUID-VkWriteDescriptorSet-descriptorType-02220"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-02220</span><br>

If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>, <code>descriptorCount</code>
<strong class="purple">must</strong> be an integer multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00322" href="#VUID-VkWriteDescriptorSet-descriptorType-00322"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00322</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>,
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, or
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>, <code>pImageInfo</code> <strong class="purple">must</strong> be a
valid pointer to an array of <code>descriptorCount</code> valid
<code>VkDescriptorImageInfo</code> structures</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-02994" href="#VUID-VkWriteDescriptorSet-descriptorType-02994"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-02994</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>
or <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>, each element of
<code>pTexelBufferView</code> <strong class="purple">must</strong> be either a valid <code>VkBufferView</code> handle
or <a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-02995" href="#VUID-VkWriteDescriptorSet-descriptorType-02995"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-02995</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>
or <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> and the
<a href="chap41.html#features-nullDescriptor">nullDescriptor</a> feature is not enabled, each
element of <code>pTexelBufferView</code> <strong class="purple">must</strong> not be <a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00324" href="#VUID-VkWriteDescriptorSet-descriptorType-00324"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00324</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>,
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, <code>pBufferInfo</code> <strong class="purple">must</strong>
be a valid pointer to an array of <code>descriptorCount</code> valid
<code>VkDescriptorBufferInfo</code> structures</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00325" href="#VUID-VkWriteDescriptorSet-descriptorType-00325"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00325</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> or
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and <code>dstSet</code> was
not allocated with a layout that included immutable samplers for
<code>dstBinding</code> with <code>descriptorType</code>, the <code>sampler</code> member of
each element of <code>pImageInfo</code> <strong class="purple">must</strong> be a valid <code>VkSampler</code> object</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-02996" href="#VUID-VkWriteDescriptorSet-descriptorType-02996"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-02996</span><br>

If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, or
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>, the <code>imageView</code> member of
each element of <code>pImageInfo</code> <strong class="purple">must</strong> be either a valid
<code>VkImageView</code> handle or <a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-02997" href="#VUID-VkWriteDescriptorSet-descriptorType-02997"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-02997</span><br>

If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, or
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> and the
<a href="chap41.html#features-nullDescriptor">nullDescriptor</a> feature is not enabled, the
<code>imageView</code> member of each element of <code>pImageInfo</code> <strong class="purple">must</strong> not be
<a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-02221" href="#VUID-VkWriteDescriptorSet-descriptorType-02221"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-02221</span><br>

If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>, the <code>pNext</code> chain
<strong class="purple">must</strong> include a <a href="#VkWriteDescriptorSetInlineUniformBlockEXT">VkWriteDescriptorSetInlineUniformBlockEXT</a>
structure whose <code>dataSize</code> member equals <code>descriptorCount</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-02382" href="#VUID-VkWriteDescriptorSet-descriptorType-02382"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-02382</span><br>

If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code>, the <code>pNext</code>
chain <strong class="purple">must</strong> include a <a href="#VkWriteDescriptorSetAccelerationStructureKHR">VkWriteDescriptorSetAccelerationStructureKHR</a>
structure whose <code>accelerationStructureCount</code> member equals
<code>descriptorCount</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-03817" href="#VUID-VkWriteDescriptorSet-descriptorType-03817"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-03817</span><br>

If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV</code>, the <code>pNext</code>
chain <strong class="purple">must</strong> include a <a href="#VkWriteDescriptorSetAccelerationStructureNV">VkWriteDescriptorSetAccelerationStructureNV</a>
structure whose <code>accelerationStructureCount</code> member equals
<code>descriptorCount</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-01946" href="#VUID-VkWriteDescriptorSet-descriptorType-01946"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-01946</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, then
the <code>imageView</code> member of each <code>pImageInfo</code> element <strong class="purple">must</strong> have
been created without a <code>VkSamplerYcbcrConversionInfo</code> structure in
its <code>pNext</code> chain</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-02738" href="#VUID-VkWriteDescriptorSet-descriptorType-02738"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-02738</span><br>

If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and if any element of
<code>pImageInfo</code> has a <code>imageView</code> member that was created with a
<code>VkSamplerYcbcrConversionInfo</code> structure in its <code>pNext</code> chain,
then <code>dstSet</code> <strong class="purple">must</strong> have been allocated with a layout that included
immutable samplers for <code>dstBinding</code>, and the corresponding immutable
sampler <strong class="purple">must</strong> have been created with an <em>identically defined</em>
<code>VkSamplerYcbcrConversionInfo</code> object</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-01948" href="#VUID-VkWriteDescriptorSet-descriptorType-01948"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-01948</span><br>

If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and <code>dstSet</code> was
allocated with a layout that included immutable samplers for
<code>dstBinding</code>, then the <code>imageView</code> member of each element of
<code>pImageInfo</code> which corresponds to an immutable sampler that enables
<a href="chap14.html#samplers-YCbCr-conversion">sampler Y′C<sub>B</sub>C<sub>R</sub> conversion</a> <strong class="purple">must</strong> have been
created with a <code>VkSamplerYcbcrConversionInfo</code> structure in its
<code>pNext</code> chain with an <em>identically defined</em>
<code>VkSamplerYcbcrConversionInfo</code> to the corresponding immutable
sampler</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00327" href="#VUID-VkWriteDescriptorSet-descriptorType-00327"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00327</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, the <code>offset</code> member
of each element of <code>pBufferInfo</code> <strong class="purple">must</strong> be a multiple of
<code>VkPhysicalDeviceLimits</code>::<code>minUniformBufferOffsetAlignment</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00328" href="#VUID-VkWriteDescriptorSet-descriptorType-00328"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00328</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, the <code>offset</code> member
of each element of <code>pBufferInfo</code> <strong class="purple">must</strong> be a multiple of
<code>VkPhysicalDeviceLimits</code>::<code>minStorageBufferOffsetAlignment</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00329" href="#VUID-VkWriteDescriptorSet-descriptorType-00329"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00329</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>,
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>, or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, and the <code>buffer</code>
member of any element of <code>pBufferInfo</code> is the handle of a non-sparse
buffer, then that buffer <strong class="purple">must</strong> be bound completely and contiguously to a
single <code>VkDeviceMemory</code> object</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00330" href="#VUID-VkWriteDescriptorSet-descriptorType-00330"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00330</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, the <code>buffer</code> member
of each element of <code>pBufferInfo</code> <strong class="purple">must</strong> have been created with
<code>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</code> set</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00331" href="#VUID-VkWriteDescriptorSet-descriptorType-00331"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00331</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, the <code>buffer</code> member
of each element of <code>pBufferInfo</code> <strong class="purple">must</strong> have been created with
<code>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</code> set</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00332" href="#VUID-VkWriteDescriptorSet-descriptorType-00332"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00332</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, the <code>range</code> member
of each element of <code>pBufferInfo</code>, or the effective range if
<code>range</code> is <code>VK_WHOLE_SIZE</code>, <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxUniformBufferRange</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00333" href="#VUID-VkWriteDescriptorSet-descriptorType-00333"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00333</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, the <code>range</code> member
of each element of <code>pBufferInfo</code>, or the effective range if
<code>range</code> is <code>VK_WHOLE_SIZE</code>, <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxStorageBufferRange</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00334" href="#VUID-VkWriteDescriptorSet-descriptorType-00334"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00334</span><br>

If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>, the <code>VkBuffer</code> that
each element of <code>pTexelBufferView</code> was created from <strong class="purple">must</strong> have been
created with <code>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</code> set</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00335" href="#VUID-VkWriteDescriptorSet-descriptorType-00335"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00335</span><br>

If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>, the <code>VkBuffer</code> that
each element of <code>pTexelBufferView</code> was created from <strong class="purple">must</strong> have been
created with <code>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</code> set</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00336" href="#VUID-VkWriteDescriptorSet-descriptorType-00336"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00336</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code> or
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>, the <code>imageView</code> member of
each element of <code>pImageInfo</code> <strong class="purple">must</strong> have been created with the
identity swizzle</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00337" href="#VUID-VkWriteDescriptorSet-descriptorType-00337"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00337</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code> or
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, the <code>imageView</code>
member of each element of <code>pImageInfo</code> <strong class="purple">must</strong> have been created with
<code>VK_IMAGE_USAGE_SAMPLED_BIT</code> set</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-04149" href="#VUID-VkWriteDescriptorSet-descriptorType-04149"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-04149</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code> the
<code>imageLayout</code> member of each element of <code>pImageInfo</code> <strong class="purple">must</strong> be a
member of the list given in <a href="#descriptorsets-sampledimage">Sampled
Image</a></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-04150" href="#VUID-VkWriteDescriptorSet-descriptorType-04150"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-04150</span><br>

If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> the <code>imageLayout</code>
member of each element of <code>pImageInfo</code> <strong class="purple">must</strong> be a member of the list
given in <a href="#descriptorsets-combinedimagesampler">Combined Image Sampler</a></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-04151" href="#VUID-VkWriteDescriptorSet-descriptorType-04151"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-04151</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> the
<code>imageLayout</code> member of each element of <code>pImageInfo</code> <strong class="purple">must</strong> be a
member of the list given in <a href="#descriptorsets-inputattachment">Input
Attachment</a></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-04152" href="#VUID-VkWriteDescriptorSet-descriptorType-04152"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-04152</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code> the
<code>imageLayout</code> member of each element of <code>pImageInfo</code> <strong class="purple">must</strong> be a
member of the list given in <a href="#descriptorsets-storageimage">Storage
Image</a></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00338" href="#VUID-VkWriteDescriptorSet-descriptorType-00338"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00338</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>,
the <code>imageView</code> member of each element of <code>pImageInfo</code> <strong class="purple">must</strong>
have been created with <code>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</code> set</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00339" href="#VUID-VkWriteDescriptorSet-descriptorType-00339"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-00339</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, the
<code>imageView</code> member of each element of <code>pImageInfo</code> <strong class="purple">must</strong> have
been created with <code>VK_IMAGE_USAGE_STORAGE_BIT</code> set</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorCount-03048" href="#VUID-VkWriteDescriptorSet-descriptorCount-03048"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorCount-03048</span><br>

All consecutive bindings updated via a single <code>VkWriteDescriptorSet</code>
structure, except those with a <code>descriptorCount</code> of zero, <strong class="purple">must</strong> have
identical <a href="#VkDescriptorBindingFlagBits">VkDescriptorBindingFlagBits</a></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-02752" href="#VUID-VkWriteDescriptorSet-descriptorType-02752"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-02752</span><br>

If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>, then
<code>dstSet</code> <strong class="purple">must</strong> not have been allocated with a layout that included
immutable samplers for <code>dstBinding</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-dstSet-04611" href="#VUID-VkWriteDescriptorSet-dstSet-04611"></a> <span class="vuid">VUID-VkWriteDescriptorSet-dstSet-04611</span><br>

If the <code>VkDescriptorSetLayoutBinding</code> for <code>dstSet</code> at
<code>dstBinding</code> is <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>, the new
active descriptor type <code>descriptorType</code> <strong class="purple">must</strong> exist in the
corresponding <code>pMutableDescriptorTypeLists</code> list for
<code>dstBinding</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWriteDescriptorSet-sType-sType" href="#VUID-VkWriteDescriptorSet-sType-sType"></a> <span class="vuid">VUID-VkWriteDescriptorSet-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-pNext-pNext" href="#VUID-VkWriteDescriptorSet-pNext-pNext"></a> <span class="vuid">VUID-VkWriteDescriptorSet-pNext-pNext</span><br>
 Each <code>pNext</code> member of any structure (including this one) in the <code>pNext</code> chain <strong class="purple">must</strong> be either <code>NULL</code> or a pointer to a valid instance of <a href="#VkWriteDescriptorSetAccelerationStructureKHR">VkWriteDescriptorSetAccelerationStructureKHR</a>, <a href="#VkWriteDescriptorSetAccelerationStructureNV">VkWriteDescriptorSetAccelerationStructureNV</a>, or <a href="#VkWriteDescriptorSetInlineUniformBlockEXT">VkWriteDescriptorSetInlineUniformBlockEXT</a></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-sType-unique" href="#VUID-VkWriteDescriptorSet-sType-unique"></a> <span class="vuid">VUID-VkWriteDescriptorSet-sType-unique</span><br>
 The <code>sType</code> value of each struct in the <code>pNext</code> chain <strong class="purple">must</strong> be unique</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-parameter" href="#VUID-VkWriteDescriptorSet-descriptorType-parameter"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorType-parameter</span><br>
 <code>descriptorType</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorType">VkDescriptorType</a> value</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorCount-arraylength" href="#VUID-VkWriteDescriptorSet-descriptorCount-arraylength"></a> <span class="vuid">VUID-VkWriteDescriptorSet-descriptorCount-arraylength</span><br>
 <code>descriptorCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-commonparent" href="#VUID-VkWriteDescriptorSet-commonparent"></a> <span class="vuid">VUID-VkWriteDescriptorSet-commonparent</span><br>
 Both of <code>dstSet</code>, and the elements of <code>pTexelBufferView</code> that are valid handles of non-ignored parameters <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap6.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The type of descriptors in a descriptor set is specified by
<a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>descriptorType</code>, which <strong class="purple">must</strong> be one of the
values:</p>
</div>
<div id="VkDescriptorType" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> <span class="keyword">enum</span> VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = <span class="integer">0</span>,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = <span class="integer">1</span>,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = <span class="integer">2</span>,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = <span class="integer">3</span>,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = <span class="integer">4</span>,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = <span class="integer">5</span>,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = <span class="integer">6</span>,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = <span class="integer">7</span>,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = <span class="integer">8</span>,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = <span class="integer">9</span>,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = <span class="integer">10</span>,
  <span class="comment">// Provided by VK_EXT_inline_uniform_block</span>
    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = <span class="integer">1000138000</span>,
  <span class="comment">// Provided by VK_KHR_acceleration_structure</span>
    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = <span class="integer">1000150000</span>,
  <span class="comment">// Provided by VK_NV_ray_tracing</span>
    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = <span class="integer">1000165000</span>,
  <span class="comment">// Provided by VK_VALVE_mutable_descriptor_type</span>
    VK_DESCRIPTOR_TYPE_MUTABLE_VALVE = <span class="integer">1000351000</span>,
} VkDescriptorType;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_DESCRIPTOR_TYPE_SAMPLER</code> specifies a <a href="#descriptorsets-sampler">sampler descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> specifies a
<a href="#descriptorsets-combinedimagesampler">combined image sampler
descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code> specifies a
<a href="#descriptorsets-sampledimage">sampled image descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code> specifies a
<a href="#descriptorsets-storageimage">storage image descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> specifies a
<a href="#descriptorsets-uniformtexelbuffer">uniform texel buffer descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> specifies a
<a href="#descriptorsets-storagetexelbuffer">storage texel buffer descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> specifies a
<a href="#descriptorsets-uniformbuffer">uniform buffer descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> specifies a
<a href="#descriptorsets-storagebuffer">storage buffer descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> specifies a
<a href="#descriptorsets-uniformbufferdynamic">dynamic uniform buffer
descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> specifies a
<a href="#descriptorsets-storagebufferdynamic">dynamic storage buffer
descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> specifies an
<a href="#descriptorsets-inputattachment">input attachment descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> specifies an
<a href="#descriptorsets-inlineuniformblock">inline uniform block</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code> specifies a
<a href="#descriptorsets-mutable">descriptor of mutable type</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a descriptor set is updated via elements of <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>,
members of <code>pImageInfo</code>, <code>pBufferInfo</code> and <code>pTexelBufferView</code>
are only accessed by the implementation when they correspond to descriptor
type being defined - otherwise they are ignored.
The members accessed are as follows for each descriptor type:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>, only the <code>sampler</code> member of
each element of <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>pImageInfo</code> is
accessed.</p>
</li>
<li>
<p>For <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, or
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>, only the <code>imageView</code> and
<code>imageLayout</code> members of each element of
<a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>pImageInfo</code> are accessed.</p>
</li>
<li>
<p>For <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, all members of each
element of <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>pImageInfo</code> are accessed.</p>
</li>
<li>
<p>For <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>,
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, all members of each
element of <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>pBufferInfo</code> are accessed.</p>
</li>
<li>
<p>For <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> or
<code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>, each element of
<a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>pTexelBufferView</code> is accessed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When updating descriptors with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>, none of the
<code>pImageInfo</code>, <code>pBufferInfo</code>, or <code>pTexelBufferView</code> members are
accessed, instead the source data of the descriptor update operation is
taken from the <a href="#VkWriteDescriptorSetInlineUniformBlockEXT">VkWriteDescriptorSetInlineUniformBlockEXT</a> structure in
the <code>pNext</code> chain of <code>VkWriteDescriptorSet</code>.
When updating descriptors with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code>, none of the
<code>pImageInfo</code>, <code>pBufferInfo</code>, or <code>pTexelBufferView</code> members are
accessed, instead the source data of the descriptor update operation is
taken from the <a href="#VkWriteDescriptorSetAccelerationStructureKHR">VkWriteDescriptorSetAccelerationStructureKHR</a> structure
in the <code>pNext</code> chain of <code>VkWriteDescriptorSet</code>.
When updating descriptors with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV</code>, none of the
<code>pImageInfo</code>, <code>pBufferInfo</code>, or <code>pTexelBufferView</code> members are
accessed, instead the source data of the descriptor update operation is
taken from the <a href="#VkWriteDescriptorSetAccelerationStructureNV">VkWriteDescriptorSetAccelerationStructureNV</a> structure
in the <code>pNext</code> chain of <code>VkWriteDescriptorSet</code>.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDescriptorBufferInfo</code> structure is defined as:</p>
</div>
<div id="VkDescriptorBufferInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorBufferInfo {
    VkBuffer        buffer;
    VkDeviceSize    offset;
    VkDeviceSize    range;
} VkDescriptorBufferInfo;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>buffer</code> is
<a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> or
the buffer resource.</p>
</li>
<li>
<p><code>offset</code> is the offset in bytes from the start of <code>buffer</code>.
Access to buffer memory via this descriptor uses addressing that is
relative to this starting offset.</p>
</li>
<li>
<p><code>range</code> is the size in bytes that is used for this descriptor
update, or <code>VK_WHOLE_SIZE</code> to use the range from <code>offset</code> to the
end of the buffer.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>When setting <code>range</code> to <code>VK_WHOLE_SIZE</code>, the effective range <strong class="purple">must</strong>
not be larger than the maximum range for the descriptor type
(<a href="chap42.html#limits-maxUniformBufferRange"><code>maxUniformBufferRange</code></a> or
<a href="chap42.html#limits-maxStorageBufferRange"><code>maxStorageBufferRange</code></a>).
This means that <code>VK_WHOLE_SIZE</code> is not typically useful in the common
case where uniform buffer descriptors are suballocated from a buffer that is
much larger than <code>maxUniformBufferRange</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> and
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> descriptor types,
<code>offset</code> is the base offset from which the dynamic offset is applied and
<code>range</code> is the static size used for all dynamic offsets.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorBufferInfo-offset-00340" href="#VUID-VkDescriptorBufferInfo-offset-00340"></a> <span class="vuid">VUID-VkDescriptorBufferInfo-offset-00340</span><br>

<code>offset</code> <strong class="purple">must</strong> be less than the size of <code>buffer</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorBufferInfo-range-00341" href="#VUID-VkDescriptorBufferInfo-range-00341"></a> <span class="vuid">VUID-VkDescriptorBufferInfo-range-00341</span><br>

If <code>range</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>range</code> <strong class="purple">must</strong> be
greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorBufferInfo-range-00342" href="#VUID-VkDescriptorBufferInfo-range-00342"></a> <span class="vuid">VUID-VkDescriptorBufferInfo-range-00342</span><br>

If <code>range</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>range</code> <strong class="purple">must</strong> be
less than or equal to the size of <code>buffer</code> minus <code>offset</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorBufferInfo-buffer-02998" href="#VUID-VkDescriptorBufferInfo-buffer-02998"></a> <span class="vuid">VUID-VkDescriptorBufferInfo-buffer-02998</span><br>

If the <a href="chap41.html#features-nullDescriptor">nullDescriptor</a> feature is not
enabled, <code>buffer</code> <strong class="purple">must</strong> not be <a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a></p>
</li>
<li>
<p><a id="VUID-VkDescriptorBufferInfo-buffer-02999" href="#VUID-VkDescriptorBufferInfo-buffer-02999"></a> <span class="vuid">VUID-VkDescriptorBufferInfo-buffer-02999</span><br>

If <code>buffer</code> is <a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>offset</code> <strong class="purple">must</strong> be zero and
<code>range</code> <strong class="purple">must</strong> be <code>VK_WHOLE_SIZE</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorBufferInfo-buffer-parameter" href="#VUID-VkDescriptorBufferInfo-buffer-parameter"></a> <span class="vuid">VUID-VkDescriptorBufferInfo-buffer-parameter</span><br>
 If <code>buffer</code> is not <a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>buffer</code> <strong class="purple">must</strong> be a valid <a href="chap13.html#VkBuffer">VkBuffer</a> handle</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDescriptorImageInfo</code> structure is defined as:</p>
</div>
<div id="VkDescriptorImageInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorImageInfo {
    VkSampler        sampler;
    VkImageView      imageView;
    VkImageLayout    imageLayout;
} VkDescriptorImageInfo;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sampler</code> is a sampler handle, and is used in descriptor updates for
types <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> and
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> if the binding being
updated does not use immutable samplers.</p>
</li>
<li>
<p><code>imageView</code> is
<a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> or
an image view handle, and is used in descriptor updates for types
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>.</p>
</li>
<li>
<p><code>imageLayout</code> is the layout that the image subresources accessible
from <code>imageView</code> will be in at the time this descriptor is accessed.
<code>imageLayout</code> is used in descriptor updates for types
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Members of <code>VkDescriptorImageInfo</code> that are not used in an update (as
described above) are ignored.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorImageInfo-imageView-00343" href="#VUID-VkDescriptorImageInfo-imageView-00343"></a> <span class="vuid">VUID-VkDescriptorImageInfo-imageView-00343</span><br>

<code>imageView</code> <strong class="purple">must</strong> not be 2D or 2D array image view created from a 3D
image</p>
</li>
<li>
<p><a id="VUID-VkDescriptorImageInfo-imageView-01976" href="#VUID-VkDescriptorImageInfo-imageView-01976"></a> <span class="vuid">VUID-VkDescriptorImageInfo-imageView-01976</span><br>

If <code>imageView</code> is created from a depth/stencil image, the
<code>aspectMask</code> used to create the <code>imageView</code> <strong class="purple">must</strong> include either
<code>VK_IMAGE_ASPECT_DEPTH_BIT</code> or <code>VK_IMAGE_ASPECT_STENCIL_BIT</code> but
not both</p>
</li>
<li>
<p><a id="VUID-VkDescriptorImageInfo-imageLayout-00344" href="#VUID-VkDescriptorImageInfo-imageLayout-00344"></a> <span class="vuid">VUID-VkDescriptorImageInfo-imageLayout-00344</span><br>

<code>imageLayout</code> <strong class="purple">must</strong> match the actual <a href="chap13.html#VkImageLayout">VkImageLayout</a> of each
subresource accessible from <code>imageView</code> at the time this descriptor
is accessed as defined by the <a href="chap13.html#resources-image-layouts-matching-rule">image layout matching rules</a></p>
</li>
<li>
<p><a id="VUID-VkDescriptorImageInfo-sampler-01564" href="#VUID-VkDescriptorImageInfo-sampler-01564"></a> <span class="vuid">VUID-VkDescriptorImageInfo-sampler-01564</span><br>

If <code>sampler</code> is used and the <a href="chap43.html#VkFormat">VkFormat</a> of the image is a
<a href="chap43.html#formats-requiring-sampler-ycbcr-conversion">multi-planar format</a>, the
image <strong class="purple">must</strong> have been created with
<code>VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT</code>, and the <code>aspectMask</code> of
the <code>imageView</code> <strong class="purple">must</strong> be <code>VK_IMAGE_ASPECT_PLANE_0_BIT</code>,
<code>VK_IMAGE_ASPECT_PLANE_1_BIT</code> or (for three-plane formats only)
<code>VK_IMAGE_ASPECT_PLANE_2_BIT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorImageInfo-mutableComparisonSamplers-04450" href="#VUID-VkDescriptorImageInfo-mutableComparisonSamplers-04450"></a> <span class="vuid">VUID-VkDescriptorImageInfo-mutableComparisonSamplers-04450</span><br>

If the <code><a href="chap50.html#VK_KHR_portability_subset">VK_KHR_portability_subset</a></code> extension is enabled, and
<a href="chap41.html#VkPhysicalDevicePortabilitySubsetFeaturesKHR">VkPhysicalDevicePortabilitySubsetFeaturesKHR</a>::<code>mutableComparisonSamplers</code>
is <code>VK_FALSE</code>, then <code>sampler</code> <strong class="purple">must</strong> have been created with
<a href="chap14.html#VkSamplerCreateInfo">VkSamplerCreateInfo</a>::<code>compareEnable</code> set to <code>VK_FALSE</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorImageInfo-commonparent" href="#VUID-VkDescriptorImageInfo-commonparent"></a> <span class="vuid">VUID-VkDescriptorImageInfo-commonparent</span><br>
 Both of <code>imageView</code>, and <code>sampler</code> that are valid handles of non-ignored parameters <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap6.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>If the <code>descriptorType</code> member of <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> is
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> then the data to write to
the descriptor set is specified through a
<code>VkWriteDescriptorSetInlineUniformBlockEXT</code> structure included in the
<code>pNext</code> chain of <code>VkWriteDescriptorSet</code>.</p>
</div>
<div class="paragraph">
<p>The <code>VkWriteDescriptorSetInlineUniformBlockEXT</code> structure is defined as:</p>
</div>
<div id="VkWriteDescriptorSetInlineUniformBlockEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_EXT_inline_uniform_block</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkWriteDescriptorSetInlineUniformBlockEXT {
    VkStructureType    sType;
    <span class="directive">const</span> <span class="directive">void</span>*        pNext;
    uint32_t           dataSize;
    <span class="directive">const</span> <span class="directive">void</span>*        pData;
} VkWriteDescriptorSetInlineUniformBlockEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>dataSize</code> is the number of bytes of inline uniform block data
pointed to by <code>pData</code>.</p>
</li>
<li>
<p><code>pData</code> is a pointer to <code>dataSize</code> number of bytes of data to
write to the inline uniform block.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWriteDescriptorSetInlineUniformBlockEXT-dataSize-02222" href="#VUID-VkWriteDescriptorSetInlineUniformBlockEXT-dataSize-02222"></a> <span class="vuid">VUID-VkWriteDescriptorSetInlineUniformBlockEXT-dataSize-02222</span><br>

<code>dataSize</code> <strong class="purple">must</strong> be an integer multiple of <code>4</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWriteDescriptorSetInlineUniformBlockEXT-sType-sType" href="#VUID-VkWriteDescriptorSetInlineUniformBlockEXT-sType-sType"></a> <span class="vuid">VUID-VkWriteDescriptorSetInlineUniformBlockEXT-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSetInlineUniformBlockEXT-pData-parameter" href="#VUID-VkWriteDescriptorSetInlineUniformBlockEXT-pData-parameter"></a> <span class="vuid">VUID-VkWriteDescriptorSetInlineUniformBlockEXT-pData-parameter</span><br>
 <code>pData</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>dataSize</code> bytes</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSetInlineUniformBlockEXT-dataSize-arraylength" href="#VUID-VkWriteDescriptorSetInlineUniformBlockEXT-dataSize-arraylength"></a> <span class="vuid">VUID-VkWriteDescriptorSetInlineUniformBlockEXT-dataSize-arraylength</span><br>
 <code>dataSize</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkWriteDescriptorSetAccelerationStructureKHR</code> structure is defined
as:</p>
</div>
<div id="VkWriteDescriptorSetAccelerationStructureKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_acceleration_structure</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkWriteDescriptorSetAccelerationStructureKHR {
    VkStructureType                      sType;
    <span class="directive">const</span> <span class="directive">void</span>*                          pNext;
    uint32_t                             accelerationStructureCount;
    <span class="directive">const</span> VkAccelerationStructureKHR*    pAccelerationStructures;
} VkWriteDescriptorSetAccelerationStructureKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>accelerationStructureCount</code> is the number of elements in
<code>pAccelerationStructures</code>.</p>
</li>
<li>
<p><code>pAccelerationStructures</code> are the acceleration structures to update.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-02236" href="#VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-02236"></a> <span class="vuid">VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-02236</span><br>

<code>accelerationStructureCount</code> <strong class="purple">must</strong> be equal to <code>descriptorCount</code>
in the extended structure</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-03579" href="#VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-03579"></a> <span class="vuid">VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-03579</span><br>

Each acceleration structure in <code>pAccelerationStructures</code> <strong class="purple">must</strong> have
been created with a <code>type</code> of
<code>VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR</code> or
<code>VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-03580" href="#VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-03580"></a> <span class="vuid">VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-03580</span><br>

If the <a href="chap41.html#features-nullDescriptor">nullDescriptor</a> feature is not
enabled, each member of <code>pAccelerationStructures</code> <strong class="purple">must</strong> not be
<a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureKHR-sType-sType" href="#VUID-VkWriteDescriptorSetAccelerationStructureKHR-sType-sType"></a> <span class="vuid">VUID-VkWriteDescriptorSetAccelerationStructureKHR-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-parameter" href="#VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-parameter"></a> <span class="vuid">VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-parameter</span><br>
 <code>pAccelerationStructures</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>accelerationStructureCount</code> valid or <a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> <a href="chap13.html#VkAccelerationStructureKHR">VkAccelerationStructureKHR</a> handles</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-arraylength" href="#VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-arraylength"></a> <span class="vuid">VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-arraylength</span><br>
 <code>accelerationStructureCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkWriteDescriptorSetAccelerationStructureNV</code> structure is defined
as:</p>
</div>
<div id="VkWriteDescriptorSetAccelerationStructureNV" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_NV_ray_tracing</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkWriteDescriptorSetAccelerationStructureNV {
    VkStructureType                     sType;
    <span class="directive">const</span> <span class="directive">void</span>*                         pNext;
    uint32_t                            accelerationStructureCount;
    <span class="directive">const</span> VkAccelerationStructureNV*    pAccelerationStructures;
} VkWriteDescriptorSetAccelerationStructureNV;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>accelerationStructureCount</code> is the number of elements in
<code>pAccelerationStructures</code>.</p>
</li>
<li>
<p><code>pAccelerationStructures</code> are the acceleration structures to update.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-03747" href="#VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-03747"></a> <span class="vuid">VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-03747</span><br>

<code>accelerationStructureCount</code> <strong class="purple">must</strong> be equal to <code>descriptorCount</code>
in the extended structure</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-03748" href="#VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-03748"></a> <span class="vuid">VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-03748</span><br>

Each acceleration structure in <code>pAccelerationStructures</code> <strong class="purple">must</strong> have
been created with <code>VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-03749" href="#VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-03749"></a> <span class="vuid">VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-03749</span><br>

If the <a href="chap41.html#features-nullDescriptor">nullDescriptor</a> feature is not
enabled, each member of <code>pAccelerationStructures</code> <strong class="purple">must</strong> not be
<a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureNV-sType-sType" href="#VUID-VkWriteDescriptorSetAccelerationStructureNV-sType-sType"></a> <span class="vuid">VUID-VkWriteDescriptorSetAccelerationStructureNV-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-parameter" href="#VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-parameter"></a> <span class="vuid">VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-parameter</span><br>
 <code>pAccelerationStructures</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>accelerationStructureCount</code> valid or <a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> <a href="chap13.html#VkAccelerationStructureNV">VkAccelerationStructureNV</a> handles</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-arraylength" href="#VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-arraylength"></a> <span class="vuid">VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-arraylength</span><br>
 <code>accelerationStructureCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkCopyDescriptorSet</code> structure is defined as:</p>
</div>
<div id="VkCopyDescriptorSet" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkCopyDescriptorSet {
    VkStructureType    sType;
    <span class="directive">const</span> <span class="directive">void</span>*        pNext;
    VkDescriptorSet    srcSet;
    uint32_t           srcBinding;
    uint32_t           srcArrayElement;
    VkDescriptorSet    dstSet;
    uint32_t           dstBinding;
    uint32_t           dstArrayElement;
    uint32_t           descriptorCount;
} VkCopyDescriptorSet;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>srcSet</code>, <code>srcBinding</code>, and <code>srcArrayElement</code> are the source
set, binding, and array element, respectively.
If the descriptor binding identified by <code>srcSet</code> and
<code>srcBinding</code> has a descriptor type of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> then
<code>srcArrayElement</code> specifies the starting byte offset within the
binding to copy from.</p>
</li>
<li>
<p><code>dstSet</code>, <code>dstBinding</code>, and <code>dstArrayElement</code> are the
destination set, binding, and array element, respectively.
If the descriptor binding identified by <code>dstSet</code> and
<code>dstBinding</code> has a descriptor type of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> then
<code>dstArrayElement</code> specifies the starting byte offset within the
binding to copy to.</p>
</li>
<li>
<p><code>descriptorCount</code> is the number of descriptors to copy from the
source to destination.
If <code>descriptorCount</code> is greater than the number of remaining array
elements in the source or destination binding, those affect consecutive
bindings in a manner similar to <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> above.
If the descriptor binding identified by <code>srcSet</code> and
<code>srcBinding</code> has a descriptor type of
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code> then
<code>descriptorCount</code> specifies the number of bytes to copy and the
remaining array elements in the source or destination binding refer to
the remaining number of bytes in those.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the <code>VkDescriptorSetLayoutBinding</code> for <code>dstBinding</code> is
<code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code> and <code>srcBinding</code> is not
<code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>, the new active descriptor type
becomes the descriptor type of <code>srcBinding</code>.
If both <code>VkDescriptorSetLayoutBinding</code> for <code>srcBinding</code> and
<code>dstBinding</code> are <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>, the active
descriptor type in each source descriptor is copied into the corresponding
destination descriptor.
The active descriptor type <strong class="purple">can</strong> be different for each source descriptor.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>The intention is that copies to and from mutable descriptors is a simple
memcpy.
Copies between non-mutable and mutable descriptors are expected to require
one memcpy per descriptor to handle the difference in size, but this use
case with more than one <code>descriptorCount</code> is considered rare.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcBinding-00345" href="#VUID-VkCopyDescriptorSet-srcBinding-00345"></a> <span class="vuid">VUID-VkCopyDescriptorSet-srcBinding-00345</span><br>

<code>srcBinding</code> <strong class="purple">must</strong> be a valid binding within <code>srcSet</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcArrayElement-00346" href="#VUID-VkCopyDescriptorSet-srcArrayElement-00346"></a> <span class="vuid">VUID-VkCopyDescriptorSet-srcArrayElement-00346</span><br>

The sum of <code>srcArrayElement</code> and <code>descriptorCount</code> <strong class="purple">must</strong> be less
than or equal to the number of array elements in the descriptor set
binding specified by <code>srcBinding</code>, and all applicable consecutive
bindings, as described by <a href="#descriptorsets-updates-consecutive">consecutive binding updates</a></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-dstBinding-00347" href="#VUID-VkCopyDescriptorSet-dstBinding-00347"></a> <span class="vuid">VUID-VkCopyDescriptorSet-dstBinding-00347</span><br>

<code>dstBinding</code> <strong class="purple">must</strong> be a valid binding within <code>dstSet</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-dstArrayElement-00348" href="#VUID-VkCopyDescriptorSet-dstArrayElement-00348"></a> <span class="vuid">VUID-VkCopyDescriptorSet-dstArrayElement-00348</span><br>

The sum of <code>dstArrayElement</code> and <code>descriptorCount</code> <strong class="purple">must</strong> be less
than or equal to the number of array elements in the descriptor set
binding specified by <code>dstBinding</code>, and all applicable consecutive
bindings, as described by <a href="#descriptorsets-updates-consecutive">consecutive binding updates</a></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-dstBinding-02632" href="#VUID-VkCopyDescriptorSet-dstBinding-02632"></a> <span class="vuid">VUID-VkCopyDescriptorSet-dstBinding-02632</span><br>

The type of <code>dstBinding</code> within <code>dstSet</code> <strong class="purple">must</strong> be equal to the
type of <code>srcBinding</code> within <code>srcSet</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcSet-00349" href="#VUID-VkCopyDescriptorSet-srcSet-00349"></a> <span class="vuid">VUID-VkCopyDescriptorSet-srcSet-00349</span><br>

If <code>srcSet</code> is equal to <code>dstSet</code>, then the source and
destination ranges of descriptors <strong class="purple">must</strong> not overlap, where the ranges
<strong class="purple">may</strong> include array elements from consecutive bindings as described by
<a href="#descriptorsets-updates-consecutive">consecutive binding updates</a></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcBinding-02223" href="#VUID-VkCopyDescriptorSet-srcBinding-02223"></a> <span class="vuid">VUID-VkCopyDescriptorSet-srcBinding-02223</span><br>

If the descriptor type of the descriptor set binding specified by
<code>srcBinding</code> is <code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>,
<code>srcArrayElement</code> <strong class="purple">must</strong> be an integer multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-dstBinding-02224" href="#VUID-VkCopyDescriptorSet-dstBinding-02224"></a> <span class="vuid">VUID-VkCopyDescriptorSet-dstBinding-02224</span><br>

If the descriptor type of the descriptor set binding specified by
<code>dstBinding</code> is <code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>,
<code>dstArrayElement</code> <strong class="purple">must</strong> be an integer multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcBinding-02225" href="#VUID-VkCopyDescriptorSet-srcBinding-02225"></a> <span class="vuid">VUID-VkCopyDescriptorSet-srcBinding-02225</span><br>

If the descriptor type of the descriptor set binding specified by either
<code>srcBinding</code> or <code>dstBinding</code> is
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>, <code>descriptorCount</code>
<strong class="purple">must</strong> be an integer multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcSet-01918" href="#VUID-VkCopyDescriptorSet-srcSet-01918"></a> <span class="vuid">VUID-VkCopyDescriptorSet-srcSet-01918</span><br>

If <code>srcSet</code>’s layout was created with the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> flag
set, then <code>dstSet</code>’s layout <strong class="purple">must</strong> also have been created with the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> flag
set</p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcSet-01919" href="#VUID-VkCopyDescriptorSet-srcSet-01919"></a> <span class="vuid">VUID-VkCopyDescriptorSet-srcSet-01919</span><br>

If <code>srcSet</code>’s layout was created without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> flag
set, then <code>dstSet</code>’s layout <strong class="purple">must</strong> also have been created without the
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code> flag
set</p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcSet-01920" href="#VUID-VkCopyDescriptorSet-srcSet-01920"></a> <span class="vuid">VUID-VkCopyDescriptorSet-srcSet-01920</span><br>

If the descriptor pool from which <code>srcSet</code> was allocated was created
with the <code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT</code> flag set,
then the descriptor pool from which <code>dstSet</code> was allocated <strong class="purple">must</strong>
also have been created with the
<code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT</code> flag set</p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcSet-01921" href="#VUID-VkCopyDescriptorSet-srcSet-01921"></a> <span class="vuid">VUID-VkCopyDescriptorSet-srcSet-01921</span><br>

If the descriptor pool from which <code>srcSet</code> was allocated was created
without the <code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT</code> flag
set, then the descriptor pool from which <code>dstSet</code> was allocated
<strong class="purple">must</strong> also have been created without the
<code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT</code> flag set</p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-dstBinding-02753" href="#VUID-VkCopyDescriptorSet-dstBinding-02753"></a> <span class="vuid">VUID-VkCopyDescriptorSet-dstBinding-02753</span><br>

If the descriptor type of the descriptor set binding specified by
<code>dstBinding</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>, then <code>dstSet</code>
<strong class="purple">must</strong> not have been allocated with a layout that included immutable
samplers for <code>dstBinding</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-dstSet-04612" href="#VUID-VkCopyDescriptorSet-dstSet-04612"></a> <span class="vuid">VUID-VkCopyDescriptorSet-dstSet-04612</span><br>

If <code>VkDescriptorSetLayoutBinding</code> for <code>dstSet</code> at
<code>dstBinding</code> is <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>, the new
active descriptor type <strong class="purple">must</strong> exist in the corresponding
<code>pMutableDescriptorTypeLists</code> list for <code>dstBinding</code> if the new
active descriptor type is not <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcSet-04613" href="#VUID-VkCopyDescriptorSet-srcSet-04613"></a> <span class="vuid">VUID-VkCopyDescriptorSet-srcSet-04613</span><br>

If <code>VkDescriptorSetLayoutBinding</code> for <code>srcSet</code> at
<code>srcBinding</code> is <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code> and the
<code>VkDescriptorSetLayoutBinding</code> for <code>dstSet</code> at <code>dstBinding</code>
is not <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>, the active descriptor
type for the source descriptor <strong class="purple">must</strong> match the descriptor type of
<code>dstBinding</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-dstSet-04614" href="#VUID-VkCopyDescriptorSet-dstSet-04614"></a> <span class="vuid">VUID-VkCopyDescriptorSet-dstSet-04614</span><br>

If <code>VkDescriptorSetLayoutBinding</code> for <code>dstSet</code> at
<code>dstBinding</code> is <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>, and the new
active descriptor type is <code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>, the
<code>pMutableDescriptorTypeLists</code> for <code>srcBinding</code> and
<code>dstBinding</code> <strong class="purple">must</strong> match exactly</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkCopyDescriptorSet-sType-sType" href="#VUID-VkCopyDescriptorSet-sType-sType"></a> <span class="vuid">VUID-VkCopyDescriptorSet-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-pNext-pNext" href="#VUID-VkCopyDescriptorSet-pNext-pNext"></a> <span class="vuid">VUID-VkCopyDescriptorSet-pNext-pNext</span><br>
 <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcSet-parameter" href="#VUID-VkCopyDescriptorSet-srcSet-parameter"></a> <span class="vuid">VUID-VkCopyDescriptorSet-srcSet-parameter</span><br>
 <code>srcSet</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorSet">VkDescriptorSet</a> handle</p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-dstSet-parameter" href="#VUID-VkCopyDescriptorSet-dstSet-parameter"></a> <span class="vuid">VUID-VkCopyDescriptorSet-dstSet-parameter</span><br>
 <code>dstSet</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorSet">VkDescriptorSet</a> handle</p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-commonparent" href="#VUID-VkCopyDescriptorSet-commonparent"></a> <span class="vuid">VUID-VkCopyDescriptorSet-commonparent</span><br>
 Both of <code>dstSet</code>, and <code>srcSet</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap6.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-updates-with-template"><a class="anchor" href="#descriptorsets-updates-with-template"></a>14.2.5. Descriptor Update Templates</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>A descriptor update template specifies a mapping from descriptor update
information in host memory to descriptors in a descriptor set.
It is designed to avoid passing redundant information to the driver when
frequently updating the same set of descriptors in descriptor sets.</p>
</div>
<div class="paragraph">
<p>Descriptor update template objects are represented by
<code>VkDescriptorUpdateTemplate</code> handles:</p>
</div>
<div id="VkDescriptorUpdateTemplate" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_1</span>
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorUpdateTemplate)</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorUpdateTemplateKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_descriptor_update_template</span>
<span class="keyword">typedef</span> VkDescriptorUpdateTemplate VkDescriptorUpdateTemplateKHR;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_descriptor_set_updates_with_templates"><a class="anchor" href="#_descriptor_set_updates_with_templates"></a>14.2.6. Descriptor Set Updates with Templates</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Updating a large <code>VkDescriptorSet</code> array <strong class="purple">can</strong> be an expensive operation
since an application <strong class="purple">must</strong> specify one <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> structure
for each descriptor or descriptor array to update, each of which
re-specifies the same state when updating the same descriptor in multiple
descriptor sets.
For cases when an application wishes to update the same set of descriptors
in multiple descriptor sets allocated using the same
<code>VkDescriptorSetLayout</code>, <a href="#vkUpdateDescriptorSetWithTemplate">vkUpdateDescriptorSetWithTemplate</a> <strong class="purple">can</strong> be
used as a replacement for <a href="#vkUpdateDescriptorSets">vkUpdateDescriptorSets</a>.</p>
</div>
<div class="paragraph">
<p><code>VkDescriptorUpdateTemplate</code> allows implementations to convert a set of
descriptor update operations on a single descriptor set to an internal
format that, in conjunction with <a href="#vkUpdateDescriptorSetWithTemplate">vkUpdateDescriptorSetWithTemplate</a>
or <a href="#vkCmdPushDescriptorSetWithTemplateKHR">vkCmdPushDescriptorSetWithTemplateKHR</a>
, <strong class="purple">can</strong> be more efficient compared to calling <a href="#vkUpdateDescriptorSets">vkUpdateDescriptorSets</a>
or <a href="#vkCmdPushDescriptorSetKHR">vkCmdPushDescriptorSetKHR</a>
.
The descriptors themselves are not specified in the
<code>VkDescriptorUpdateTemplate</code>, rather, offsets into an application
provided pointer to host memory are specified, which are combined with a
pointer passed to <a href="#vkUpdateDescriptorSetWithTemplate">vkUpdateDescriptorSetWithTemplate</a>
or <a href="#vkCmdPushDescriptorSetWithTemplateKHR">vkCmdPushDescriptorSetWithTemplateKHR</a>
.
This allows large batches of updates to be executed without having to
convert application data structures into a strictly-defined Vulkan data
structure.</p>
</div>
<div class="paragraph">
<p>To create a descriptor update template, call:</p>
</div>
<div id="vkCreateDescriptorUpdateTemplate" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_1</span>
VkResult vkCreateDescriptorUpdateTemplate(
    VkDevice                                    device,
    <span class="directive">const</span> VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkDescriptorUpdateTemplate*                 pDescriptorUpdateTemplate);</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent command</p>
</div>
<div id="vkCreateDescriptorUpdateTemplateKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_descriptor_update_template</span>
VkResult vkCreateDescriptorUpdateTemplateKHR(
    VkDevice                                    device,
    <span class="directive">const</span> VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkDescriptorUpdateTemplate*                 pDescriptorUpdateTemplate);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that creates the descriptor update
template.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to a
<a href="#VkDescriptorUpdateTemplateCreateInfo">VkDescriptorUpdateTemplateCreateInfo</a> structure specifying the set
of descriptors to update with a single call to
<a href="#vkCmdPushDescriptorSetWithTemplateKHR">vkCmdPushDescriptorSetWithTemplateKHR</a> or
<a href="#vkUpdateDescriptorSetWithTemplate">vkUpdateDescriptorSetWithTemplate</a>.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap12.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
<li>
<p><code>pDescriptorUpdateTemplate</code> is a pointer to a
<code>VkDescriptorUpdateTemplate</code> handle in which the resulting
descriptor update template object is returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateDescriptorUpdateTemplate-device-parameter" href="#VUID-vkCreateDescriptorUpdateTemplate-device-parameter"></a> <span class="vuid">VUID-vkCreateDescriptorUpdateTemplate-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorUpdateTemplate-pCreateInfo-parameter" href="#VUID-vkCreateDescriptorUpdateTemplate-pCreateInfo-parameter"></a> <span class="vuid">VUID-vkCreateDescriptorUpdateTemplate-pCreateInfo-parameter</span><br>
 <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkDescriptorUpdateTemplateCreateInfo">VkDescriptorUpdateTemplateCreateInfo</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorUpdateTemplate-pAllocator-parameter" href="#VUID-vkCreateDescriptorUpdateTemplate-pAllocator-parameter"></a> <span class="vuid">VUID-vkCreateDescriptorUpdateTemplate-pAllocator-parameter</span><br>
 If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap12.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorUpdateTemplate-pDescriptorUpdateTemplate-parameter" href="#VUID-vkCreateDescriptorUpdateTemplate-pDescriptorUpdateTemplate-parameter"></a> <span class="vuid">VUID-vkCreateDescriptorUpdateTemplate-pDescriptorUpdateTemplate-parameter</span><br>
 <code>pDescriptorUpdateTemplate</code> <strong class="purple">must</strong> be a valid pointer to a <a href="#VkDescriptorUpdateTemplate">VkDescriptorUpdateTemplate</a> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap4.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap4.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <a href="#VkDescriptorUpdateTemplateCreateInfo">VkDescriptorUpdateTemplateCreateInfo</a> structure is defined as:</p>
</div>
<div id="VkDescriptorUpdateTemplateCreateInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_1</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorUpdateTemplateCreateInfo {
    VkStructureType                           sType;
    <span class="directive">const</span> <span class="directive">void</span>*                               pNext;
    VkDescriptorUpdateTemplateCreateFlags     flags;
    uint32_t                                  descriptorUpdateEntryCount;
    <span class="directive">const</span> VkDescriptorUpdateTemplateEntry*    pDescriptorUpdateEntries;
    VkDescriptorUpdateTemplateType            templateType;
    VkDescriptorSetLayout                     descriptorSetLayout;
    VkPipelineBindPoint                       pipelineBindPoint;
    VkPipelineLayout                          pipelineLayout;
    uint32_t                                  set;
} VkDescriptorUpdateTemplateCreateInfo;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorUpdateTemplateCreateInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_descriptor_update_template</span>
<span class="keyword">typedef</span> VkDescriptorUpdateTemplateCreateInfo VkDescriptorUpdateTemplateCreateInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
<li>
<p><code>descriptorUpdateEntryCount</code> is the number of elements in the
<code>pDescriptorUpdateEntries</code> array.</p>
</li>
<li>
<p><code>pDescriptorUpdateEntries</code> is a pointer to an array of
<a href="#VkDescriptorUpdateTemplateEntry">VkDescriptorUpdateTemplateEntry</a> structures describing the
descriptors to be updated by the descriptor update template.</p>
</li>
<li>
<p><code>templateType</code> Specifies the type of the descriptor update template.
If set to <code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET</code> it
<strong class="purple">can</strong> only be used to update descriptor sets with a fixed
<code>descriptorSetLayout</code>.
If set to <code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code>
it <strong class="purple">can</strong> only be used to push descriptor sets using the provided
<code>pipelineBindPoint</code>, <code>pipelineLayout</code>, and <code>set</code> number.</p>
</li>
<li>
<p><code>descriptorSetLayout</code> is the descriptor set layout the parameter
update template will be used with.
All descriptor sets which are going to be updated through the newly
created descriptor update template <strong class="purple">must</strong> be created with this layout.
<code>descriptorSetLayout</code> is the descriptor set layout used to build the
descriptor update template.
All descriptor sets which are going to be updated through the newly
created descriptor update template <strong class="purple">must</strong> be created with a layout that
matches (is the same as, or defined identically to) this layout.
This parameter is ignored if <code>templateType</code> is not
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET</code>.</p>
</li>
<li>
<p><code>pipelineBindPoint</code> is a <a href="chap11.html#VkPipelineBindPoint">VkPipelineBindPoint</a> indicating the
type of the pipeline that will use the descriptors.
This parameter is ignored if <code>templateType</code> is not
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code></p>
</li>
<li>
<p><code>pipelineLayout</code> is a <a href="#VkPipelineLayout">VkPipelineLayout</a> object used to program
the bindings.
This parameter is ignored if <code>templateType</code> is not
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code></p>
</li>
<li>
<p><code>set</code> is the set number of the descriptor set in the pipeline layout
that will be updated.
This parameter is ignored if <code>templateType</code> is not
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code></p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00350" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00350"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00350</span><br>

If <code>templateType</code> is
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET</code>,
<code>descriptorSetLayout</code> <strong class="purple">must</strong> be a valid <code>VkDescriptorSetLayout</code>
handle</p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00351" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00351"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00351</span><br>

If <code>templateType</code> is
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code>,
<code>pipelineBindPoint</code> <strong class="purple">must</strong> be a valid <a href="chap11.html#VkPipelineBindPoint">VkPipelineBindPoint</a> value</p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00352" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00352"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00352</span><br>

If <code>templateType</code> is
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code>,
<code>pipelineLayout</code> <strong class="purple">must</strong> be a valid <code>VkPipelineLayout</code> handle</p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00353" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00353"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00353</span><br>

If <code>templateType</code> is
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code>, <code>set</code>
<strong class="purple">must</strong> be the unique set number in the pipeline layout that uses a
descriptor set layout that was created with
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-04615" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-04615"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-04615</span><br>

If <code>templateType</code> is
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET</code>,
<code>descriptorSetLayout</code> <strong class="purple">must</strong> not contain a binding with type
<code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-sType-sType" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-sType-sType"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateCreateInfo-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-pNext-pNext" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-pNext-pNext"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateCreateInfo-pNext-pNext</span><br>
 <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-flags-zerobitmask" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-flags-zerobitmask"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateCreateInfo-flags-zerobitmask</span><br>
 <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-pDescriptorUpdateEntries-parameter" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-pDescriptorUpdateEntries-parameter"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateCreateInfo-pDescriptorUpdateEntries-parameter</span><br>
 <code>pDescriptorUpdateEntries</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorUpdateEntryCount</code> valid <a href="#VkDescriptorUpdateTemplateEntry">VkDescriptorUpdateTemplateEntry</a> structures</p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-parameter" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-parameter"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-parameter</span><br>
 <code>templateType</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorUpdateTemplateType">VkDescriptorUpdateTemplateType</a> value</p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-descriptorUpdateEntryCount-arraylength" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-descriptorUpdateEntryCount-arraylength"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateCreateInfo-descriptorUpdateEntryCount-arraylength</span><br>
 <code>descriptorUpdateEntryCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-commonparent" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-commonparent"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateCreateInfo-commonparent</span><br>
 Both of <code>descriptorSetLayout</code>, and <code>pipelineLayout</code> that are valid handles of non-ignored parameters <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap6.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkDescriptorUpdateTemplateCreateFlags" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_1</span>
<span class="keyword">typedef</span> VkFlags VkDescriptorUpdateTemplateCreateFlags;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorUpdateTemplateCreateFlagsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_descriptor_update_template</span>
<span class="keyword">typedef</span> VkDescriptorUpdateTemplateCreateFlags VkDescriptorUpdateTemplateCreateFlagsKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkDescriptorUpdateTemplateCreateFlags</code> is a bitmask type for setting a
mask, but is currently reserved for future use.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The descriptor update template type is determined by the
<a href="#VkDescriptorUpdateTemplateCreateInfo">VkDescriptorUpdateTemplateCreateInfo</a>::<code>templateType</code> property,
which takes the following values:</p>
</div>
<div id="VkDescriptorUpdateTemplateType" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_1</span>
<span class="keyword">typedef</span> <span class="keyword">enum</span> VkDescriptorUpdateTemplateType {
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = <span class="integer">0</span>,
  <span class="comment">// Provided by VK_KHR_push_descriptor with VK_VERSION_1_1, VK_KHR_push_descriptor with VK_KHR_descriptor_update_template, VK_KHR_descriptor_update_template with VK_KHR_push_descriptor</span>
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = <span class="integer">1</span>,
  <span class="comment">// Provided by VK_KHR_descriptor_update_template</span>
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
} VkDescriptorUpdateTemplateType;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorUpdateTemplateTypeKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_descriptor_update_template</span>
<span class="keyword">typedef</span> VkDescriptorUpdateTemplateType VkDescriptorUpdateTemplateTypeKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET</code> specifies that
the descriptor update template will be used for descriptor set updates
only.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code> specifies
that the descriptor update template will be used for push descriptor
updates only.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDescriptorUpdateTemplateEntry</code> structure is defined as:</p>
</div>
<div id="VkDescriptorUpdateTemplateEntry" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_1</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorUpdateTemplateEntry {
    uint32_t            dstBinding;
    uint32_t            dstArrayElement;
    uint32_t            descriptorCount;
    VkDescriptorType    descriptorType;
    size_t              offset;
    size_t              stride;
} VkDescriptorUpdateTemplateEntry;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorUpdateTemplateEntryKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_descriptor_update_template</span>
<span class="keyword">typedef</span> VkDescriptorUpdateTemplateEntry VkDescriptorUpdateTemplateEntryKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>dstBinding</code> is the descriptor binding to update when using this
descriptor update template.</p>
</li>
<li>
<p><code>dstArrayElement</code> is the starting element in the array belonging to
<code>dstBinding</code>.
If the descriptor binding identified by <code>dstBinding</code> has a
descriptor type of <code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>
then <code>dstArrayElement</code> specifies the starting byte offset to update.</p>
</li>
<li>
<p><code>descriptorCount</code> is the number of descriptors to update.
If <code>descriptorCount</code> is greater than the number of remaining array
elements in the destination binding, those affect consecutive bindings
in a manner similar to <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> above.
If the descriptor binding identified by <code>dstBinding</code> has a
descriptor type of <code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>
then <code>descriptorCount</code> specifies the number of bytes to update and
the remaining array elements in the destination binding refer to the
remaining number of bytes in it.</p>
</li>
<li>
<p><code>descriptorType</code> is a <a href="#VkDescriptorType">VkDescriptorType</a> specifying the type of
the descriptor.</p>
</li>
<li>
<p><code>offset</code> is the offset in bytes of the first binding in the raw data
structure.</p>
</li>
<li>
<p><code>stride</code> is the stride in bytes between two consecutive array
elements of the descriptor update informations in the raw data
structure.
The actual pointer ptr for each array element j of update entry i is
computed using the following formula:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">    <span class="directive">const</span> <span class="predefined-type">char</span> *ptr = (<span class="directive">const</span> <span class="predefined-type">char</span> *)pData + pDescriptorUpdateEntries[i].offset + j * pDescriptorUpdateEntries[i].stride</code></pre>
</div>
</div>
<div class="paragraph">
<p>The stride is useful in case the bindings are stored in structs along with
other data.
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>
then the value of <code>stride</code> is ignored and the stride is assumed to be
<code>1</code>, i.e. the descriptor update information for them is always specified as
a contiguous range.</p>
</div>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateEntry-dstBinding-00354" href="#VUID-VkDescriptorUpdateTemplateEntry-dstBinding-00354"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateEntry-dstBinding-00354</span><br>

<code>dstBinding</code> <strong class="purple">must</strong> be a valid binding in the descriptor set layout
implicitly specified when using a descriptor update template to update
descriptors</p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateEntry-dstArrayElement-00355" href="#VUID-VkDescriptorUpdateTemplateEntry-dstArrayElement-00355"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateEntry-dstArrayElement-00355</span><br>

<code>dstArrayElement</code> and <code>descriptorCount</code> <strong class="purple">must</strong> be less than or
equal to the number of array elements in the descriptor set binding
implicitly specified when using a descriptor update template to update
descriptors, and all applicable consecutive bindings, as described by
<a href="#descriptorsets-updates-consecutive">consecutive binding updates</a></p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateEntry-descriptor-02226" href="#VUID-VkDescriptorUpdateTemplateEntry-descriptor-02226"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateEntry-descriptor-02226</span><br>

If <code>descriptor</code> type is
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>, <code>dstArrayElement</code>
<strong class="purple">must</strong> be an integer multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateEntry-descriptor-02227" href="#VUID-VkDescriptorUpdateTemplateEntry-descriptor-02227"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateEntry-descriptor-02227</span><br>

If <code>descriptor</code> type is
<code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>, <code>descriptorCount</code>
<strong class="purple">must</strong> be an integer multiple of <code>4</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateEntry-descriptorType-parameter" href="#VUID-VkDescriptorUpdateTemplateEntry-descriptorType-parameter"></a> <span class="vuid">VUID-VkDescriptorUpdateTemplateEntry-descriptorType-parameter</span><br>
 <code>descriptorType</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorType">VkDescriptorType</a> value</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To destroy a descriptor update template, call:</p>
</div>
<div id="vkDestroyDescriptorUpdateTemplate" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_1</span>
<span class="directive">void</span> vkDestroyDescriptorUpdateTemplate(
    VkDevice                                    device,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator);</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent command</p>
</div>
<div id="vkDestroyDescriptorUpdateTemplateKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_descriptor_update_template</span>
<span class="directive">void</span> vkDestroyDescriptorUpdateTemplateKHR(
    VkDevice                                    device,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that has been used to create the
descriptor update template</p>
</li>
<li>
<p><code>descriptorUpdateTemplate</code> is the descriptor update template to
destroy.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap12.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00356" href="#VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00356"></a> <span class="vuid">VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00356</span><br>

If <code>VkAllocationCallbacks</code> were provided when
<code>descriptorSetLayout</code> was created, a compatible set of callbacks
<strong class="purple">must</strong> be provided here</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00357" href="#VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00357"></a> <span class="vuid">VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00357</span><br>

If no <code>VkAllocationCallbacks</code> were provided when
<code>descriptorSetLayout</code> was created, <code>pAllocator</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyDescriptorUpdateTemplate-device-parameter" href="#VUID-vkDestroyDescriptorUpdateTemplate-device-parameter"></a> <span class="vuid">VUID-vkDestroyDescriptorUpdateTemplate-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parameter" href="#VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parameter"></a> <span class="vuid">VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parameter</span><br>
 If <code>descriptorUpdateTemplate</code> is not <a href="chap51.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>descriptorUpdateTemplate</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorUpdateTemplate">VkDescriptorUpdateTemplate</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorUpdateTemplate-pAllocator-parameter" href="#VUID-vkDestroyDescriptorUpdateTemplate-pAllocator-parameter"></a> <span class="vuid">VUID-vkDestroyDescriptorUpdateTemplate-pAllocator-parameter</span><br>
 If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap12.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parent" href="#VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parent"></a> <span class="vuid">VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parent</span><br>
 If <code>descriptorUpdateTemplate</code> is a valid handle, it <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>descriptorUpdateTemplate</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Once a <code>VkDescriptorUpdateTemplate</code> has been created, descriptor sets
<strong class="purple">can</strong> be updated by calling:</p>
</div>
<div id="vkUpdateDescriptorSetWithTemplate" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_1</span>
<span class="directive">void</span> vkUpdateDescriptorSetWithTemplate(
    VkDevice                                    device,
    VkDescriptorSet                             descriptorSet,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    <span class="directive">const</span> <span class="directive">void</span>*                                 pData);</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent command</p>
</div>
<div id="vkUpdateDescriptorSetWithTemplateKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_descriptor_update_template</span>
<span class="directive">void</span> vkUpdateDescriptorSetWithTemplateKHR(
    VkDevice                                    device,
    VkDescriptorSet                             descriptorSet,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    <span class="directive">const</span> <span class="directive">void</span>*                                 pData);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that updates the descriptor sets.</p>
</li>
<li>
<p><code>descriptorSet</code> is the descriptor set to update</p>
</li>
<li>
<p><code>descriptorUpdateTemplate</code> is a <a href="#VkDescriptorUpdateTemplate">VkDescriptorUpdateTemplate</a>
object specifying the update mapping between <code>pData</code> and the
descriptor set to update.</p>
</li>
<li>
<p><code>pData</code> is a pointer to memory containing one or more
    <a href="#VkDescriptorImageInfo">VkDescriptorImageInfo</a>, <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a>, or
    <a href="chap13.html#VkBufferView">VkBufferView</a> structures
or <a href="chap13.html#VkAccelerationStructureKHR">VkAccelerationStructureKHR</a>
or <a href="chap13.html#VkAccelerationStructureNV">VkAccelerationStructureNV</a>
handles
    used to write the descriptors.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkUpdateDescriptorSetWithTemplate-pData-01685" href="#VUID-vkUpdateDescriptorSetWithTemplate-pData-01685"></a> <span class="vuid">VUID-vkUpdateDescriptorSetWithTemplate-pData-01685</span><br>

<code>pData</code> <strong class="purple">must</strong> be a valid pointer to a memory containing one or more
valid instances of <a href="#VkDescriptorImageInfo">VkDescriptorImageInfo</a>,
<a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a>, or <a href="chap13.html#VkBufferView">VkBufferView</a> in a layout defined
by <code>descriptorUpdateTemplate</code> when it was created with
<a href="#vkCreateDescriptorUpdateTemplate">vkCreateDescriptorUpdateTemplate</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkUpdateDescriptorSetWithTemplate-device-parameter" href="#VUID-vkUpdateDescriptorSetWithTemplate-device-parameter"></a> <span class="vuid">VUID-vkUpdateDescriptorSetWithTemplate-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkUpdateDescriptorSetWithTemplate-descriptorSet-parameter" href="#VUID-vkUpdateDescriptorSetWithTemplate-descriptorSet-parameter"></a> <span class="vuid">VUID-vkUpdateDescriptorSetWithTemplate-descriptorSet-parameter</span><br>
 <code>descriptorSet</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorSet">VkDescriptorSet</a> handle</p>
</li>
<li>
<p><a id="VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parameter" href="#VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parameter"></a> <span class="vuid">VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parameter</span><br>
 <code>descriptorUpdateTemplate</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorUpdateTemplate">VkDescriptorUpdateTemplate</a> handle</p>
</li>
<li>
<p><a id="VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parent" href="#VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parent"></a> <span class="vuid">VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parent</span><br>
 <code>descriptorUpdateTemplate</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>descriptorSet</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">API example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">struct</span> AppBufferView {
    VkBufferView bufferView;
    uint32_t     applicationRelatedInformation;
};

<span class="keyword">struct</span> AppDataStructure
{
    VkDescriptorImageInfo  imageInfo;          <span class="comment">// a single image info</span>
    VkDescriptorBufferInfo bufferInfoArray[<span class="integer">3</span>]; <span class="comment">// 3 buffer infos in an array</span>
    AppBufferView          bufferView[<span class="integer">2</span>];      <span class="comment">// An application defined structure containing a bufferView</span>
    <span class="comment">// ... some more application related data</span>
};

<span class="directive">const</span> VkDescriptorUpdateTemplateEntry descriptorUpdateTemplateEntries[] =
{
    <span class="comment">// binding to a single image descriptor</span>
    {
        <span class="integer">0</span>,                                           <span class="comment">// binding</span>
        <span class="integer">0</span>,                                           <span class="comment">// dstArrayElement</span>
        <span class="integer">1</span>,                                           <span class="comment">// descriptorCount</span>
        VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,   <span class="comment">// descriptorType</span>
        offsetof(AppDataStructure, imageInfo),       <span class="comment">// offset</span>
        <span class="integer">0</span>                                            <span class="comment">// stride is not required if descriptorCount is 1</span>
    },

    <span class="comment">// binding to an array of buffer descriptors</span>
    {
        <span class="integer">1</span>,                                           <span class="comment">// binding</span>
        <span class="integer">0</span>,                                           <span class="comment">// dstArrayElement</span>
        <span class="integer">3</span>,                                           <span class="comment">// descriptorCount</span>
        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,           <span class="comment">// descriptorType</span>
        offsetof(AppDataStructure, bufferInfoArray), <span class="comment">// offset</span>
        <span class="keyword">sizeof</span>(VkDescriptorBufferInfo)               <span class="comment">// stride, descriptor buffer infos are compact</span>
    },

    <span class="comment">// binding to an array of buffer views</span>
    {
        <span class="integer">2</span>,                                           <span class="comment">// binding</span>
        <span class="integer">0</span>,                                           <span class="comment">// dstArrayElement</span>
        <span class="integer">2</span>,                                           <span class="comment">// descriptorCount</span>
        VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,     <span class="comment">// descriptorType</span>
        offsetof(AppDataStructure, bufferView) +
          offsetof(AppBufferView, bufferView),       <span class="comment">// offset</span>
        <span class="keyword">sizeof</span>(AppBufferView)                        <span class="comment">// stride, bufferViews do not have to be compact</span>
    },
};

<span class="comment">// create a descriptor update template for descriptor set updates</span>
<span class="directive">const</span> VkDescriptorUpdateTemplateCreateInfo createInfo =
{
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,  <span class="comment">// sType</span>
    <span class="predefined-constant">NULL</span>,                                                      <span class="comment">// pNext</span>
    <span class="integer">0</span>,                                                         <span class="comment">// flags</span>
    <span class="integer">3</span>,                                                         <span class="comment">// descriptorUpdateEntryCount</span>
    descriptorUpdateTemplateEntries,                           <span class="comment">// pDescriptorUpdateEntries</span>
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,         <span class="comment">// templateType</span>
    myLayout,                                                  <span class="comment">// descriptorSetLayout</span>
    <span class="integer">0</span>,                                                         <span class="comment">// pipelineBindPoint, ignored by given templateType</span>
    <span class="integer">0</span>,                                                         <span class="comment">// pipelineLayout, ignored by given templateType</span>
    <span class="integer">0</span>,                                                         <span class="comment">// set, ignored by given templateType</span>
};

VkDescriptorUpdateTemplate myDescriptorUpdateTemplate;
myResult = vkCreateDescriptorUpdateTemplate(
    myDevice,
    &amp;createInfo,
    <span class="predefined-constant">NULL</span>,
    &amp;myDescriptorUpdateTemplate);
}


AppDataStructure appData;

<span class="comment">// fill appData here or cache it in your engine</span>
vkUpdateDescriptorSetWithTemplate(myDevice, myDescriptorSet, myDescriptorUpdateTemplate, &amp;appData);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-binding"><a class="anchor" href="#descriptorsets-binding"></a>14.2.7. Descriptor Set Binding</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To bind one or more descriptor sets to a command buffer, call:</p>
</div>
<div id="vkCmdBindDescriptorSets" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="directive">void</span> vkCmdBindDescriptorSets(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    <span class="directive">const</span> VkDescriptorSet*                      pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    <span class="directive">const</span> uint32_t*                             pDynamicOffsets);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>commandBuffer</code> is the command buffer that the descriptor sets will
be bound to.</p>
</li>
<li>
<p><code>pipelineBindPoint</code> is a <a href="chap11.html#VkPipelineBindPoint">VkPipelineBindPoint</a> indicating the
type of the pipeline that will use the descriptors.
There is a separate set of bind points for each pipeline type, so
binding one does not disturb the others.</p>
</li>
<li>
<p><code>layout</code> is a <a href="#VkPipelineLayout">VkPipelineLayout</a> object used to program the
bindings.</p>
</li>
<li>
<p><code>firstSet</code> is the set number of the first descriptor set to be
bound.</p>
</li>
<li>
<p><code>descriptorSetCount</code> is the number of elements in the
<code>pDescriptorSets</code> array.</p>
</li>
<li>
<p><code>pDescriptorSets</code> is a pointer to an array of handles to
<a href="#VkDescriptorSet">VkDescriptorSet</a> objects describing the descriptor sets to write
to.</p>
</li>
<li>
<p><code>dynamicOffsetCount</code> is the number of dynamic offsets in the
<code>pDynamicOffsets</code> array.</p>
</li>
<li>
<p><code>pDynamicOffsets</code> is a pointer to an array of <code>uint32_t</code> values
specifying dynamic offsets.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>vkCmdBindDescriptorSets</code> causes the sets numbered [<code>firstSet</code>..
<code>firstSet</code>+<code>descriptorSetCount</code>-1] to use the bindings stored in
<code>pDescriptorSets</code>[0..descriptorSetCount-1] for subsequent
<a href="chap11.html#pipeline-bindpoint-commands">bound pipeline commands</a> set by
<code>pipelineBindPoint</code>.
Any bindings that were previously applied via these sets are no longer
valid.</p>
</div>
<div class="paragraph">
<p>Once bound, a descriptor set affects rendering of subsequent commands that
interact with the given pipeline type in the command buffer until either a
different set is bound to the same set number, or the set is disturbed as
described in <a href="#descriptorsets-compatibility">Pipeline Layout
Compatibility</a>.</p>
</div>
<div class="paragraph">
<p>A compatible descriptor set <strong class="purple">must</strong> be bound for all set numbers that any
shaders in a pipeline access, at the time that a draw or dispatch command is
recorded to execute using that pipeline.
However, if none of the shaders in a pipeline statically use any bindings
with a particular set number, then no descriptor set need be bound for that
set number, even if the pipeline layout includes a non-trivial descriptor
set layout for that set number.</p>
</div>
<div id="descriptorsets-binding-dynamicoffsets" class="paragraph">
<p>If any of the sets being bound include dynamic uniform or storage buffers,
then <code>pDynamicOffsets</code> includes one element for each array element in
each dynamic descriptor type binding in each set.
Values are taken from <code>pDynamicOffsets</code> in an order such that all
entries for set N come before set N+1; within a set, entries are ordered by
the binding numbers in the descriptor set layouts; and within a binding
array, elements are in order.
<code>dynamicOffsetCount</code> <strong class="purple">must</strong> equal the total number of dynamic descriptors
in the sets being bound.</p>
</div>
<div class="paragraph">
<p>The effective offset used for dynamic uniform and storage buffer bindings is
the sum of the relative offset taken from <code>pDynamicOffsets</code>, and the
base address of the buffer plus base offset in the descriptor set.
The range of the dynamic uniform and storage buffer bindings is the buffer
range as specified in the descriptor set.</p>
</div>
<div class="paragraph">
<p>Each of the <code>pDescriptorSets</code> <strong class="purple">must</strong> be compatible with the pipeline
layout specified by <code>layout</code>.
The layout used to program the bindings <strong class="purple">must</strong> also be compatible with the
pipeline used in subsequent <a href="chap11.html#pipeline-bindpoint-commands">bound pipeline
commands</a> with that pipeline type, as defined in the
<a href="#descriptorsets-compatibility">Pipeline Layout Compatibility</a> section.</p>
</div>
<div class="paragraph">
<p>The descriptor set contents bound by a call to <code>vkCmdBindDescriptorSets</code>
<strong class="purple">may</strong> be consumed at the following times:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For descriptor bindings created with the
<code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code> bit set, the contents
<strong class="purple">may</strong> be consumed when the command buffer is submitted to a queue, or
during shader execution of the resulting draws and dispatches, or any
time in between.
Otherwise,</p>
</li>
<li>
<p>during host execution of the command, or during shader execution of the
resulting draws and dispatches, or any time in between.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Thus, the contents of a descriptor set binding <strong class="purple">must</strong> not be altered
(overwritten by an update command, or freed) between the first point in time
that it <strong class="purple">may</strong> be consumed, and when the command completes executing on the
queue.</p>
</div>
<div class="paragraph">
<p>The contents of <code>pDynamicOffsets</code> are consumed immediately during
execution of <code>vkCmdBindDescriptorSets</code>.
Once all pending uses have completed, it is legal to update and reuse a
descriptor set.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pDescriptorSets-00358" href="#VUID-vkCmdBindDescriptorSets-pDescriptorSets-00358"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-pDescriptorSets-00358</span><br>

Each element of <code>pDescriptorSets</code> <strong class="purple">must</strong> have been allocated with a
<code>VkDescriptorSetLayout</code> that matches (is the same as, or identically
defined as) the <code>VkDescriptorSetLayout</code> at set <em>n</em> in <code>layout</code>,
where <em>n</em> is the sum of <code>firstSet</code> and the index into
<code>pDescriptorSets</code></p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-dynamicOffsetCount-00359" href="#VUID-vkCmdBindDescriptorSets-dynamicOffsetCount-00359"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-dynamicOffsetCount-00359</span><br>

<code>dynamicOffsetCount</code> <strong class="purple">must</strong> be equal to the total number of dynamic
descriptors in <code>pDescriptorSets</code></p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-firstSet-00360" href="#VUID-vkCmdBindDescriptorSets-firstSet-00360"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-firstSet-00360</span><br>

The sum of <code>firstSet</code> and <code>descriptorSetCount</code> <strong class="purple">must</strong> be less
than or equal to <a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a>::<code>setLayoutCount</code>
provided when <code>layout</code> was created</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pipelineBindPoint-00361" href="#VUID-vkCmdBindDescriptorSets-pipelineBindPoint-00361"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-pipelineBindPoint-00361</span><br>

<code>pipelineBindPoint</code> <strong class="purple">must</strong> be supported by the <code>commandBuffer</code>’s
parent <code>VkCommandPool</code>’s queue family</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01971" href="#VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01971"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01971</span><br>

Each element of <code>pDynamicOffsets</code> which corresponds to a descriptor
binding with type <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> <strong class="purple">must</strong>
be a multiple of
<code>VkPhysicalDeviceLimits</code>::<code>minUniformBufferOffsetAlignment</code></p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01972" href="#VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01972"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01972</span><br>

Each element of <code>pDynamicOffsets</code> which corresponds to a descriptor
binding with type <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> <strong class="purple">must</strong>
be a multiple of
<code>VkPhysicalDeviceLimits</code>::<code>minStorageBufferOffsetAlignment</code></p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pDescriptorSets-01979" href="#VUID-vkCmdBindDescriptorSets-pDescriptorSets-01979"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-pDescriptorSets-01979</span><br>

For each dynamic uniform or storage buffer binding in
<code>pDescriptorSets</code>, the sum of the effective offset, as defined
above, and the range of the binding <strong class="purple">must</strong> be less than or equal to the
size of the buffer</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pDescriptorSets-04616" href="#VUID-vkCmdBindDescriptorSets-pDescriptorSets-04616"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-pDescriptorSets-04616</span><br>

Each element of <code>pDescriptorSets</code> <strong class="purple">must</strong> not have been allocated from
a <code>VkDescriptorPool</code> with the
<code>VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE</code> flag set</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-commandBuffer-parameter" href="#VUID-vkCmdBindDescriptorSets-commandBuffer-parameter"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-commandBuffer-parameter</span><br>
 <code>commandBuffer</code> <strong class="purple">must</strong> be a valid <a href="chap7.html#VkCommandBuffer">VkCommandBuffer</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pipelineBindPoint-parameter" href="#VUID-vkCmdBindDescriptorSets-pipelineBindPoint-parameter"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-pipelineBindPoint-parameter</span><br>
 <code>pipelineBindPoint</code> <strong class="purple">must</strong> be a valid <a href="chap11.html#VkPipelineBindPoint">VkPipelineBindPoint</a> value</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-layout-parameter" href="#VUID-vkCmdBindDescriptorSets-layout-parameter"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-layout-parameter</span><br>
 <code>layout</code> <strong class="purple">must</strong> be a valid <a href="#VkPipelineLayout">VkPipelineLayout</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pDescriptorSets-parameter" href="#VUID-vkCmdBindDescriptorSets-pDescriptorSets-parameter"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-pDescriptorSets-parameter</span><br>
 <code>pDescriptorSets</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorSetCount</code> valid <a href="#VkDescriptorSet">VkDescriptorSet</a> handles</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pDynamicOffsets-parameter" href="#VUID-vkCmdBindDescriptorSets-pDynamicOffsets-parameter"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-pDynamicOffsets-parameter</span><br>
 If <code>dynamicOffsetCount</code> is not <code>0</code>, <code>pDynamicOffsets</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>dynamicOffsetCount</code> <code>uint32_t</code> values</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-commandBuffer-recording" href="#VUID-vkCmdBindDescriptorSets-commandBuffer-recording"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-commandBuffer-recording</span><br>
 <code>commandBuffer</code> <strong class="purple">must</strong> be in the <a href="chap7.html#commandbuffers-lifecycle">recording state</a></p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-commandBuffer-cmdpool" href="#VUID-vkCmdBindDescriptorSets-commandBuffer-cmdpool"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-commandBuffer-cmdpool</span><br>
 The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> support graphics, or compute operations</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-descriptorSetCount-arraylength" href="#VUID-vkCmdBindDescriptorSets-descriptorSetCount-arraylength"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-descriptorSetCount-arraylength</span><br>
 <code>descriptorSetCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-commonparent" href="#VUID-vkCmdBindDescriptorSets-commonparent"></a> <span class="vuid">VUID-vkCmdBindDescriptorSets-commonparent</span><br>
 Each of <code>commandBuffer</code>, <code>layout</code>, and the elements of <code>pDescriptorSets</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap6.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>commandBuffer</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Command Properties</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><a href="chap7.html#VkCommandBufferLevel">Command Buffer Levels</a></th>
<th class="tableblock halign-left valign-top"><a href="chap9.html#vkCmdBeginRenderPass">Render Pass Scope</a></th>
<th class="tableblock halign-left valign-top"><a href="chap6.html#VkQueueFlagBits">Supported Queue Types</a></th>
<th class="tableblock halign-left valign-top"><a href="chap8.html#synchronization-pipeline-stages-types">Pipeline Type</a></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br>
Secondary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br>
Compute</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-push-descriptors"><a class="anchor" href="#descriptorsets-push-descriptors"></a>14.2.8. Push Descriptor Updates</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>In addition to allocating descriptor sets and binding them to a command
buffer, an application <strong class="purple">can</strong> record descriptor updates into the command
buffer.</p>
</div>
<div class="paragraph">
<p>To push descriptor updates into a command buffer, call:</p>
</div>
<div id="vkCmdPushDescriptorSetKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_push_descriptor</span>
<span class="directive">void</span> vkCmdPushDescriptorSetKHR(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    uint32_t                                    descriptorWriteCount,
    <span class="directive">const</span> VkWriteDescriptorSet*                 pDescriptorWrites);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>commandBuffer</code> is the command buffer that the descriptors will be
recorded in.</p>
</li>
<li>
<p><code>pipelineBindPoint</code> is a <a href="chap11.html#VkPipelineBindPoint">VkPipelineBindPoint</a> indicating the
type of the pipeline that will use the descriptors.
There is a separate set of push descriptor bindings for each pipeline
type, so binding one does not disturb the others.</p>
</li>
<li>
<p><code>layout</code> is a <a href="#VkPipelineLayout">VkPipelineLayout</a> object used to program the
bindings.</p>
</li>
<li>
<p><code>set</code> is the set number of the descriptor set in the pipeline layout
that will be updated.</p>
</li>
<li>
<p><code>descriptorWriteCount</code> is the number of elements in the
<code>pDescriptorWrites</code> array.</p>
</li>
<li>
<p><code>pDescriptorWrites</code> is a pointer to an array of
<a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> structures describing the descriptors to be
updated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Push descriptors</em> are a small bank of descriptors whose storage is
internally managed by the command buffer rather than being written into a
descriptor set and later bound to a command buffer.
Push descriptors allow for incremental updates of descriptors without
managing the lifetime of descriptor sets.</p>
</div>
<div class="paragraph">
<p>When a command buffer begins recording, all push descriptors are undefined.
Push descriptors <strong class="purple">can</strong> be updated incrementally and cause shaders to use the
updated descriptors for subsequent <a href="chap11.html#pipeline-bindpoint-commands">bound
pipeline commands</a> with the pipeline type set by <code>pipelineBindPoint</code>
until the descriptor is overwritten, or else until the set is disturbed as
described in <a href="#descriptorsets-compatibility">Pipeline Layout
Compatibility</a>.
When the set is disturbed or push descriptors with a different descriptor
set layout are set, all push descriptors are undefined.</p>
</div>
<div class="paragraph">
<p>Push descriptors that are <a href="chap10.html#shaders-staticuse">statically used</a> by a
pipeline <strong class="purple">must</strong> not be undefined at the time that a draw or dispatch command
is recorded to execute using that pipeline.
This includes immutable sampler descriptors, which <strong class="purple">must</strong> be pushed before
they are accessed by a pipeline (the immutable samplers are pushed, rather
than the samplers in <code>pDescriptorWrites</code>).
Push descriptors that are not statically used <strong class="purple">can</strong> remain undefined.</p>
</div>
<div class="paragraph">
<p>Push descriptors do not use dynamic offsets.
Instead, the corresponding non-dynamic descriptor types <strong class="purple">can</strong> be used and the
<code>offset</code> member of <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a> <strong class="purple">can</strong> be changed each
time the descriptor is written.</p>
</div>
<div class="paragraph">
<p>Each element of <code>pDescriptorWrites</code> is interpreted as in
<a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>, except the <code>dstSet</code> member is ignored.</p>
</div>
<div class="paragraph">
<p>To push an immutable sampler, use a <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> with
<code>dstBinding</code> and <code>dstArrayElement</code> selecting the immutable sampler’s
binding.
If the descriptor type is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>, the
<code>pImageInfo</code> parameter is ignored and the immutable sampler is taken
from the push descriptor set layout in the pipeline layout.
If the descriptor type is <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
the <code>sampler</code> member of the <code>pImageInfo</code> parameter is ignored and
the immutable sampler is taken from the push descriptor set layout in the
pipeline layout.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-00363" href="#VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-00363"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-00363</span><br>

<code>pipelineBindPoint</code> <strong class="purple">must</strong> be supported by the <code>commandBuffer</code>’s
parent <code>VkCommandPool</code>’s queue family</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-set-00364" href="#VUID-vkCmdPushDescriptorSetKHR-set-00364"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetKHR-set-00364</span><br>

<code>set</code> <strong class="purple">must</strong> be less than
<a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a>::<code>setLayoutCount</code> provided when
<code>layout</code> was created</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-set-00365" href="#VUID-vkCmdPushDescriptorSetKHR-set-00365"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetKHR-set-00365</span><br>

<code>set</code> <strong class="purple">must</strong> be the unique set number in the pipeline layout that
uses a descriptor set layout that was created with
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-commandBuffer-parameter" href="#VUID-vkCmdPushDescriptorSetKHR-commandBuffer-parameter"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetKHR-commandBuffer-parameter</span><br>
 <code>commandBuffer</code> <strong class="purple">must</strong> be a valid <a href="chap7.html#VkCommandBuffer">VkCommandBuffer</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-parameter" href="#VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-parameter"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-parameter</span><br>
 <code>pipelineBindPoint</code> <strong class="purple">must</strong> be a valid <a href="chap11.html#VkPipelineBindPoint">VkPipelineBindPoint</a> value</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-layout-parameter" href="#VUID-vkCmdPushDescriptorSetKHR-layout-parameter"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetKHR-layout-parameter</span><br>
 <code>layout</code> <strong class="purple">must</strong> be a valid <a href="#VkPipelineLayout">VkPipelineLayout</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-pDescriptorWrites-parameter" href="#VUID-vkCmdPushDescriptorSetKHR-pDescriptorWrites-parameter"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetKHR-pDescriptorWrites-parameter</span><br>
 <code>pDescriptorWrites</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorWriteCount</code> valid <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> structures</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-commandBuffer-recording" href="#VUID-vkCmdPushDescriptorSetKHR-commandBuffer-recording"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetKHR-commandBuffer-recording</span><br>
 <code>commandBuffer</code> <strong class="purple">must</strong> be in the <a href="chap7.html#commandbuffers-lifecycle">recording state</a></p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-commandBuffer-cmdpool" href="#VUID-vkCmdPushDescriptorSetKHR-commandBuffer-cmdpool"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetKHR-commandBuffer-cmdpool</span><br>
 The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> support graphics, or compute operations</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-descriptorWriteCount-arraylength" href="#VUID-vkCmdPushDescriptorSetKHR-descriptorWriteCount-arraylength"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetKHR-descriptorWriteCount-arraylength</span><br>
 <code>descriptorWriteCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-commonparent" href="#VUID-vkCmdPushDescriptorSetKHR-commonparent"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetKHR-commonparent</span><br>
 Both of <code>commandBuffer</code>, and <code>layout</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap6.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>commandBuffer</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Command Properties</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><a href="chap7.html#VkCommandBufferLevel">Command Buffer Levels</a></th>
<th class="tableblock halign-left valign-top"><a href="chap9.html#vkCmdBeginRenderPass">Render Pass Scope</a></th>
<th class="tableblock halign-left valign-top"><a href="chap6.html#VkQueueFlagBits">Supported Queue Types</a></th>
<th class="tableblock halign-left valign-top"><a href="chap8.html#synchronization-pipeline-stages-types">Pipeline Type</a></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br>
Secondary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br>
Compute</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_push_descriptor_updates_with_descriptor_update_templates"><a class="anchor" href="#_push_descriptor_updates_with_descriptor_update_templates"></a>14.2.9. Push Descriptor Updates with Descriptor Update Templates</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>It is also possible to use a descriptor update template to specify the push
descriptors to update.
To do so, call:</p>
</div>
<div id="vkCmdPushDescriptorSetWithTemplateKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_push_descriptor with VK_VERSION_1_1, VK_KHR_push_descriptor with VK_KHR_descriptor_update_template, VK_KHR_descriptor_update_template with VK_KHR_push_descriptor</span>
<span class="directive">void</span> vkCmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer                             commandBuffer,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    <span class="directive">const</span> <span class="directive">void</span>*                                 pData);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>commandBuffer</code> is the command buffer that the descriptors will be
recorded in.</p>
</li>
<li>
<p><code>descriptorUpdateTemplate</code> is a descriptor update template defining
how to interpret the descriptor information in <code>pData</code>.</p>
</li>
<li>
<p><code>layout</code> is a <a href="#VkPipelineLayout">VkPipelineLayout</a> object used to program the
bindings.
It <strong class="purple">must</strong> be compatible with the layout used to create the
<code>descriptorUpdateTemplate</code> handle.</p>
</li>
<li>
<p><code>set</code> is the set number of the descriptor set in the pipeline layout
that will be updated.
This <strong class="purple">must</strong> be the same number used to create the
<code>descriptorUpdateTemplate</code> handle.</p>
</li>
<li>
<p><code>pData</code> is a pointer to memory containing descriptors for the
templated update.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-00366" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-00366"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-00366</span><br>

The <code>pipelineBindPoint</code> specified during the creation of the
descriptor update template <strong class="purple">must</strong> be supported by the
<code>commandBuffer</code>’s parent <code>VkCommandPool</code>’s queue family</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-pData-01686" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-pData-01686"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetWithTemplateKHR-pData-01686</span><br>

<code>pData</code> <strong class="purple">must</strong> be a valid pointer to a memory containing one or more
valid instances of <a href="#VkDescriptorImageInfo">VkDescriptorImageInfo</a>,
<a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a>, or <a href="chap13.html#VkBufferView">VkBufferView</a> in a layout defined
by <code>descriptorUpdateTemplate</code> when it was created with
<a href="#vkCreateDescriptorUpdateTemplate">vkCreateDescriptorUpdateTemplate</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-parameter" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-parameter"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-parameter</span><br>
 <code>commandBuffer</code> <strong class="purple">must</strong> be a valid <a href="chap7.html#VkCommandBuffer">VkCommandBuffer</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-descriptorUpdateTemplate-parameter" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-descriptorUpdateTemplate-parameter"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetWithTemplateKHR-descriptorUpdateTemplate-parameter</span><br>
 <code>descriptorUpdateTemplate</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorUpdateTemplate">VkDescriptorUpdateTemplate</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-layout-parameter" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-layout-parameter"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetWithTemplateKHR-layout-parameter</span><br>
 <code>layout</code> <strong class="purple">must</strong> be a valid <a href="#VkPipelineLayout">VkPipelineLayout</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-recording" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-recording"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-recording</span><br>
 <code>commandBuffer</code> <strong class="purple">must</strong> be in the <a href="chap7.html#commandbuffers-lifecycle">recording state</a></p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-cmdpool" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-cmdpool"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-cmdpool</span><br>
 The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> support graphics, or compute operations</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-commonparent" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-commonparent"></a> <span class="vuid">VUID-vkCmdPushDescriptorSetWithTemplateKHR-commonparent</span><br>
 Each of <code>commandBuffer</code>, <code>descriptorUpdateTemplate</code>, and <code>layout</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap6.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>commandBuffer</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Command Properties</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><a href="chap7.html#VkCommandBufferLevel">Command Buffer Levels</a></th>
<th class="tableblock halign-left valign-top"><a href="chap9.html#vkCmdBeginRenderPass">Render Pass Scope</a></th>
<th class="tableblock halign-left valign-top"><a href="chap6.html#VkQueueFlagBits">Supported Queue Types</a></th>
<th class="tableblock halign-left valign-top"><a href="chap8.html#synchronization-pipeline-stages-types">Pipeline Type</a></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br>
Secondary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br>
Compute</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="listingblock">
<div class="title">API example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">struct</span> AppDataStructure
{
    VkDescriptorImageInfo  imageInfo;          <span class="comment">// a single image info</span>
    <span class="comment">// ... some more application related data</span>
};

<span class="directive">const</span> VkDescriptorUpdateTemplateEntry descriptorUpdateTemplateEntries[] =
{
    <span class="comment">// binding to a single image descriptor</span>
    {
        <span class="integer">0</span>,                                           <span class="comment">// binding</span>
        <span class="integer">0</span>,                                           <span class="comment">// dstArrayElement</span>
        <span class="integer">1</span>,                                           <span class="comment">// descriptorCount</span>
        VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,   <span class="comment">// descriptorType</span>
        offsetof(AppDataStructure, imageInfo),       <span class="comment">// offset</span>
        <span class="integer">0</span>                                            <span class="comment">// stride is not required if descriptorCount is 1</span>
    }
};

<span class="comment">// create a descriptor update template for descriptor set updates</span>
<span class="directive">const</span> VkDescriptorUpdateTemplateCreateInfo createInfo =
{
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,  <span class="comment">// sType</span>
    <span class="predefined-constant">NULL</span>,                                                      <span class="comment">// pNext</span>
    <span class="integer">0</span>,                                                         <span class="comment">// flags</span>
    <span class="integer">1</span>,                                                         <span class="comment">// descriptorUpdateEntryCount</span>
    descriptorUpdateTemplateEntries,                           <span class="comment">// pDescriptorUpdateEntries</span>
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,   <span class="comment">// templateType</span>
    <span class="integer">0</span>,                                                         <span class="comment">// descriptorSetLayout, ignored by given templateType</span>
    VK_PIPELINE_BIND_POINT_GRAPHICS,                           <span class="comment">// pipelineBindPoint</span>
    myPipelineLayout,                                          <span class="comment">// pipelineLayout</span>
    <span class="integer">0</span>,                                                         <span class="comment">// set</span>
};

VkDescriptorUpdateTemplate myDescriptorUpdateTemplate;
myResult = vkCreateDescriptorUpdateTemplate(
    myDevice,
    &amp;createInfo,
    <span class="predefined-constant">NULL</span>,
    &amp;myDescriptorUpdateTemplate);
}

AppDataStructure appData;
<span class="comment">// fill appData here or cache it in your engine</span>
vkCmdPushDescriptorSetWithTemplateKHR(myCmdBuffer, myDescriptorUpdateTemplate, myPipelineLayout, <span class="integer">0</span>,&amp;appData);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_push_constant_updates"><a class="anchor" href="#_push_constant_updates"></a>14.2.10. Push Constant Updates</h4>
<div id="descriptorsets-push-constants" class="paragraph">
<p>As described above in section <a href="#descriptorsets-pipelinelayout">Pipeline
Layouts</a>, the pipeline layout defines shader push constants which are
updated via Vulkan commands rather than via writes to memory or copy
commands.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Push constants represent a high speed path to modify constant data in
pipelines that is expected to outperform memory-backed resource updates.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To update push constants, call:</p>
</div>
<div id="vkCmdPushConstants" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_VERSION_1_0</span>
<span class="directive">void</span> vkCmdPushConstants(
    VkCommandBuffer                             commandBuffer,
    VkPipelineLayout                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    <span class="directive">const</span> <span class="directive">void</span>*                                 pValues);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>commandBuffer</code> is the command buffer in which the push constant
update will be recorded.</p>
</li>
<li>
<p><code>layout</code> is the pipeline layout used to program the push constant
updates.</p>
</li>
<li>
<p><code>stageFlags</code> is a bitmask of <a href="chap11.html#VkShaderStageFlagBits">VkShaderStageFlagBits</a> specifying
the shader stages that will use the push constants in the updated range.</p>
</li>
<li>
<p><code>offset</code> is the start offset of the push constant range to update,
in units of bytes.</p>
</li>
<li>
<p><code>size</code> is the size of the push constant range to update, in units of
bytes.</p>
</li>
<li>
<p><code>pValues</code> is a pointer to an array of <code>size</code> bytes containing
the new push constant values.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a command buffer begins recording, all push constant values are
undefined.</p>
</div>
<div class="paragraph">
<p>Push constant values <strong class="purple">can</strong> be updated incrementally, causing shader stages in
<code>stageFlags</code> to read the new data from <code>pValues</code> for push constants
modified by this command, while still reading the previous data for push
constants not modified by this command.
When a <a href="chap11.html#pipeline-bindpoint-commands">bound pipeline command</a> is issued,
the bound pipeline’s layout <strong class="purple">must</strong> be compatible with the layouts used to set
the values of all push constants in the pipeline layout’s push constant
ranges, as described in <a href="#descriptorsets-compatibility">Pipeline Layout
Compatibility</a>.
Binding a pipeline with a layout that is not compatible with the push
constant layout does not disturb the push constant values.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>As <code>stageFlags</code> needs to include all flags the relevant push constant
ranges were created with, any flags that are not supported by the queue
family that the <a href="chap7.html#VkCommandPool">VkCommandPool</a> used to allocate <code>commandBuffer</code> was
created on are ignored.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdPushConstants-offset-01795" href="#VUID-vkCmdPushConstants-offset-01795"></a> <span class="vuid">VUID-vkCmdPushConstants-offset-01795</span><br>

For each byte in the range specified by <code>offset</code> and <code>size</code> and
for each shader stage in <code>stageFlags</code>, there <strong class="purple">must</strong> be a push
constant range in <code>layout</code> that includes that byte and that stage</p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-offset-01796" href="#VUID-vkCmdPushConstants-offset-01796"></a> <span class="vuid">VUID-vkCmdPushConstants-offset-01796</span><br>

For each byte in the range specified by <code>offset</code> and <code>size</code> and
for each push constant range that overlaps that byte, <code>stageFlags</code>
<strong class="purple">must</strong> include all stages in that push constant range’s
<a href="#VkPushConstantRange">VkPushConstantRange</a>::<code>stageFlags</code></p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-offset-00368" href="#VUID-vkCmdPushConstants-offset-00368"></a> <span class="vuid">VUID-vkCmdPushConstants-offset-00368</span><br>

<code>offset</code> <strong class="purple">must</strong> be a multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-size-00369" href="#VUID-vkCmdPushConstants-size-00369"></a> <span class="vuid">VUID-vkCmdPushConstants-size-00369</span><br>

<code>size</code> <strong class="purple">must</strong> be a multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-offset-00370" href="#VUID-vkCmdPushConstants-offset-00370"></a> <span class="vuid">VUID-vkCmdPushConstants-offset-00370</span><br>

<code>offset</code> <strong class="purple">must</strong> be less than
<code>VkPhysicalDeviceLimits</code>::<code>maxPushConstantsSize</code></p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-size-00371" href="#VUID-vkCmdPushConstants-size-00371"></a> <span class="vuid">VUID-vkCmdPushConstants-size-00371</span><br>

<code>size</code> <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPushConstantsSize</code> minus
<code>offset</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdPushConstants-commandBuffer-parameter" href="#VUID-vkCmdPushConstants-commandBuffer-parameter"></a> <span class="vuid">VUID-vkCmdPushConstants-commandBuffer-parameter</span><br>
 <code>commandBuffer</code> <strong class="purple">must</strong> be a valid <a href="chap7.html#VkCommandBuffer">VkCommandBuffer</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-layout-parameter" href="#VUID-vkCmdPushConstants-layout-parameter"></a> <span class="vuid">VUID-vkCmdPushConstants-layout-parameter</span><br>
 <code>layout</code> <strong class="purple">must</strong> be a valid <a href="#VkPipelineLayout">VkPipelineLayout</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-stageFlags-parameter" href="#VUID-vkCmdPushConstants-stageFlags-parameter"></a> <span class="vuid">VUID-vkCmdPushConstants-stageFlags-parameter</span><br>
 <code>stageFlags</code> <strong class="purple">must</strong> be a valid combination of <a href="chap11.html#VkShaderStageFlagBits">VkShaderStageFlagBits</a> values</p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-stageFlags-requiredbitmask" href="#VUID-vkCmdPushConstants-stageFlags-requiredbitmask"></a> <span class="vuid">VUID-vkCmdPushConstants-stageFlags-requiredbitmask</span><br>
 <code>stageFlags</code> <strong class="purple">must</strong> not be <code>0</code></p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-pValues-parameter" href="#VUID-vkCmdPushConstants-pValues-parameter"></a> <span class="vuid">VUID-vkCmdPushConstants-pValues-parameter</span><br>
 <code>pValues</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>size</code> bytes</p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-commandBuffer-recording" href="#VUID-vkCmdPushConstants-commandBuffer-recording"></a> <span class="vuid">VUID-vkCmdPushConstants-commandBuffer-recording</span><br>
 <code>commandBuffer</code> <strong class="purple">must</strong> be in the <a href="chap7.html#commandbuffers-lifecycle">recording state</a></p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-commandBuffer-cmdpool" href="#VUID-vkCmdPushConstants-commandBuffer-cmdpool"></a> <span class="vuid">VUID-vkCmdPushConstants-commandBuffer-cmdpool</span><br>
 The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> support graphics, or compute operations</p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-size-arraylength" href="#VUID-vkCmdPushConstants-size-arraylength"></a> <span class="vuid">VUID-vkCmdPushConstants-size-arraylength</span><br>
 <code>size</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-commonparent" href="#VUID-vkCmdPushConstants-commonparent"></a> <span class="vuid">VUID-vkCmdPushConstants-commonparent</span><br>
 Both of <code>commandBuffer</code>, and <code>layout</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap6.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>commandBuffer</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Command Properties</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><a href="chap7.html#VkCommandBufferLevel">Command Buffer Levels</a></th>
<th class="tableblock halign-left valign-top"><a href="chap9.html#vkCmdBeginRenderPass">Render Pass Scope</a></th>
<th class="tableblock halign-left valign-top"><a href="chap6.html#VkQueueFlagBits">Supported Queue Types</a></th>
<th class="tableblock halign-left valign-top"><a href="chap8.html#synchronization-pipeline-stages-types">Pipeline Type</a></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br>
Secondary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br>
Compute</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_physical_storage_buffer_access"><a class="anchor" href="#_physical_storage_buffer_access"></a>14.3. Physical Storage Buffer Access</h3>
<div id="descriptorsets-physical-storage-buffer" class="openblock">
<div class="content">
<div class="paragraph">
<p>To query a 64-bit buffer device address value through which buffer memory
<strong class="purple">can</strong> be accessed in a shader, call:</p>
</div>
<div id="vkGetBufferDeviceAddressKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_buffer_device_address</span>
VkDeviceAddress vkGetBufferDeviceAddressKHR(
    VkDevice                                    device,
    <span class="directive">const</span> VkBufferDeviceAddressInfo*            pInfo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent command</p>
</div>
<div id="vkGetBufferDeviceAddressEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_EXT_buffer_device_address</span>
VkDeviceAddress vkGetBufferDeviceAddressEXT(
    VkDevice                                    device,
    <span class="directive">const</span> VkBufferDeviceAddressInfo*            pInfo);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that the buffer was created on.</p>
</li>
<li>
<p><code>pInfo</code> is a pointer to a <a href="#VkBufferDeviceAddressInfo">VkBufferDeviceAddressInfo</a> structure
specifying the buffer to retrieve an address for.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The 64-bit return value is an address of the start of <code>pInfo-&gt;buffer</code>.
The address range starting at this value and whose size is the size of the
buffer <strong class="purple">can</strong> be used in a shader to access the memory bound to that buffer,
using the
<code>SPV_KHR_physical_storage_buffer</code> extension
<code>SPV_EXT_physical_storage_buffer</code> extension
and the <code>PhysicalStorageBuffer</code> storage class.
For example, this value <strong class="purple">can</strong> be stored in a uniform buffer, and the shader
<strong class="purple">can</strong> read the value from the uniform buffer and use it to do a dependent
read/write to this buffer.
A value of zero is reserved as a “null” pointer and <strong class="purple">must</strong> not be returned
as a valid buffer device address.
All loads, stores, and atomics in a shader through
<code>PhysicalStorageBuffer</code> pointers <strong class="purple">must</strong> access addresses in the address
range of some buffer.</p>
</div>
<div class="paragraph">
<p>If the buffer was created with a non-zero value of
<a href="chap13.html#VkBufferOpaqueCaptureAddressCreateInfo">VkBufferOpaqueCaptureAddressCreateInfo</a>::<code>opaqueCaptureAddress</code>
<a href="chap13.html#VkBufferDeviceAddressCreateInfoEXT">VkBufferDeviceAddressCreateInfoEXT</a>::<code>deviceAddress</code>
the return value will be the same address that was returned at capture time.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetBufferDeviceAddress-bufferDeviceAddress-03324" href="#VUID-vkGetBufferDeviceAddress-bufferDeviceAddress-03324"></a> <span class="vuid">VUID-vkGetBufferDeviceAddress-bufferDeviceAddress-03324</span><br>

The <a href="chap41.html#features-bufferDeviceAddress">bufferDeviceAddress</a> or
<a href="chap41.html#features-bufferDeviceAddressEXT"><code>VkPhysicalDeviceBufferDeviceAddressFeaturesEXT</code>::<code>bufferDeviceAddress</code></a>
feature <strong class="purple">must</strong> be enabled</p>
</li>
<li>
<p><a id="VUID-vkGetBufferDeviceAddress-device-03325" href="#VUID-vkGetBufferDeviceAddress-device-03325"></a> <span class="vuid">VUID-vkGetBufferDeviceAddress-device-03325</span><br>

If <code>device</code> was created with multiple physical devices, then the
<a href="chap41.html#features-bufferDeviceAddressMultiDevice">bufferDeviceAddressMultiDevice</a>
or
<a href="chap41.html#features-bufferDeviceAddressMultiDeviceEXT"><code>VkPhysicalDeviceBufferDeviceAddressFeaturesEXT</code>::<code>bufferDeviceAddressMultiDevice</code></a>
feature <strong class="purple">must</strong> be enabled</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetBufferDeviceAddress-device-parameter" href="#VUID-vkGetBufferDeviceAddress-device-parameter"></a> <span class="vuid">VUID-vkGetBufferDeviceAddress-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkGetBufferDeviceAddress-pInfo-parameter" href="#VUID-vkGetBufferDeviceAddress-pInfo-parameter"></a> <span class="vuid">VUID-vkGetBufferDeviceAddress-pInfo-parameter</span><br>
 <code>pInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkBufferDeviceAddressInfo">VkBufferDeviceAddressInfo</a> structure</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkBufferDeviceAddressInfo</code> structure is defined as:</p>
</div>
<div id="VkBufferDeviceAddressInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkBufferDeviceAddressInfo {
    VkStructureType    sType;
    <span class="directive">const</span> <span class="directive">void</span>*        pNext;
    VkBuffer           buffer;
} VkBufferDeviceAddressInfo;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkBufferDeviceAddressInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_buffer_device_address</span>
<span class="keyword">typedef</span> VkBufferDeviceAddressInfo VkBufferDeviceAddressInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkBufferDeviceAddressInfoEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_EXT_buffer_device_address</span>
<span class="keyword">typedef</span> VkBufferDeviceAddressInfo VkBufferDeviceAddressInfoEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this
structure.</p>
</li>
<li>
<p><code>buffer</code> specifies the buffer whose address is being queried.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkBufferDeviceAddressInfo-buffer-02600" href="#VUID-VkBufferDeviceAddressInfo-buffer-02600"></a> <span class="vuid">VUID-VkBufferDeviceAddressInfo-buffer-02600</span><br>

If <code>buffer</code> is non-sparse and was not created with the
<code>VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT</code> flag, then it
<strong class="purple">must</strong> be bound completely and contiguously to a single
<code>VkDeviceMemory</code> object</p>
</li>
<li>
<p><a id="VUID-VkBufferDeviceAddressInfo-buffer-02601" href="#VUID-VkBufferDeviceAddressInfo-buffer-02601"></a> <span class="vuid">VUID-VkBufferDeviceAddressInfo-buffer-02601</span><br>

<code>buffer</code> <strong class="purple">must</strong> have been created with
<code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkBufferDeviceAddressInfo-sType-sType" href="#VUID-VkBufferDeviceAddressInfo-sType-sType"></a> <span class="vuid">VUID-VkBufferDeviceAddressInfo-sType-sType</span><br>
 <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO</code></p>
</li>
<li>
<p><a id="VUID-VkBufferDeviceAddressInfo-pNext-pNext" href="#VUID-VkBufferDeviceAddressInfo-pNext-pNext"></a> <span class="vuid">VUID-VkBufferDeviceAddressInfo-pNext-pNext</span><br>
 <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkBufferDeviceAddressInfo-buffer-parameter" href="#VUID-VkBufferDeviceAddressInfo-buffer-parameter"></a> <span class="vuid">VUID-VkBufferDeviceAddressInfo-buffer-parameter</span><br>
 <code>buffer</code> <strong class="purple">must</strong> be a valid <a href="chap13.html#VkBuffer">VkBuffer</a> handle</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query a 64-bit buffer opaque capture address, call:</p>
</div>
<div id="vkGetBufferOpaqueCaptureAddressKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Provided by VK_KHR_buffer_device_address</span>
uint64_t vkGetBufferOpaqueCaptureAddressKHR(
    VkDevice                                    device,
    <span class="directive">const</span> VkBufferDeviceAddressInfo*            pInfo);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that the buffer was created on.</p>
</li>
<li>
<p><code>pInfo</code> is a pointer to a <a href="#VkBufferDeviceAddressInfo">VkBufferDeviceAddressInfo</a> structure
specifying the buffer to retrieve an address for.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The 64-bit return value is an opaque capture address of the start of
<code>pInfo-&gt;buffer</code>.</p>
</div>
<div class="paragraph">
<p>If the buffer was created with a non-zero value of
<a href="chap13.html#VkBufferOpaqueCaptureAddressCreateInfo">VkBufferOpaqueCaptureAddressCreateInfo</a>::<code>opaqueCaptureAddress</code> the
return value <strong class="purple">must</strong> be the same address.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetBufferOpaqueCaptureAddress-None-03326" href="#VUID-vkGetBufferOpaqueCaptureAddress-None-03326"></a> <span class="vuid">VUID-vkGetBufferOpaqueCaptureAddress-None-03326</span><br>

The <a href="chap41.html#features-bufferDeviceAddress">bufferDeviceAddress</a> feature <strong class="purple">must</strong>
be enabled</p>
</li>
<li>
<p><a id="VUID-vkGetBufferOpaqueCaptureAddress-device-03327" href="#VUID-vkGetBufferOpaqueCaptureAddress-device-03327"></a> <span class="vuid">VUID-vkGetBufferOpaqueCaptureAddress-device-03327</span><br>

If <code>device</code> was created with multiple physical devices, then the
<a href="chap41.html#features-bufferDeviceAddressMultiDevice">bufferDeviceAddressMultiDevice</a>
feature <strong class="purple">must</strong> be enabled</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetBufferOpaqueCaptureAddress-device-parameter" href="#VUID-vkGetBufferOpaqueCaptureAddress-device-parameter"></a> <span class="vuid">VUID-vkGetBufferOpaqueCaptureAddress-device-parameter</span><br>
 <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap6.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkGetBufferOpaqueCaptureAddress-pInfo-parameter" href="#VUID-vkGetBufferOpaqueCaptureAddress-pInfo-parameter"></a> <span class="vuid">VUID-vkGetBufferOpaqueCaptureAddress-pInfo-parameter</span><br>
 <code>pInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkBufferDeviceAddressInfo">VkBufferDeviceAddressInfo</a> structure</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div id="footer" style="max-width: 100%;">
<div id="footer-text">
Version 1.1.169<br>
Last updated 2021-02-01 22:51:50 -0800
</div>
</div>


</body>
</html>