<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>vkGetPhysicalDeviceFeatures</title><link rel="stylesheet" type="text/css" href="vkman.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /></head><body><div xml:lang="en" class="refentry" lang="en"><a id="id-1"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>vkGetPhysicalDeviceFeatures â€” Reports capabilities of a physical device.</p></div><div class="refsect1"><a id="_c_specification"></a><h2>C Specification</h2><pre class="programlisting">void vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures*                   pFeatures);</pre></div><div class="refsect1"><a id="_parameters"></a><h2>Parameters</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<em class="parameter"><code>physicalDevice</code></em>
</span></dt><dd>
    A handle to the physical device.
</dd><dt><span class="term">
<em class="parameter"><code>pFeatures</code></em>
</span></dt><dd>
    A pointer to a structure that will be written with the device feature set.
</dd></dl></div></div><div class="refsect1"><a id="_description"></a><h2>Description</h2><p><span class="strong"><strong><code class="code">vkGetPhysicalDeviceFeatures</code></strong></span> returns the set of physical features supported by the physical device
whose handle is passed in <em class="parameter"><code>physicalDevice</code></em>. This parameter should be a valid handle to a physical
device returned from a successful call to <code class="code"><a class="ulink" href="vkEnumeratePhysicalDevices.html" target="_top">vkEnumeratePhysicalDevices</a></code>. <em class="parameter"><code>pFeatures</code></em> is a pointer
to an instance of the <span class="type">VkPhysicalDeviceFeatures</span> structure, the definition of which is:</p><pre class="programlisting">typedef struct VkPhysicalDeviceFeatures {
    VkBool32    robustBufferAccess;
    VkBool32    fullDrawIndexUint32;
    VkBool32    imageCubeArray;
    VkBool32    independentBlend;
    VkBool32    geometryShader;
    VkBool32    tessellationShader;
    VkBool32    sampleRateShading;
    VkBool32    dualSrcBlend;
    VkBool32    logicOp;
    VkBool32    multiDrawIndirect;
    VkBool32    drawIndirectFirstInstance;
    VkBool32    depthClamp;
    VkBool32    depthBiasClamp;
    VkBool32    fillModeNonSolid;
    VkBool32    depthBounds;
    VkBool32    wideLines;
    VkBool32    largePoints;
    VkBool32    alphaToOne;
    VkBool32    multiViewport;
    VkBool32    samplerAnisotropy;
    VkBool32    textureCompressionETC2;
    VkBool32    textureCompressionASTC_LDR;
    VkBool32    textureCompressionBC;
    VkBool32    occlusionQueryPrecise;
    VkBool32    pipelineStatisticsQuery;
    VkBool32    vertexPipelineStoresAndAtomics;
    VkBool32    fragmentStoresAndAtomics;
    VkBool32    shaderTessellationAndGeometryPointSize;
    VkBool32    shaderImageGatherExtended;
    VkBool32    shaderStorageImageExtendedFormats;
    VkBool32    shaderStorageImageMultisample;
    VkBool32    shaderStorageImageReadWithoutFormat;
    VkBool32    shaderStorageImageWriteWithoutFormat;
    VkBool32    shaderUniformBufferArrayDynamicIndexing;
    VkBool32    shaderSampledImageArrayDynamicIndexing;
    VkBool32    shaderStorageBufferArrayDynamicIndexing;
    VkBool32    shaderStorageImageArrayDynamicIndexing;
    VkBool32    shaderClipDistance;
    VkBool32    shaderCullDistance;
    VkBool32    shaderFloat64;
    VkBool32    shaderInt64;
    VkBool32    shaderInt16;
    VkBool32    shaderResourceResidency;
    VkBool32    shaderResourceMinLod;
    VkBool32    sparseBinding;
    VkBool32    sparseResidencyBuffer;
    VkBool32    sparseResidencyImage2D;
    VkBool32    sparseResidencyImage3D;
    VkBool32    sparseResidency2Samples;
    VkBool32    sparseResidency4Samples;
    VkBool32    sparseResidency8Samples;
    VkBool32    sparseResidency16Samples;
    VkBool32    sparseResidencyAliased;
    VkBool32    variableMultisampleRate;
    VkBool32    inheritedQueries;
} VkPhysicalDeviceFeatures;</pre><p>Each member of the <em class="parameter"><code>pFeatures</code></em> structure represents a feature of the underlying physical device. A brief
description of the members follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">
<span class="strong"><strong><em class="parameter"><code>robustBufferAccess</code></em></strong></span> indicates that out of bounds accesses to buffers via shader
  operations are well-defined.
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p class="simpara">
When enabled, out-of-bounds buffer reads will return any of the following values:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem">
Values from anywhere within the buffer object.
</li><li class="listitem"><p class="simpara">
Zero values, or (0,0,0,x) vectors for vector reads where x is a valid value
    represented in the type of the vector components and may be any of:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
0, 1, or the maximum representable positive integer value, for signed or unsigned
        integer components
</li><li class="listitem">
0.0 or 1.0, for floating-point components
</li></ul></div></li></ul></div></li><li class="listitem">
When enabled, out-of-bounds writes may modify values within the buffer object or
   be ignored.
</li><li class="listitem">
If not enabled, out of bounds accesses may cause undefined behaviour up-to and including
   process termination.
</li></ul></div></li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>fullDrawIndexUint32</code></em></strong></span> indicates the full 32-bit range of indices is supported for
  indexed draw calls when using a <span class="type"><a class="ulink" href="VkIndexType.html" target="_top">VkIndexType</a></span> of <span class="type">VK_INDEX_TYPE_UINT32</span>.
  The <em class="parameter"><code>maxDrawIndexedIndexValue</code></em> limit indicates the maximum
  index value that may be used (aside from the primitive restart index, which is always
  2<sup>32</sup>-1 when the <span class="type"><a class="ulink" href="VkIndexType.html" target="_top">VkIndexType</a></span> is <span class="type">VK_INDEX_TYPE_UINT32</span>). If this feature
  is supported, <em class="parameter"><code>maxDrawIndexedIndexValue</code></em> must be 2<sup>32</sup>-1; otherwise it must be no
  smaller than 2<sup>24</sup>-1. See <a class="xref" href="#">???</a>.
  <a id="features-features-fullDrawIndexUint"></a>
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>imageCubeArray</code></em></strong></span> indicates whether image views with a <span class="type"><a class="ulink" href="VkImageViewType.html" target="_top">VkImageViewType</a></span> of
  <span class="type">VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</span> can be created and that the corresponding
  <span class="strong"><strong>ImageCubeArray</strong></span> SPIR-V OpCapability can be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>independentBlend</code></em></strong></span> indicates whether the <span class="type">VkPipelineColorBlendAttachmentState</span>
  settings are controlled independently per-attachment. If this is features not supported or
  enabled, the <span class="type">VkPipelineColorBlendAttachmentState</span> settings for the first color attachment
  will be used for all attachments. Otherwise, a <span class="type">VkPipelineColorBlendAttachmentState</span>
  must be provided for each bound color attachment.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>geometryShader</code></em></strong></span> indicates whether geometry shaders are supported. If this feature is not
  supported or enabled, <span class="type">VK_SHADER_STAGE_GEOMETRY_BIT</span>,
  and <span class="type">VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</span> enum values may not be used. This also
  indicates whether the <span class="strong"><strong>Geometry</strong></span> SPIR-V OpCapability can be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>tessellationShader</code></em></strong></span> indicates whether tessellation control and evaluation shaders are supported.
  If this feature is not supported or enabled, the <span class="type">VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT</span>,
  <span class="type">VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT</span>, <span class="type">VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</span>,
  <span class="type">VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</span>, and
  <span class="type">VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO</span> enum values may not be used.
  This also indicates whether the <span class="strong"><strong>Tessellation</strong></span> SPIR-V OpCapability can be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>sampleRateShading</code></em></strong></span> indicates whether per-sample shading and multisample interpolation is supported.
  If this feature is not supported or enabled, the <em class="parameter"><code>sampleShadingEnable</code></em> member of
  the <span class="type"><a class="ulink" href="VkPipelineMultisampleStateCreateInfo.html" target="_top">VkPipelineMultisampleStateCreateInfo</a></span> structure must be set to
  <span class="type">VK_FALSE</span> and the <em class="parameter"><code>minSampleShading</code></em> member is ignored. This also indicates whether
  the <span class="strong"><strong>SampleRateShading</strong></span> SPIR-V OpCapability can be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>dualSourceBlend</code></em></strong></span> indicates whether blend operations which take two sources are supported.
  If this feature is not supported or enabled, the <span class="type">VK_BLEND_FACTOR_SRC1_COLOR</span>,
  <span class="type">VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR</span>, <span class="type">VK_BLEND_FACTOR_SRC1_ALPHA</span>, and <span class="type">VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</span>
  enum values may not be used as source or destination blending factors.
</li><li class="listitem"><p class="simpara">
<span class="strong"><strong><em class="parameter"><code>logicOp</code></em></strong></span> indicates whether logic operations are supported. If this feature is not supported
  or enabled, the <em class="parameter"><code>logicOpEnable</code></em> member of the <span class="type"><a class="ulink" href="VkPipelineColorBlendStateCreateInfo.html" target="_top">VkPipelineColorBlendStateCreateInfo</a></span> structure
  must be set to <span class="type">VK_FALSE</span> and the <em class="parameter"><code>logicOp</code></em> member is ignored.
</p><pre class="literallayout">  [[features-features-multiDrawIndirect]]
* *pname:multiDrawIndirect* indicates whether multi-draw indirect is
  supported. If this feature is not supported or enabled, the
  ptext:drawCount parameter to the flink:vkCmdDrawIndirect and
  flink:vkCmdDrawIndexedIndirect commands must be 1. The
  ptext:maxDrawIndirectCount member of the slink:VkPhysicalDeviceLimits
  structure must also be 1 if this feature is not supported. See
  &lt;&lt;features-limits-maxDrawIndirectCount&gt;&gt;.</pre></li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>depthClamp</code></em></strong></span> indicates whether depth clamping is supported.  If this feature is not supported
  or enabled, the <em class="parameter"><code>depthClampEnable</code></em> member of the <span class="type">VkPipelineRasterizationStateCreateInfo</span> structure
  must be set to <span class="type">VK_FALSE</span>. Otherwise, setting <em class="parameter"><code>depthClampEnable</code></em> to <span class="type">VK_TRUE</span> will
  enable depth clamping.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>depthBiasClamp</code></em></strong></span> indicates whether depth bias clamping is supported. If this feature is not
  supported or enabled, the <em class="parameter"><code>depthBiasClamp</code></em> parameter to <code class="code"><a class="ulink" href="vkCmdSetDepthBias.html" target="_top">vkCmdSetDepthBias</a></code> is ignored.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>fillModeNonSolid</code></em></strong></span> indicates whether point and wireframe fill modes are supported. If this feature
  is not supported or enabled, the <span class="type">VK_POLYGON_MODE_POINT</span> and <span class="type">VK_POLYGON_MODE_LINE</span> enum
  values may not be used.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>depthBounds</code></em></strong></span> indicates whether depth bounds tests are supported. If this feature is not supported
  or enabled, the <em class="parameter"><code>depthBoundsTestEnable</code></em> member of the <span class="type">VkPipelineDepthStencilStateCreateInfo</span>
  structure must be set to <span class="type">VK_FALSE</span>.  When <em class="parameter"><code>depthBoundsTestEnable</code></em> is set to <span class="type">VK_FALSE</span>,
  the values of the <code class="code"><a class="ulink" href="vkCmdSetDepthBounds.html" target="_top">vkCmdSetDepthBounds</a></code> command may not be used.
</li><li class="listitem"><p class="simpara">
<span class="strong"><strong><em class="parameter"><code>wideLines</code></em></strong></span> indicates whether lines with width greater than 1.0 are supported. If this feature is
  not supported or enabled, the <code class="code"><a class="ulink" href="vkCmdSetLineWidth.html" target="_top">vkCmdSetLineWidth</a></code> command may not be used.
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
The range and granularity of supported line widths are indicated by the
  <em class="parameter"><code>lineWidthRange</code></em> and <em class="parameter"><code>lineWidthGranularity</code></em> members of the <span class="type"><a class="ulink" href="VkPhysicalDeviceLimits.html" target="_top">VkPhysicalDeviceLimits</a></span>
  structure, respectively.
</li></ol></div></li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>largePoints</code></em></strong></span> indictates if points with size greater than 1.0 are supported. If this feature
  is not supported or enabled, only a point size of 1.0 written by a shader is supported.
  The range and granularity of supported point sizes are indicated by the <em class="parameter"><code>pointSizeRange</code></em> and
  <em class="parameter"><code>pointSizeGranularity</code></em> members of the <em class="parameter"><code>VkPhysicalDeviceLimits</code></em> structure, respectively.
</li><li class="listitem"><p class="simpara">
<span class="strong"><strong><em class="parameter"><code>textureCompressionETC2</code></em></strong></span> indicates whether the ETC2 and EAC compressed texture formats are
  supported. If this feature is not supported or enabled, the following formats may not be
  used to create images:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
<span class="type">VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_EAC_R11_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_EAC_R11_SNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_EAC_R11G11_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_EAC_R11G11_SNORM_BLOCK</span>
</li></ul></div><p class="simpara">The <span class="strong"><strong><code class="code">vkGetPhysicalDeviceFormatProperties</code></strong></span> command should be used to check
for the supported properties of individual formats.</p></li><li class="listitem"><p class="simpara">
<span class="strong"><strong><em class="parameter"><code>textureCompressionASTC_LDR</code></em></strong></span> indicates whether the ASTC LDR compressed texture formats are
  supported. If this feature is not supported or enabled, the following formats may not be
  used to create images:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
<span class="type">VK_FORMAT_ASTC_4x4_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_4x4_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_5x4_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_5x4_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_5x5_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_5x5_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_6x5_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_6x5_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_6x6_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_6x6_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_8x5_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_8x5_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_8x6_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_8x6_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_8x8_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_8x8_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_10x5_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_10x5_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_10x6_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_10x6_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_10x8_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_10x8_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_10x10_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_10x10_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_12x10_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_12x10_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_12x12_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_ASTC_12x12_SRGB_BLOCK</span>
</li></ul></div><p class="simpara">The <span class="strong"><strong><code class="code">vkGetPhysicalDeviceFormatProperties</code></strong></span> command should be used to check
for the supported properties of individual formats.</p></li><li class="listitem"><p class="simpara">
<span class="strong"><strong><em class="parameter"><code>textureCompressionBC</code></em></strong></span> indicates whether the BC compressed texture formats are supported.
  If this feature is not supported or enabled, the following formats may not be
  used to create images:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
<span class="type">VK_FORMAT_BC1_RGB_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC1_RGB_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC1_RGBA_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC1_RGBA_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC2_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC2_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC3_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC3_SRGB_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC4_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC4_SNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC5_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC5_SNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC6H_UFLOAT_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC6H_SFLOAT_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC7_UNORM_BLOCK</span>
</li><li class="listitem">
<span class="type">VK_FORMAT_BC7_SRGB_BLOCK</span>
</li></ul></div><p class="simpara">The <span class="strong"><strong><code class="code">vkGetPhysicalDeviceFormatProperties</code></strong></span> command should be used to check
for the supported properties of individual formats.</p></li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>occlusionQueryPrecise</code></em></strong></span> indicates whether precise (non-conservative)
  occlusion queries are supported. Occlusion queries are created in a <span class="type">VkQueryPool</span> by
  specifying the <em class="parameter"><code>queryType</code></em> of <span class="type">VK_QUERY_TYPE_OCCLUSION</span> in the <span class="type">VkQueryPoolCreateInfo</span>
  structure which is passed to <span class="strong"><strong><code class="code">vkCreateQueryPool</code></strong></span>. If this feature is supported and enabled,
  queries of this type may set <span class="type">VK_QUERY_CONTROL_PRECISE_BIT</span> in the <em class="parameter"><code>flags</code></em>
  parameter to <span class="strong"><strong><code class="code">vkCmdBeginQuery</code></strong></span>. If this feature is not supported, the implementation can
  only support conservative occlusion queries. When any samples are passed, conservative queries
  will return between one and the actual number of samples passed. When this feature is enabled
  and <span class="type">VK_QUERY_CONTROL_PRECISE_BIT</span> is set, occlusion queries will report the
  actual number of samples passed.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>pipelineStatisticsQuery</code></em></strong></span> indicates whether the pipeline statistics queries are supported.
  If this feature is not supported or enabled, queries of type
  <span class="type">VK_QUERY_TYPE_PIPELINE_STATISTICS</span> cannot be created and none of the
  <span class="type"><a class="ulink" href="VkQueryPipelineStatisticFlagBits.html" target="_top">VkQueryPipelineStatisticFlagBits</a></span> bits should be set in the <em class="parameter"><code>pipelineStatistics</code></em>
  member of the <span class="type">VkQueryPoolCreateInfo</span> structure.
</li><li class="listitem">
<em class="parameter"><code>vertexPipelineStoresAndAtomics</code></em> indicates whether
    storage buffers and images support stores and atomic operations
    in the vertex, tessellation, and geometry shader stages. If this
    feature is not supported or enabled, all storage image, storage texel
    buffers and storage buffer variables in shaders for these
    stages must be decorated with the <span class="strong"><strong>NonWriteable</strong></span> SPIR-V decoration
    (or the <span class="emphasis"><em>readonly</em></span> memory qualifier in GLSL).
    <a id="features-features-fragmentStoresAndAtomics"></a>
</li><li class="listitem">
<em class="parameter"><code>fragmentStoresAndAtomics</code></em> indicates whether storage buffers and
    images support stores and atomic operations in the fragment shader stage.
    If this feature is not supported or enabled, all storage image, storage
    texel buffers and storage buffer variables in shaders for the
    fragment stage must be decorated with the <span class="strong"><strong>NonWriteable</strong></span> SPIR-V decoration
    (or the <span class="emphasis"><em>readonly</em></span> memory qualifier in GLSL).
</li><li class="listitem">
<em class="parameter"><code>shaderTessellationAndGeometryPointSize</code></em> indicates whether the
    <span class="emphasis"><em>PointSize</em></span> shader builtin is available in the tessellation control,
    tessellation evaluation, and geometry shader stages. If this feature is
    not supported or enabled, the <span class="emphasis"><em>PointSize</em></span> shader builtin is not available
    in these shader stages and all points written from a tessellation or
    geometry shader will have a size of 1.0. This also indicates whether
    the <span class="strong"><strong>TessellationPointSize</strong></span> SPIR-V OpCapability can be used in shader
    code for tessellation control and evaluation shaders, or if the
    <span class="strong"><strong>GeometryPointSize</strong></span> SPIR-V OpCapability can be used in shader code
    for geometry shaders. An implementation supporting this feature must
    also support one or both of the <span class="emphasis"><em>tessellationShader</em></span> or
    <span class="emphasis"><em>geometryShader</em></span> features.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>shaderImageGatherExtended</code></em></strong></span> indicates whether the extended set of image gather
  instructions are available in shader code. If this feature is not supported or enabled,
  the <span class="emphasis"><em>textureGatherOffset</em></span> shader instruction only supports offsets that are constant
  integer expressions and the <span class="emphasis"><em>textureGatherOffsets</em></span> shader instruction is not supported.
  This also indicates whether the <span class="strong"><strong>ImageGatherExtended</strong></span> SPIR-V OpCapability can be used in
  shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>shaderStorageImageExtendedFormats</code></em></strong></span> indicates whether the extended storage image
  formats are available in shader code. If this feature is not supported or enabled,
  the formats requiring the <span class="strong"><strong>StorageImageExtendedFormats</strong></span> SPIR-V OpCapability are not
  supported for resources referenced by the <span class="type">VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</span> descriptor
  type. This also indicates whether the <span class="strong"><strong>StorageImageExtendedFormats</strong></span> OpCapability ca
  be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>shaderStorageImageMultisample</code></em></strong></span> indicates whether multisampled storage images are
  supported. If this feature is not supported or enabled, images that are created
  with a <em class="parameter"><code>usage</code></em> that includes <span class="type">VK_IMAGE_USAGE_STORAGE_BIT</span> must be created
  with <em class="parameter"><code>samples</code></em> equal to 1. This also indicates whether the <span class="strong"><strong>StorageImageMultisample</strong></span> SPIR-V
  OpCapability can be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>shaderUniformBufferArrayDynamicIndexing</code></em></strong></span> indicates whether arrays of uniform buffers
  can be indexed by dynamically uniform integer expressions in shader code. If this feature is not
  supported or enabled, resources with a descriptor type of <span class="type">VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</span>
  or <span class="type">VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</span> can only be indexed by constant
  integral expressions when aggregated into arrays in shader code. This corresponds to the
  <span class="strong"><strong>UniformBufferArrayDynamicIndexing</strong></span> SPIR-V OpCapability can be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>shaderSampledImageArrayDynamicIndexing</code></em></strong></span> indicates whether arrays of samplers or sampled images
  can be indexed by dynamically uniform integer expressions in shader code. If this feature is not
  supported or enabled, resources with a descriptor type of <span class="type">VK_DESCRIPTOR_TYPE_SAMPLER</span>,
  <span class="type">VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</span> and <span class="type">VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</span> can
  only be indexed by constant integral expressions when aggregated into arrays in shader code.
  This also indicates whether the <span class="strong"><strong>SampledImageArrayDynamicIndexing</strong></span> SPIR-V OpCapability can be
  used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>shaderStorageBufferArrayDynamicIndexing</code></em></strong></span> indicates whether arrays of storage buffers can
  be indexed by dynamically uniform integer expressions in shader code. If this feature is not
  supported or enabled, resources with a descriptor type of <span class="type">VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</span>
  or <span class="type">VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</span> can only be indexed by constant integral
  expressions when aggregated into arrays in shader code. This corresponds to the
  <span class="strong"><strong>StorageBufferArrayDynamicIndexing</strong></span> SPIR-V OpCapability can be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>shaderStorageImageArrayDynamicIndexing</code></em></strong></span> indicates whether arrays of storage images
  can be indexed by dynamically uniform integer expressions in shader code. If this feature
  is not supported or enabled, resources with a descriptor type of
  <span class="type">VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</span> can only be indexed by constant integral expressions when
  aggregated into arrays in shader code. This also indicates whether the <span class="strong"><strong>StorageImageArrayDynamicIndexing</strong></span>
  SPIR-V OpCapability can be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>shaderClipDistance</code></em></strong></span> indicates whether clip distances are supported in shader code.
  If this feature is not supported or enabled, the <span class="emphasis"><em>ClipDistance</em></span> shader builtin is not available
  in the builtin shader input and output blocks. This also indicates whether the <span class="strong"><strong>ClipDistance</strong></span>
  SPIR-V OpCapability can be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>shaderCullDistance</code></em></strong></span> indicates whether cull distances are suppored in shader code.
  If this feature is not supported or enabled, the <span class="emphasis"><em>CullDistance</em></span> shader builtin is not available
  in the builtin shader input and output blocks. This also indicates whether the <span class="strong"><strong>CullDistance</strong></span>
  SPIR-V OpCapability can be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>shaderFloat64</code></em></strong></span> indicates whether 64-bit floats (doubles) are supported in shader code.
  If this feature is not supported or enabled, the 64-bit floating point types cannot be used in
  shader code. This also indicates whether the <span class="strong"><strong>Float64</strong></span> SPIR-V OpCapability can be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>shaderInt64</code></em></strong></span> indicates whether 64-bit integers (signed and unsigned) are supported in shader
  code.  If this feature is not supported or enabled, the 64-bit integer types cannot be used in
  shader code.  This also indicates whether the <span class="strong"><strong>Int64</strong></span> SPIR-V OpCapability can be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>shaderInt16</code></em></strong></span> indicates whether 16-bit integers (signed and unsigned) are supported in shader
  code. If this feature is not supported or enabled, the 16-bit integer types cannot be used in
  shader code. This also indicates whether the <span class="strong"><strong>Int16</strong></span> SPIR-V OpCapability can be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>shaderResourceResidency</code></em></strong></span> indicates whether image operations that return resource residency
  information are supported in shader code.  If this feature is not supported or enabled,
  the image operations which return resource residency information cannot be used in shader code.
  This also indicates whether the <span class="strong"><strong>SparseResidency</strong></span> SPIR-V OpCapability can be used in shader code.
  The feature requires the <em class="parameter"><code>sparseNonResident</code></em> feature to be supported.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>shaderResourceMinLod</code></em></strong></span> indicates whether image operations that specify the minimum resource
  level-of-detail (LOD) are supported in shader code. If this feature is not supported or enabled,
  the image operations which specify minimum resource LOD cannot be used in shader code.
  This also indicates whether the <span class="strong"><strong>MinLod</strong></span> SPIR-V OpCapability can be used in shader code.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>alphaToOne</code></em></strong></span> indicates whether the implementation is able to replace the alpha value of the color
  fragment output from the fragment shader with the maximum representable alpha value for fixed-point
  colors or 1.0 for floating-point colors. If this feature is not supported or enabled, then the
  <em class="parameter"><code>alphaToOneEnable</code></em> member of the <span class="type">VkPipelineColorBlendAttachmentState</span> structure must be
  set to <span class="type">VK_FALSE</span>. Otherwise setting <em class="parameter"><code>alphaToOneEnable</code></em> to <span class="type">VK_TRUE</span> will enable
  alpha-to-one behaviour.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>sparseBinding</code></em></strong></span> indicates whether resource memory can be managed at opaque page level instead of
  at the object level.  If this feature is not supported or enabled, resource memory can only be
  bound on a per-object basis using the <span class="strong"><strong><code class="code">vkBindBufferMemory</code></strong></span> and <span class="strong"><strong><code class="code">vkBindImageMemory</code></strong></span>
  commands. In this case, buffers and images cannot be created with <span class="type">VK_BUFFER_CREATE_SPARSE_BINDING_BIT</span>
  and <span class="type">VK_IMAGE_CREATE_SPARSE_BINDING_BIT</span> set in the <em class="parameter"><code>flags</code></em> member of the
  <span class="type">VkBufferCreateInfo</span> and <span class="type">VkImageCreateInfo</span> structures, respectively.
  Otherwise resource memory can be managed as described in
  <a class="link" href="#">Sparse Resource Features</a>.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>sparseResidencyBuffer</code></em></strong></span> indicates whether the device can access partially resident
  buffers. If this feature is not supported or enabled, buffers cannot be created with
  <span class="type">VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT</span> set in the <em class="parameter"><code>flags</code></em> member of the
  <span class="type">VkBufferCreateInfo</span> structure.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>sparseResidencyImage2D</code></em></strong></span> indicates whether the device can access partially resident
  2D images with 1 sample per pixel. If this feature is not supported or enabled, images
  with an <em class="parameter"><code>imageType</code></em> of <span class="type">VK_IMAGE_TYPE_2D</span> and <em class="parameter"><code>samples</code></em> of 1
  cannot be created with <span class="type">VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</span> set
  in the <em class="parameter"><code>flags</code></em> member of the <span class="type">VkImageCreateInfo</span> structure.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>sparseResidencyImage3D</code></em></strong></span> indicates whether the device can access partially resident
  3D images. If this feature is not supported or enabled, images with an <em class="parameter"><code>imageType</code></em> of
  <span class="type">VK_IMAGE_TYPE_3D</span> cannot be created with <span class="type">VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</span> set
  in the <em class="parameter"><code>flags</code></em> member of the <span class="type">VkImageCreateInfo</span> structure.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>sparseResidency2Samples</code></em></strong></span> indicates whether the physical device can access partially
  resident 2D images with 2 samples per pixel. If this feature is not supported or enabled, images
  with an <em class="parameter"><code>imageType</code></em> of <span class="type">VK_IMAGE_TYPE_2D</span> and <em class="parameter"><code>samples</code></em> of 2 cannot be created with
  <span class="type">VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</span> set in the <em class="parameter"><code>flags</code></em> member of the <span class="type">VkImageCreateInfo</span>
  structure.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>sparseResidency4Samples</code></em></strong></span> indicates whether the physical device can access partially
  resident 2D images with 4 samples per pixel. If this feature is not supported or enabled, images
  with an <em class="parameter"><code>imageType</code></em> of <span class="type">VK_IMAGE_TYPE_2D</span> and <em class="parameter"><code>samples</code></em> of 4 cannot be created with
  <span class="type">VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</span> set in the <em class="parameter"><code>flags</code></em> member of the
  <span class="type">VkImageCreateInfo</span> structure.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>sparseResidency8Samples</code></em></strong></span> indicates whether the physical device can access partially
  resident 2D images with 8 samples per pixel. If this feature is not supported or enabled, images
  with an <em class="parameter"><code>imageType</code></em> of <span class="type">VK_IMAGE_TYPE_2D</span> and <em class="parameter"><code>samples</code></em> of 8 cannot be created with
  <span class="type">VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</span> set in the <em class="parameter"><code>flags</code></em> member of the
  <span class="type">VkImageCreateInfo</span> structure.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>sparseResidency16Samples</code></em></strong></span> indicates whether the physical device can access partially
  resident 2D images with 16 samples per pixel. If this feature is not supported or enabled, images
  with an <em class="parameter"><code>imageType</code></em> of <span class="type">VK_IMAGE_TYPE_2D</span> and <em class="parameter"><code>samples</code></em> of 16 cannot be created with
  <span class="type">VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</span> set in the <em class="parameter"><code>flags</code></em> member of the
  <span class="type">VkImageCreateInfo</span> structure.
</li><li class="listitem">
<span class="strong"><strong><em class="parameter"><code>sparseResidencyAliased</code></em></strong></span> indicates whether the physical device can correctly access
  data aliased into multiple locations. If this feature is not supported or enabled,
  the <span class="type">VK_BUFFER_CREATE_SPARSE_ALIASED_BIT</span> and <span class="type">VK_IMAGE_CREATE_SPARSE_ALIASED_BIT</span>
  enum values may not be used in <em class="parameter"><code>flags</code></em> members of the <span class="type">VkBufferCreateInfo</span> and
  <span class="type">VkImageCreateInfo</span> structures, respectively.
</li></ul></div></div><div class="refsect1"><a id="_valid_usage"></a><h2>Valid Usage</h2><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>physicalDevice</code></em> <span class="normative">must</span> be a valid <span class="type">VkPhysicalDevice</span> handle
</li><li class="listitem">
<em class="parameter"><code>pFeatures</code></em> <span class="normative">must</span> be a pointer to a <span class="type">VkPhysicalDeviceFeatures</span> structure
</li></ul></div></div><div class="refsect1"><a id="_see_also"></a><h2>See Also</h2><p><code class="code"><a class="ulink" href="vkGetPhysicalDeviceProperties.html" target="_top">vkGetPhysicalDeviceProperties</a></code></p></div><div class="refsect1"><a id="_copyright"></a><h2>Copyright</h2><p>Copyright Â© 2014-2016 Khronos Group. This material may be distributed subject to
the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. <a class="ulink" href="http://opencontent.org/openpub/" target="_top">http://opencontent.org/openpub/</a>.</p></div></div></body></html>