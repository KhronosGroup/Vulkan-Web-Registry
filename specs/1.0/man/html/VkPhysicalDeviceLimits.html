<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="AsciiDoc 8.6.9">
<title>VkPhysicalDeviceLimits(3)</title>
<style type="text/css">
/*
  CSS stylesheet for XHTML produced by DocBook XSL stylesheets.
  Tested with XSL stylesheets 1.61.2, 1.67.2
*/

span.strong {
  font-weight: bold;
}

body blockquote {
  margin-top: .75em;
  line-height: 1.5;
  margin-bottom: .75em;
}

html body {
  margin: 1em 5% 1em 5%;
  font-family: tahoma, veranda, sans-serif;
}

body div {
  margin: 0;
}

h1, h2, h3, h4, h5, h6
{
  color: #527bbd;
  font-family: tahoma, verdana, sans-serif;
}

.type {
  color: #333333;
  font-family: "courier new", monospace;
  /* font-size: 1.2em; */
}

code {
  font-family: "courier new", monospace;
  /* font-size: 1.2em; */
}

div.toc p:first-child,
div.list-of-figures p:first-child,
div.list-of-tables p:first-child,
div.list-of-examples p:first-child,
div.example p.title,
div.sidebar p.title
{
  font-weight: bold;
  color: #527bbd;
  font-family: tahoma, verdana, sans-serif;
  margin-bottom: 0.2em;
}

div.refnamediv
{
  font-weight: bold;
  color: #333377;
}

em.parameter {
  font-style: normal;
  color: #000060;
  font-family: "courier new", monospace;
}

body h1 {
  margin: .0em 0 0 -4%;
  line-height: 1.3;
  border-bottom: 2px solid silver;
}

body h2 {
  margin: 0.5em 0 0 -4%;
  line-height: 1.3;
  border-bottom: 2px solid silver;
}

body h3 {
  margin: .8em 0 0 -3%;
  line-height: 1.3;
}

body h4 {
  margin: .8em 0 0 -3%;
  line-height: 1.3;
}

body h5 {
  margin: .8em 0 0 -2%;
  line-height: 1.3;
}

body h6 {
  margin: .8em 0 0 -1%;
  line-height: 1.3;
}

body hr {
  border: none; /* Broken on IE6 */
}
div.footnotes hr {
  border: 1px solid silver;
}

div.navheader th, div.navheader td, div.navfooter td {
  font-family: sans-serif;
  font-size: 0.9em;
  font-weight: bold;
  color: #527bbd;
}
div.navheader img, div.navfooter img {
  border-style: none;
}
div.navheader a, div.navfooter a {
  font-weight: normal;
}
div.navfooter hr {
  border: 1px solid silver;
}

body td {
  line-height: 1.2
}

body th {
  line-height: 1.2;
}

ol {
  line-height: 1.2;
}

ul, body dir, body menu {
  line-height: 1.2;
}

html {
  margin: 0;
  padding: 0;
}

body h1, body h2, body h3, body h4, body h5, body h6 {
  margin-left: 0
}

body pre {
  margin: 0.5em 10% 0.5em 1em;
  line-height: 1.0;
  color: #333333;
}

tt.literal, code.literal {
  color: navy;
}

.programlisting, .screen {
  border: 1px solid silver;
  background: #f4f4f4;
  margin: 0.5em 10% 0.5em 0;
  padding: 0.5em 1em;
  font-family: "courier new", monospace;
}

div.sidebar {
  background: #ffffee;
  margin: 1.0em 10% 0.5em 0;
  padding: 0.5em 1em;
  border: 1px solid silver;
}
div.sidebar * { padding: 0; }
div.sidebar div { margin: 0; }
div.sidebar p.title {
  margin-top: 0.5em;
  margin-bottom: 0.2em;
}

div.bibliomixed {
  margin: 0.5em 5% 0.5em 1em;
}

div.glossary dt {
  font-weight: bold;
}
div.glossary dd p {
  margin-top: 0.2em;
}

dl {
  margin: .8em 0;
  line-height: 1.2;
}

dt {
  margin-top: 0.5em;
}

dt span.term {
  font-style: normal;
  color: navy;
}

div.variablelist dd p {
  margin-top: 0;
}

div.itemizedlist li, div.orderedlist li {
  margin-left: -0.8em;
  margin-top: 0.5em;
}

ul, ol {
    list-style-position: outside;
}

div.sidebar ul, div.sidebar ol {
    margin-left: 2.8em;
}

div.itemizedlist p.title,
div.orderedlist p.title,
div.variablelist p.title
{
  margin-bottom: -0.8em;
}

div.revhistory table {
  border-collapse: collapse;
  border: none;
}
div.revhistory th {
  border: none;
  color: #527bbd;
  font-family: tahoma, verdana, sans-serif;
}
div.revhistory td {
  border: 1px solid silver;
}

/* Keep TOC and index lines close together. */
div.toc dl, div.toc dt,
div.list-of-figures dl, div.list-of-figures dt,
div.list-of-tables dl, div.list-of-tables dt,
div.indexdiv dl, div.indexdiv dt
{
  line-height: normal;
  margin-top: 0;
  margin-bottom: 0;
}

/*
  Table styling does not work because of overriding attributes in
  generated HTML.
*/
div.table table,
div.informaltable table
{
    margin-left: 0;
    margin-right: 5%;
    margin-bottom: 0.8em;
}
div.informaltable table
{
    margin-top: 0.4em
}
div.table thead,
div.table tfoot,
div.table tbody,
div.informaltable thead,
div.informaltable tfoot,
div.informaltable tbody
{
    /* No effect in IE6. */
    border-top: 3px solid #527bbd;
    border-bottom: 3px solid #527bbd;
}
div.table thead, div.table tfoot,
div.informaltable thead, div.informaltable tfoot
{
    font-weight: bold;
}

div.mediaobject img {
    margin-bottom: 0.8em;
}
div.figure p.title,
div.table p.title
{
  margin-top: 1em;
  margin-bottom: 0.4em;
}

div.calloutlist p
{
  margin-top: 0em;
  margin-bottom: 0.4em;
}

@media print {
  div.navheader, div.navfooter { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
    <script type="text/x-mathjax-config">
	MathJax.Hub.Config({
	    MathML: { extensions: ["content-mathml.js"] },
	    tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] }
	});
    </script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>
<body class="manpage" style="max-width:1024px">
<div id="header">
<h1>
VkPhysicalDeviceLimits(3) Manual Page
</h1>
<h2>NAME</h2>
<div class="sectionbody">
<p>VkPhysicalDeviceLimits -
   Structure
</p>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_c_specification">C Specification</h2>
<div class="sectionbody">
<div class="paragraph"><p>The <code>VkPhysicalDeviceLimits</code> structure is defined as:</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight 3.1.7
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #0000FF">typedef</span></span> <span style="font-weight: bold"><span style="color: #0000FF">struct</span></span> <span style="color: #008080">VkPhysicalDeviceLimits</span> <span style="color: #FF0000">{</span>
    <span style="color: #008080">uint32_t</span>              maxImageDimension1D<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxImageDimension2D<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxImageDimension3D<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxImageDimensionCube<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxImageArrayLayers<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxTexelBufferElements<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxUniformBufferRange<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxStorageBufferRange<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxPushConstantsSize<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxMemoryAllocationCount<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxSamplerAllocationCount<span style="color: #990000">;</span>
    <span style="color: #008080">VkDeviceSize</span>          bufferImageGranularity<span style="color: #990000">;</span>
    <span style="color: #008080">VkDeviceSize</span>          sparseAddressSpaceSize<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxBoundDescriptorSets<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxPerStageDescriptorSamplers<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxPerStageDescriptorUniformBuffers<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxPerStageDescriptorStorageBuffers<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxPerStageDescriptorSampledImages<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxPerStageDescriptorStorageImages<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxPerStageDescriptorInputAttachments<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxPerStageResources<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxDescriptorSetSamplers<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxDescriptorSetUniformBuffers<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxDescriptorSetUniformBuffersDynamic<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxDescriptorSetStorageBuffers<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxDescriptorSetStorageBuffersDynamic<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxDescriptorSetSampledImages<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxDescriptorSetStorageImages<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxDescriptorSetInputAttachments<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxVertexInputAttributes<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxVertexInputBindings<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxVertexInputAttributeOffset<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxVertexInputBindingStride<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxVertexOutputComponents<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxTessellationGenerationLevel<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxTessellationPatchSize<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxTessellationControlPerVertexInputComponents<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxTessellationControlPerVertexOutputComponents<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxTessellationControlPerPatchOutputComponents<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxTessellationControlTotalOutputComponents<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxTessellationEvaluationInputComponents<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxTessellationEvaluationOutputComponents<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxGeometryShaderInvocations<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxGeometryInputComponents<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxGeometryOutputComponents<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxGeometryOutputVertices<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxGeometryTotalOutputComponents<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxFragmentInputComponents<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxFragmentOutputAttachments<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxFragmentDualSrcAttachments<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxFragmentCombinedOutputResources<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxComputeSharedMemorySize<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxComputeWorkGroupCount<span style="color: #990000">[</span><span style="color: #993399">3</span><span style="color: #990000">];</span>
    <span style="color: #008080">uint32_t</span>              maxComputeWorkGroupInvocations<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxComputeWorkGroupSize<span style="color: #990000">[</span><span style="color: #993399">3</span><span style="color: #990000">];</span>
    <span style="color: #008080">uint32_t</span>              subPixelPrecisionBits<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              subTexelPrecisionBits<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              mipmapPrecisionBits<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxDrawIndexedIndexValue<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxDrawIndirectCount<span style="color: #990000">;</span>
    <span style="color: #009900">float</span>                 maxSamplerLodBias<span style="color: #990000">;</span>
    <span style="color: #009900">float</span>                 maxSamplerAnisotropy<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxViewports<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxViewportDimensions<span style="color: #990000">[</span><span style="color: #993399">2</span><span style="color: #990000">];</span>
    <span style="color: #009900">float</span>                 viewportBoundsRange<span style="color: #990000">[</span><span style="color: #993399">2</span><span style="color: #990000">];</span>
    <span style="color: #008080">uint32_t</span>              viewportSubPixelBits<span style="color: #990000">;</span>
    <span style="color: #008080">size_t</span>                minMemoryMapAlignment<span style="color: #990000">;</span>
    <span style="color: #008080">VkDeviceSize</span>          minTexelBufferOffsetAlignment<span style="color: #990000">;</span>
    <span style="color: #008080">VkDeviceSize</span>          minUniformBufferOffsetAlignment<span style="color: #990000">;</span>
    <span style="color: #008080">VkDeviceSize</span>          minStorageBufferOffsetAlignment<span style="color: #990000">;</span>
    <span style="color: #008080">int32_t</span>               minTexelOffset<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxTexelOffset<span style="color: #990000">;</span>
    <span style="color: #008080">int32_t</span>               minTexelGatherOffset<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxTexelGatherOffset<span style="color: #990000">;</span>
    <span style="color: #009900">float</span>                 minInterpolationOffset<span style="color: #990000">;</span>
    <span style="color: #009900">float</span>                 maxInterpolationOffset<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              subPixelInterpolationOffsetBits<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxFramebufferWidth<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxFramebufferHeight<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxFramebufferLayers<span style="color: #990000">;</span>
    <span style="color: #008080">VkSampleCountFlags</span>    framebufferColorSampleCounts<span style="color: #990000">;</span>
    <span style="color: #008080">VkSampleCountFlags</span>    framebufferDepthSampleCounts<span style="color: #990000">;</span>
    <span style="color: #008080">VkSampleCountFlags</span>    framebufferStencilSampleCounts<span style="color: #990000">;</span>
    <span style="color: #008080">VkSampleCountFlags</span>    framebufferNoAttachmentsSampleCounts<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxColorAttachments<span style="color: #990000">;</span>
    <span style="color: #008080">VkSampleCountFlags</span>    sampledImageColorSampleCounts<span style="color: #990000">;</span>
    <span style="color: #008080">VkSampleCountFlags</span>    sampledImageIntegerSampleCounts<span style="color: #990000">;</span>
    <span style="color: #008080">VkSampleCountFlags</span>    sampledImageDepthSampleCounts<span style="color: #990000">;</span>
    <span style="color: #008080">VkSampleCountFlags</span>    sampledImageStencilSampleCounts<span style="color: #990000">;</span>
    <span style="color: #008080">VkSampleCountFlags</span>    storageImageSampleCounts<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxSampleMaskWords<span style="color: #990000">;</span>
    <span style="color: #008080">VkBool32</span>              timestampComputeAndGraphics<span style="color: #990000">;</span>
    <span style="color: #009900">float</span>                 timestampPeriod<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxClipDistances<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxCullDistances<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              maxCombinedClipAndCullDistances<span style="color: #990000">;</span>
    <span style="color: #008080">uint32_t</span>              discreteQueuePriorities<span style="color: #990000">;</span>
    <span style="color: #009900">float</span>                 pointSizeRange<span style="color: #990000">[</span><span style="color: #993399">2</span><span style="color: #990000">];</span>
    <span style="color: #009900">float</span>                 lineWidthRange<span style="color: #990000">[</span><span style="color: #993399">2</span><span style="color: #990000">];</span>
    <span style="color: #009900">float</span>                 pointSizeGranularity<span style="color: #990000">;</span>
    <span style="color: #009900">float</span>                 lineWidthGranularity<span style="color: #990000">;</span>
    <span style="color: #008080">VkBool32</span>              strictLines<span style="color: #990000">;</span>
    <span style="color: #008080">VkBool32</span>              standardSampleLocations<span style="color: #990000">;</span>
    <span style="color: #008080">VkDeviceSize</span>          optimalBufferCopyOffsetAlignment<span style="color: #990000">;</span>
    <span style="color: #008080">VkDeviceSize</span>          optimalBufferCopyRowPitchAlignment<span style="color: #990000">;</span>
    <span style="color: #008080">VkDeviceSize</span>          nonCoherentAtomSize<span style="color: #990000">;</span>
<span style="color: #FF0000">}</span> VkPhysicalDeviceLimits<span style="color: #990000">;</span></tt></pre></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_members">Members</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
<a id="features-limits-maxImageDimension1D"></a> <code>maxImageDimension1D</code> is the
    maximum dimension (<code>width</code>) of an image created with an
    <code>imageType</code> of <code>VK_IMAGE_TYPE_1D</code>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxImageDimension2D"></a> <code>maxImageDimension2D</code> is the
    maximum dimension (<code>width</code> or <code>height</code>) of an image created with
    an <code>imageType</code> of <code>VK_IMAGE_TYPE_2D</code> and without
    <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code> set in <code>flags</code>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxImageDimension3D"></a> <code>maxImageDimension3D</code> is the
    maximum dimension (<code>width</code>, <code>height</code>, or <code>depth</code>) of an
    image created with an <code>imageType</code> of <code>VK_IMAGE_TYPE_3D</code>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxImageDimensionCube"></a> <code>maxImageDimensionCube</code> is
    the maximum dimension (<code>width</code> or <code>height</code>) of an image created
    with an <code>imageType</code> of <code>VK_IMAGE_TYPE_2D</code> and with
    <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code> set in <code>flags</code>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxImageArrayLayers"></a> <code>maxImageArrayLayers</code> is the
    maximum number of layers (<code>arrayLayers</code>) for an image.
</p>
</li>
<li>
<p>
<a id="features-limits-maxTexelBufferElements"></a> <code>maxTexelBufferElements</code>
    is the maximum number of addressable texels for a buffer view created on
    a buffer which was created with the
    <code>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</code> or
    <code>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</code> set in the <code>usage</code>
    member of the <code>VkBufferCreateInfo</code> structure.
</p>
</li>
<li>
<p>
<a id="features-limits-maxUniformBufferRange"></a> <code>maxUniformBufferRange</code> is
    the maximum value that <span role="normative">can</span> be specified in the <code>range</code> member of
    any <code><a href="VkDescriptorBufferInfo.html">VkDescriptorBufferInfo</a></code> structures passed to a call to
    <code><a href="vkUpdateDescriptorSets.html">vkUpdateDescriptorSets</a></code> for descriptors of type
    <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or
    <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxStorageBufferRange"></a> <code>maxStorageBufferRange</code> is
    the maximum value that <span role="normative">can</span> be specified in the <code>range</code> member of
    any <code><a href="VkDescriptorBufferInfo.html">VkDescriptorBufferInfo</a></code> structures passed to a call to
    <code><a href="vkUpdateDescriptorSets.html">vkUpdateDescriptorSets</a></code> for descriptors of type
    <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or
    <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxPushConstantsSize"></a> <code>maxPushConstantsSize</code> is
    the maximum size, in bytes, of the pool of push constant memory. For
    each of the push constant ranges indicated by the
    <code>pPushConstantRanges</code> member of the <code>VkPipelineLayoutCreateInfo</code>
    structure, <code>offset</code> + <code>size</code> <span role="normative">must</span> be less than or equal to this
    limit.
</p>
</li>
<li>
<p>
<a id="features-limits-maxMemoryAllocationCount"></a>
    <code>maxMemoryAllocationCount</code> is the maximum number of device memory
    allocations, as created by <code><a href="vkAllocateMemory.html">vkAllocateMemory</a></code>, which <span role="normative">can</span>
    simultaneously exist.
</p>
</li>
<li>
<p>
<a id="features-limits-maxSamplerAllocationCount"></a>
    <code>maxSamplerAllocationCount</code> is the maximum number of sampler
    objects, as created by <code><a href="vkCreateSampler.html">vkCreateSampler</a></code>, which <span role="normative">can</span> simultaneously
    exist on a device.
</p>
</li>
<li>
<p>
<a id="features-limits-bufferImageGranularity"></a> <code>bufferImageGranularity</code>
    is the granularity, in bytes, at which buffer or linear image resources,
    and optimal image resources <span role="normative">can</span> be bound to adjacent offsets in the same
    <code>VkDeviceMemory</code> object without aliasing. See
    <a href="#resources-bufferimagegranularity">Buffer-Image Granularity</a> for more
    details.
</p>
</li>
<li>
<p>
<a id="features-limits-sparseAddressSpaceSize"></a> <code>sparseAddressSpaceSize</code>
    is the total amount of address space available, in bytes, for sparse
    memory resources. This is an upper bound on the sum of the size of all
    sparse resources, regardless of whether any memory is bound to them.
</p>
</li>
<li>
<p>
<a id="features-limits-maxBoundDescriptorSets"></a> <code>maxBoundDescriptorSets</code>
    is the maximum number of descriptor sets that <span role="normative">can</span> be simultaneously
    used by a pipeline. All <code>DescriptorSet</code> decorations in shader modules
    <span role="normative">must</span> have a value less than <code>maxBoundDescriptorSets</code>. See
    <a href="#descriptorsets-sets">[descriptorsets-sets]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxPerStageDescriptorSamplers"></a>
    <code>maxPerStageDescriptorSamplers</code> is the maximum number of samplers
    that <span role="normative">can</span> be accessible to a single shader stage in a pipeline layout.
    Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> or
    <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> count against this
    limit. A descriptor is accessible to a shader stage when the
    <code>stageFlags</code> member of the <code>VkDescriptorSetLayoutBinding</code>
    structure has the bit for that shader stage set. See
    <a href="#descriptorsets-sampler">[descriptorsets-sampler]</a> and <a href="#descriptorsets-combinedimagesampler">[descriptorsets-combinedimagesampler]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxPerStageDescriptorUniformBuffers"></a>
    <code>maxPerStageDescriptorUniformBuffers</code> is the maximum number of
    uniform buffers that <span role="normative">can</span> be accessible to a single shader stage in a
    pipeline layout. Descriptors with a type of
    <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or
    <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> count against this
    limit. A descriptor is accessible to a shader stage when the
    <code>stageFlags</code> member of the <code>VkDescriptorSetLayoutBinding</code>
    structure has the bit for that shader stage set. See
    <a href="#descriptorsets-uniformbuffer">[descriptorsets-uniformbuffer]</a> and
    <a href="#descriptorsets-uniformbufferdynamic">[descriptorsets-uniformbufferdynamic]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxPerStageDescriptorStorageBuffers"></a>
    <code>maxPerStageDescriptorStorageBuffers</code> is the maximum number of
    storage buffers that <span role="normative">can</span> be accessible to a single shader stage in a
    pipeline layout. Descriptors with a type of
    <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or
    <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> count against this
    limit. A descriptor is accessible to a pipeline shader stage when the
    <code>stageFlags</code> member of the <code>VkDescriptorSetLayoutBinding</code>
    structure has the bit for that shader stage set. See
    <a href="#descriptorsets-storagebuffer">[descriptorsets-storagebuffer]</a> and
    <a href="#descriptorsets-storagebufferdynamic">[descriptorsets-storagebufferdynamic]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxPerStageDescriptorSampledImages"></a>
    <code>maxPerStageDescriptorSampledImages</code> is the maximum number of
    sampled images that <span role="normative">can</span> be accessible to a single shader stage in a
    pipeline layout. Descriptors with a type of
    <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
    <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, or
    <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> count against this limit.
    A descriptor is accessible to a pipeline shader stage when the
    <code>stageFlags</code> member of the <code>VkDescriptorSetLayoutBinding</code>
    structure has the bit for that shader stage set. See
    <a href="#descriptorsets-combinedimagesampler">[descriptorsets-combinedimagesampler]</a>,
    <a href="#descriptorsets-sampledimage">[descriptorsets-sampledimage]</a>, and
    <a href="#descriptorsets-uniformtexelbuffer">[descriptorsets-uniformtexelbuffer]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxPerStageDescriptorStorageImages"></a>
    <code>maxPerStageDescriptorStorageImages</code> is the maximum number of
    storage images that <span role="normative">can</span> be accessible to a single shader stage in a
    pipeline layout. Descriptors with a type of
    <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, or
    <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> count against this limit.
    A descriptor is accessible to a pipeline shader stage when the
    <code>stageFlags</code> member of the <code>VkDescriptorSetLayoutBinding</code>
    structure has the bit for that shader stage set. See
    <a href="#descriptorsets-storageimage">[descriptorsets-storageimage]</a>, and
    <a href="#descriptorsets-storagetexelbuffer">[descriptorsets-storagetexelbuffer]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxPerStageDescriptorInputAttachments"></a>
    <code>maxPerStageDescriptorInputAttachments</code> is the maximum number of
    input attachments that <span role="normative">can</span> be accessible to a single shader stage in a
    pipeline layout. Descriptors with a type of
    <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> count against this limit.
    A descriptor is accessible to a pipeline shader stage when the
    <code>stageFlags</code> member of the <code>VkDescriptorSetLayoutBinding</code>
    structure has the bit for that shader stage set. These are only
    supported for the fragment stage. See
    <a href="#descriptorsets-inputattachment">[descriptorsets-inputattachment]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxPerStageResources"></a> <code>maxPerStageResources</code> is
    the maximum number of resources that <span role="normative">can</span> be accessible to a single
    shader stage in a pipeline layout. Descriptors with a type of
    <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
    <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>,
    <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>,
    <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>,
    <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>,
    <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>,
    <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>,
    <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>,
    <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, or
    <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> count against this limit. For
    the fragment shader stage the framebuffer color attachments also count
    against this limit.
</p>
</li>
<li>
<p>
<a id="features-limits-maxDescriptorSetSamplers"></a>
    <code>maxDescriptorSetSamplers</code> is the maximum number of samplers that
    <span role="normative">can</span> be included in descriptor bindings in a pipeline layout across all
    pipeline shader stages and descriptor set numbers. Descriptors with a
    type of <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> or
    <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> count against this
    limit. See <a href="#descriptorsets-sampler">[descriptorsets-sampler]</a> and
    <a href="#descriptorsets-combinedimagesampler">[descriptorsets-combinedimagesampler]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxDescriptorSetUniformBuffers"></a>
    <code>maxDescriptorSetUniformBuffers</code> is the maximum number of uniform
    buffers that <span role="normative">can</span> be included in descriptor bindings in a pipeline
    layout across all pipeline shader stages and descriptor set numbers.
    Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or
    <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> count against this
    limit. See <a href="#descriptorsets-uniformbuffer">[descriptorsets-uniformbuffer]</a> and
    <a href="#descriptorsets-uniformbufferdynamic">[descriptorsets-uniformbufferdynamic]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxDescriptorSetUniformBuffersDynamic"></a>
    <code>maxDescriptorSetUniformBuffersDynamic</code> is the maximum number of
    dynamic uniform buffers that <span role="normative">can</span> be included in descriptor bindings in
    a pipeline layout across all pipeline shader stages and descriptor set
    numbers. Descriptors with a type of
    <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> count against this
    limit. See <a href="#descriptorsets-uniformbufferdynamic">[descriptorsets-uniformbufferdynamic]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxDescriptorSetStorageBuffers"></a>
    <code>maxDescriptorSetStorageBuffers</code> is the maximum number of storage
    buffers that <span role="normative">can</span> be included in descriptor bindings in a pipeline
    layout across all pipeline shader stages and descriptor set numbers.
    Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or
    <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> count against this
    limit. See <a href="#descriptorsets-storagebuffer">[descriptorsets-storagebuffer]</a> and
    <a href="#descriptorsets-storagebufferdynamic">[descriptorsets-storagebufferdynamic]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxDescriptorSetStorageBuffersDynamic"></a>
    <code>maxDescriptorSetStorageBuffersDynamic</code> is the maximum number of
    dynamic storage buffers that <span role="normative">can</span> be included in descriptor bindings
    in a pipeline layout across all pipeline shader stages and descriptor
    set numbers. Descriptors with a type of
    <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> count against this
    limit. See <a href="#descriptorsets-storagebufferdynamic">[descriptorsets-storagebufferdynamic]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxDescriptorSetSampledImages"></a>
    <code>maxDescriptorSetSampledImages</code> is the maximum number of sampled
    images that <span role="normative">can</span> be included in descriptor bindings in a pipeline
    layout across all pipeline shader stages and descriptor set numbers.
    Descriptors with a type of
    <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
    <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, or
    <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> count against this limit.
    See <a href="#descriptorsets-combinedimagesampler">[descriptorsets-combinedimagesampler]</a>,
    <a href="#descriptorsets-sampledimage">[descriptorsets-sampledimage]</a>, and
    <a href="#descriptorsets-uniformtexelbuffer">[descriptorsets-uniformtexelbuffer]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxDescriptorSetStorageImages"></a>
    <code>maxDescriptorSetStorageImages</code> is the maximum number of storage
    images that <span role="normative">can</span> be included in descriptor bindings in a pipeline
    layout across all pipeline shader stages and descriptor set numbers.
    Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, or
    <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> count against this limit.
    See <a href="#descriptorsets-storageimage">[descriptorsets-storageimage]</a>, and
    <a href="#descriptorsets-storagetexelbuffer">[descriptorsets-storagetexelbuffer]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxDescriptorSetInputAttachments"></a>
    <code>maxDescriptorSetInputAttachments</code> is the maximum number of input
    attachments that <span role="normative">can</span> be included in descriptor bindings in a
    pipeline layout across all pipeline shader stages and descriptor set
    numbers. Descriptors with a type of
    <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> count against this limit. See
    <a href="#descriptorsets-inputattachment">[descriptorsets-inputattachment]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxVertexInputAttributes"></a>
    <code>maxVertexInputAttributes</code> is the maximum number of vertex input
    attributes that <span role="normative">can</span> be specified for a graphics pipeline. These are
    described in the array of <code>VkVertexInputAttributeDescription</code>
    structures that are provided at graphics pipeline creation time via the
    <code>pVertexAttributeDescriptions</code> member of the
    <code>VkPipelineVertexInputStateCreateInfo</code> structure. See
    <a href="#fxvertex-attrib">[fxvertex-attrib]</a> and <a href="#fxvertex-input">[fxvertex-input]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxVertexInputBindings"></a>
    <code>maxVertexInputBindings</code> is the maximum number of vertex buffers
    that <span role="normative">can</span> be specified for providing vertex attributes to a graphics
    pipeline. These are described in the array of
    <code>VkVertexInputBindingDescription</code> structures that are provided at
    graphics pipeline creation time via the <code>pVertexBindingDescriptions</code>
    member of the <code>VkPipelineVertexInputStateCreateInfo</code> structure. The
    <code>binding</code> member of <code>VkVertexInputBindingDescription</code> <span role="normative">must</span> be
    less than this limit. See <a href="#fxvertex-input">[fxvertex-input]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxVertexInputAttributeOffset"></a>
    <code>maxVertexInputAttributeOffset</code> is the maximum vertex input
    attribute offset that <span role="normative">can</span> be added to the vertex input binding stride.
    The <code>offset</code> member of the <code>VkVertexInputAttributeDescription</code>
    structure <span role="normative">must</span> be less than or equal to this limit. See
    <a href="#fxvertex-input">[fxvertex-input]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxVertexInputBindingStride"></a>
    <code>maxVertexInputBindingStride</code> is the maximum vertex input binding
    stride that <span role="normative">can</span> be specified in a vertex input binding. The
    <code>stride</code> member of the <code>VkVertexInputBindingDescription</code>
    structure <span role="normative">must</span> be less than or equal to this limit. See
    <a href="#fxvertex-input">[fxvertex-input]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxVertexOutputComponents"></a>
    <code>maxVertexOutputComponents</code> is the maximum number of components of
    output variables which <span role="normative">can</span> be output by a vertex shader. See
    <a href="#shaders-vertex">[shaders-vertex]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxTessellationGenerationLevel"></a>
    <code>maxTessellationGenerationLevel</code> is the maximum tessellation
    generation level supported by the fixed-function tessellation primitive
    generator. See <a href="#tessellation">[tessellation]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxTessellationPatchSize"></a>
    <code>maxTessellationPatchSize</code> is the maximum patch size, in vertices,
    of patches that <span role="normative">can</span> be processed by the tessellation control shader and
    tessellation primitive generator. The
    <code>patchControlPoints</code> member of the
    <code>VkPipelineTessellationStateCreateInfo</code> structure specified at
    pipeline creation time and the value provided in the <code>OutputVertices</code>
    execution mode of shader modules <span role="normative">must</span> be less than or equal to this
    limit. See <a href="#tessellation">[tessellation]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxTessellationControlPerVertexInputComponents"></a>
    <code>maxTessellationControlPerVertexInputComponents</code> is the maximum
    number of components of input variables which <span role="normative">can</span> be provided as
    per-vertex inputs to the tessellation control shader stage.
</p>
</li>
<li>
<p>
<a id="features-limits-maxTessellationControlPerVertexOutputComponents"></a>
    <code>maxTessellationControlPerVertexOutputComponents</code> is the maximum
    number of components of per-vertex output variables which <span role="normative">can</span> be output
    from the tessellation control shader stage.
</p>
</li>
<li>
<p>
<a id="features-limits-maxTessellationControlPerPatchOutputComponents"></a>
    <code>maxTessellationControlPerPatchOutputComponents</code> is the maximum
    number of components of per-patch output variables which <span role="normative">can</span> be output
    from the tessellation control shader stage.
</p>
</li>
<li>
<p>
<a id="features-limits-maxTessellationControlTotalOutputComponents"></a>
    <code>maxTessellationControlTotalOutputComponents</code> is the maximum total
    number of components of per-vertex and per-patch output variables which
    <span role="normative">can</span> be output from the tessellation control shader stage.
</p>
</li>
<li>
<p>
<a id="features-limits-maxTessellationEvaluationInputComponents"></a>
    <code>maxTessellationEvaluationInputComponents</code> is the maximum number of
    components of input variables which <span role="normative">can</span> be provided as per-vertex
    inputs to the tessellation evaluation shader stage.
</p>
</li>
<li>
<p>
<a id="features-limits-maxTessellationEvaluationOutputComponents"></a>
    <code>maxTessellationEvaluationOutputComponents</code> is the maximum number of
    components of per-vertex output variables which <span role="normative">can</span> be output from the
    tessellation evaluation shader stage.
</p>
</li>
<li>
<p>
<a id="features-limits-maxGeometryShaderInvocations"></a>
    <code>maxGeometryShaderInvocations</code> is the maximum invocation count
    supported for instanced geometry shaders. The value provided in the
    <code>Invocations</code> execution mode of shader modules <span role="normative">must</span> be less than
    or equal to this limit. See <a href="#geometry">[geometry]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxGeometryInputComponents"></a>
    <code>maxGeometryInputComponents</code> is the maximum number of components of
    input variables which <span role="normative">can</span> be provided as inputs to the geometry shader
    stage.
</p>
</li>
<li>
<p>
<a id="features-limits-maxGeometryOutputComponents"></a>
    <code>maxGeometryOutputComponents</code> is the maximum number of components of
    output variables which <span role="normative">can</span> be output from the geometry shader stage.
</p>
</li>
<li>
<p>
<a id="features-limits-maxGeometryOutputVertices"></a>
    <code>maxGeometryOutputVertices</code> is the maximum number of vertices which
    <span role="normative">can</span> be emitted by any geometry shader.
</p>
</li>
<li>
<p>
<a id="features-limits-maxGeometryTotalOutputComponents"></a>
    <code>maxGeometryTotalOutputComponents</code> is the maximum total number of
    components of output, across all emitted vertices, which <span role="normative">can</span> be output
    from the geometry shader stage.
</p>
</li>
<li>
<p>
<a id="features-limits-maxFragmentInputComponents"></a>
    <code>maxFragmentInputComponents</code> is the maximum number of components of
    input variables which <span role="normative">can</span> be provided as inputs to the fragment shader
    stage.
</p>
</li>
<li>
<p>
<a id="features-limits-maxFragmentOutputAttachments"></a>
    <code>maxFragmentOutputAttachments</code> is the maximum number of output
    attachments which <span role="normative">can</span> be written to by the fragment shader stage.
</p>
</li>
<li>
<p>
<a id="features-limits-maxFragmentDualSrcAttachments"></a>
    <code>maxFragmentDualSrcAttachments</code> is the maximum number of output
    attachments which <span role="normative">can</span> be written to by the fragment shader stage when
    blending is enabled and one of the dual source blend modes is in use.
    See <a href="#framebuffer-dsb">[framebuffer-dsb]</a> and
    <a href="#features-features-dualSrcBlend">dualSrcBlend</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxFragmentCombinedOutputResources"></a>
    <code>maxFragmentCombinedOutputResources</code> is the total number of storage
    buffers, storage images, and output buffers which <span role="normative">can</span> be used in the
    fragment shader stage.
</p>
</li>
<li>
<p>
<a id="features-limits-maxComputeSharedMemorySize"></a>
    <code>maxComputeSharedMemorySize</code> is the maximum total storage size, in
    bytes, of all variables declared with the <code>WorkgroupLocal</code> storage
    class in shader modules (or with the <code>shared</code> storage qualifier in
    GLSL) in the compute shader stage.
</p>
</li>
<li>
<p>
<a id="features-limits-maxComputeWorkGroupCount"></a>
    <code>maxComputeWorkGroupCount</code>[3] is the maximum number of local workgroups
    that <span role="normative">can</span> be dispatched by a single dispatch command. These three values
    represent the maximum number of local workgroups for the X, Y, and Z
    dimensions, respectively. The <code>x</code>, <code>y</code>, and <code>z</code> parameters
    to the <code><a href="vkCmdDispatch.html">vkCmdDispatch</a></code> command, or members of the
    <code><a href="VkDispatchIndirectCommand.html">VkDispatchIndirectCommand</a></code> structure <span role="normative">must</span> be less than or equal to
    the corresponding limit. See <a href="#dispatch">[dispatch]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxComputeWorkGroupInvocations"></a>
    <code>maxComputeWorkGroupInvocations</code> is the maximum total number of
    compute shader invocations in a single local workgroup. The product of
    the X, Y, and Z sizes as specified by the <code>LocalSize</code> execution mode
    in shader modules and by the object decorated by the <code>WorkgroupSize</code>
    decoration <span role="normative">must</span> be less than or equal to this limit.
</p>
</li>
<li>
<p>
<a id="features-limits-maxComputeWorkGroupSize"></a>
    <code>maxComputeWorkGroupSize</code>[3] is the maximum size of a local compute
    workgroup, per dimension. These three values represent the maximum
    local workgroup size in the X, Y, and Z dimensions, respectively. The
    <code>x</code>, <code>y</code>, and <code>z</code> sizes specified by the <code>LocalSize</code>
    execution mode and by the object decorated by the <code>WorkgroupSize</code>
    decoration in shader modules <span role="normative">must</span> be less than or equal to the
    corresponding limit.
</p>
</li>
<li>
<p>
<a id="features-limits-subPixelPrecisionBits"></a> <code>subPixelPrecisionBits</code> is
    the number of bits of subpixel precision in framebuffer coordinates
    $x_f$ and $y_f$. See <a href="#primsrast">[primsrast]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-subTexelPrecisionBits"></a> <code>subTexelPrecisionBits</code> is
    the number of bits of precision in the division along an axis of an
    image used for minification and magnification filters.
    $2^\mathit{subTexelPrecisionBits}$ is the actual number of
    divisions along each axis of the image represented. The filtering
    hardware will snap to these locations when computing the filtered
    results.
</p>
</li>
<li>
<p>
<a id="features-limits-mipmapPrecisionBits"></a> <code>mipmapPrecisionBits</code> is the
    number of bits of division that the LOD calculation for mipmap fetching
    get snapped to when determining the contribution from each miplevel to
    the mip filtered results. $2^\mathit{mipmapPrecisionBits}$ is
    the actual number of divisions.
</p>
<div class="openblock">
<div class="content">
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph"><p>For example, if this value is 2 bits then when linearly filtering between
two levels, each level could: contribute: 0%, 33%, 66%, or 100% (this is
just an example and the amount of contribution <span role="normative">should</span> be covered by
different equations in the spec).</p></div>
</td>
</tr></table>
</div>
</div></div>
</li>
<li>
<p>
<a id="features-limits-maxDrawIndexedIndexValue"></a>
    <code>maxDrawIndexedIndexValue</code> is the maximum index value that <span role="normative">can</span> be
    used for indexed draw calls when using 32-bit indices. This excludes the
    primitive restart index value of 0xFFFFFFFF. See
    <a href="#features-features-fullDrawIndexUint32">fullDrawIndexUint32</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxDrawIndirectCount"></a> <code>maxDrawIndirectCount</code> is
    the maximum draw count that is supported for indirect draw calls. See
    <a href="#features-features-multiDrawIndirect">multiDrawIndirect</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxSamplerLodBias"></a> <code>maxSamplerLodBias</code> is the
    maximum absolute sampler level of detail bias. The sum of the
    <code>mipLodBias</code> member of the <code>VkSamplerCreateInfo</code> structure and
    the <code>Bias</code> operand of image sampling operations in shader modules (or
    0 if no <code>Bias</code> operand is provided to an image sampling operation)
    are clamped to the range
    $[-\mathit{maxSamplerLodBias},+\mathit{maxSamplerLodBias}]$.
    See <a href="#samplers-mipLodBias">[samplers-mipLodBias]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxSamplerAnisotropy"></a> <code>maxSamplerAnisotropy</code> is
    the maximum degree of sampler anisotropy. The maximum degree of
    anisotropic filtering used for an image sampling operation is the
    minimum of the <code>maxAnisotropy</code> member of the
    <code>VkSamplerCreateInfo</code> structure and this limit. See
    <a href="#samplers-maxAnisotropy">[samplers-maxAnisotropy]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxViewports"></a> <code>maxViewports</code> is the maximum
    number of active viewports. The <code>viewportCount</code> member of the
    <code>VkPipelineViewportStateCreateInfo</code> structure that is provided at
    pipeline creation <span role="normative">must</span> be less than or equal to this limit.
</p>
</li>
<li>
<p>
<a id="features-limits-maxViewportDimensions"></a> <code>maxViewportDimensions</code>[2]
    are the maximum viewport dimensions in the X (width) and Y (height)
    dimensions, respectively. The maximum viewport dimensions <span role="normative">must</span> be
    greater than or equal to the largest image
    which <span role="normative">can</span> be created and used as a framebuffer attachment. See
    <a href="#vertexpostproc-viewport">Controlling the Viewport</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-viewportboundsrange"></a> <code>viewportBoundsRange</code>[2] is
    the $[\mathit{minimum},\mathit{maximum}]$ range that the
    corners of a viewport <span role="normative">must</span> be contained in. This range <span role="normative">must</span> be at
    least $[- 2 \times \mathit{maxViewportDimensions},
                       2 \times \mathit{maxViewportDimensions} - 1]$.
    See <a href="#vertexpostproc-viewport">Controlling the Viewport</a>.
</p>
<div class="openblock">
<div class="content">
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph"><p>The intent of the <code>viewportBoundsRange</code> limit is to allow a maximum sized
viewport to be arbitrarily shifted relative to the output target as long
as at least some portion intersects. This would give a bounds limit of
$[- \mathit{maxViewportDimensions}+1,
             2 \times \mathit{maxViewportDimensions} -1]$ which would allow
all possible non-empty-set intersections of the output target and the viewport.
Since these numbers are typically powers of two, picking the signed number
range using the smalled possible number of bits, ends up with the specified
range.</p></div>
</td>
</tr></table>
</div>
</div></div>
</li>
<li>
<p>
<a id="features-limits-viewportSubPixelBits"></a> <code>viewportSubPixelBits</code> is
    the number of bits of subpixel precision for viewport bounds. The
    subpixel precision that floating-point viewport bounds are interpreted
    at is given by this limit.
</p>
</li>
<li>
<p>
<a id="features-limits-minMemoryMapAlignment"></a> <code>minMemoryMapAlignment</code> is
    the minimum required alignment, in bytes, of host visible memory
    allocations within the host address space. When mapping a memory
    allocation with <code><a href="vkMapMemory.html">vkMapMemory</a></code>, subtracting <code>offset</code> bytes from
    the returned pointer will always produce an integer multiple of this
    limit. See <a href="#memory-device-hostaccess">[memory-device-hostaccess]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-minTexelBufferOffsetAlignment"></a>
    <code>minTexelBufferOffsetAlignment</code> is the minimum required alignment,
    in bytes, for the <code>offset</code> member of the
    <code>VkBufferViewCreateInfo</code> structure for texel buffers. When a buffer
    view is created for a buffer which was created with
    <code>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</code> or
    <code>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</code> set in the <code>usage</code>
    member of the <code>VkBufferCreateInfo</code> structure, the <code>offset</code> <span role="normative">must</span>
    be an integer multiple of this limit.
</p>
</li>
<li>
<p>
<a id="features-limits-minUniformBufferOffsetAlignment"></a>
    <code>minUniformBufferOffsetAlignment</code> is the minimum required alignment,
    in bytes, for the <code>offset</code> member of the
    <code>VkDescriptorBufferInfo</code> structure for uniform buffers. When a
    descriptor of type <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or
    <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> is updated, the
    <code>offset</code> <span role="normative">must</span> be an integer multiple of this limit. Similarly,
    dynamic offsets for uniform buffers <span role="normative">must</span> be multiples of this limit.
</p>
</li>
<li>
<p>
<a id="features-limits-minStorageBufferOffsetAlignment"></a>
    <code>minStorageBufferOffsetAlignment</code> is the minimum required alignment,
    in bytes, for the <code>offset</code> member of the
    <code>VkDescriptorBufferInfo</code> structure for storage buffers. When a
    descriptor of type <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or
    <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> is updated, the
    <code>offset</code> <span role="normative">must</span> be an integer multiple of this limit. Similarly,
    dynamic offsets for storage buffers <span role="normative">must</span> be multiples of this limit.
</p>
</li>
<li>
<p>
<a id="features-limits-minTexelOffset"></a> <code>minTexelOffset</code> is the minimum
    offset value for the <code>ConstOffset</code> image operand of any of the
    <code>OpImageSample</code>* or <code>OpImageFetch</code>* image instructions.
</p>
</li>
<li>
<p>
<a id="features-limits-maxTexelOffset"></a> <code>maxTexelOffset</code> is the maximum
    offset value for the <code>ConstOffset</code> image operand of any of the
    <code>OpImageSample</code>* or <code>OpImageFetch</code>* image instructions.
</p>
</li>
<li>
<p>
<a id="features-limits-minTexelGatherOffset"></a> <code>minTexelGatherOffset</code> is
    the minimum offset value for the <code>Offset</code> or <code>ConstOffsets</code> image
    operands of any of the <code>OpImage</code>*<code>Gather</code> image instructions.
</p>
</li>
<li>
<p>
<a id="features-limits-maxTexelGatherOffset"></a> <code>maxTexelGatherOffset</code> is
    the maximum offset value for the <code>Offset</code> or <code>ConstOffsets</code> image
    operands of any of the <code>OpImage</code>*<code>Gather</code> image instructions.
</p>
</li>
<li>
<p>
<a id="features-limits-minInterpolationOffset"></a> <code>minInterpolationOffset</code>
    is the minimum negative offset value for the <code>offset</code> operand of the
    <code>InterpolateAtOffset</code> extended instruction.
</p>
</li>
<li>
<p>
<a id="features-limits-maxInterpolationOffset"></a> <code>maxInterpolationOffset</code>
    is the maximum positive offset value for the <code>offset</code> operand of the
    <code>InterpolateAtOffset</code> extended instruction.
</p>
</li>
<li>
<p>
<a id="features-limits-subPixelInterpolationOffsetBits"></a>
    <code>subPixelInterpolationOffsetBits</code> is the number of subpixel
    fractional bits that the <code>x</code> and <code>y</code> offsets to the
    <code>InterpolateAtOffset</code> extended instruction <span role="normative">may</span> be rounded to as
    fixed-point values.
</p>
</li>
<li>
<p>
<a id="features-limits-maxFramebufferWidth"></a> <code>maxFramebufferWidth</code> is the
    maximum width for a framebuffer. The <code>width</code> member of the
    <code>VkFramebufferCreateInfo</code> structure <span role="normative">must</span> be less than or equal to
    this limit.
</p>
</li>
<li>
<p>
<a id="features-limits-maxFramebufferHeight"></a> <code>maxFramebufferHeight</code> is
    the maximum height for a framebuffer. The <code>height</code> member of the
    <code>VkFramebufferCreateInfo</code> structure <span role="normative">must</span> be less than or equal to
    this limit.
</p>
</li>
<li>
<p>
<a id="features-limits-maxFramebufferLayers"></a> <code>maxFramebufferLayers</code> is
    the maximum layer count for a layered framebuffer. The <code>layers</code>
    member of the <code>VkFramebufferCreateInfo</code> structure <span role="normative">must</span> be less than
    or equal to this limit.
</p>
</li>
<li>
<p>
<a id="features-limits-framebufferColorSampleCounts"></a>
    <code>framebufferColorSampleCounts</code> is a bitmask<sup>1</sup> of
    <code><a href="VkSampleCountFlagBits.html">VkSampleCountFlagBits</a></code> bits indicating the color sample counts that
    are supported for all framebuffer color attachments.
</p>
</li>
<li>
<p>
<a id="features-limits-framebufferDepthSampleCounts"></a>
    <code>framebufferDepthSampleCounts</code> is a bitmask<sup>1</sup> of
    <code><a href="VkSampleCountFlagBits.html">VkSampleCountFlagBits</a></code> bits indicating the supported depth sample
    counts for all framebuffer depth/stencil attachments, when the format
    includes a depth component.
</p>
</li>
<li>
<p>
<code>framebufferStencilSampleCounts</code> is a bitmask<sup>1</sup> of
    <code><a href="VkSampleCountFlagBits.html">VkSampleCountFlagBits</a></code> bits indicating the supported stencil sample
    counts for all framebuffer depth/stencil attachments, when the format
    includes a stencil component.
</p>
</li>
<li>
<p>
<code>framebufferNoAttachmentsSampleCounts</code> is a bitmask<sup>1</sup> of
    <code><a href="VkSampleCountFlagBits.html">VkSampleCountFlagBits</a></code> bits indicating the supported sample counts
    for a framebuffer with no attachments.
</p>
</li>
<li>
<p>
<a id="features-limits-maxColorAttachments"></a> <code>maxColorAttachments</code> is the
    maximum number of color attachments that <span role="normative">can</span> be used by a subpass in a
    render pass. The <code>colorAttachmentCount</code> member of the
    <code>VkSubpassDescription</code> structure <span role="normative">must</span> be less than or equal to this
    limit.
</p>
</li>
<li>
<p>
<a id="features-limits-sampledImageColorSampleCounts"></a>
    <code>sampledImageColorSampleCounts</code> is a bitmask<sup>1</sup> of
    <code><a href="VkSampleCountFlagBits.html">VkSampleCountFlagBits</a></code> bits indicating the sample counts supported
    for all 2D images created with <code>VK_IMAGE_TILING_OPTIMAL</code>, <code>usage</code>
    containing <code>VK_IMAGE_USAGE_SAMPLED_BIT</code>, and a non-integer color
    format.
</p>
</li>
<li>
<p>
<a id="features-limits-sampledImageIntegerSampleCounts"></a>
    <code>sampledImageIntegerSampleCounts</code> is a bitmask<sup>1</sup> of
    <code><a href="VkSampleCountFlagBits.html">VkSampleCountFlagBits</a></code> bits indicating the sample counts supported
    for all 2D images created with <code>VK_IMAGE_TILING_OPTIMAL</code>, <code>usage</code>
    containing <code>VK_IMAGE_USAGE_SAMPLED_BIT</code>, and an integer color
    format.
</p>
</li>
<li>
<p>
<a id="features-limits-sampledImageDepthSampleCounts"></a>
    <code>sampledImageDepthSampleCounts</code> is a bitmask<sup>1</sup> of
    <code><a href="VkSampleCountFlagBits.html">VkSampleCountFlagBits</a></code> bits indicating the sample counts supported
    for all 2D images created with <code>VK_IMAGE_TILING_OPTIMAL</code>, <code>usage</code>
    containing <code>VK_IMAGE_USAGE_SAMPLED_BIT</code>, and a depth format.
</p>
</li>
<li>
<p>
<a id="features-limits-sampledImageStencilSampleCounts"></a>
    <code>sampledImageStencilSampleCounts</code> is a bitmask<sup>1</sup> of
    <code><a href="VkSampleCountFlagBits.html">VkSampleCountFlagBits</a></code> bits indicating the sample supported
    for all 2D images created with <code>VK_IMAGE_TILING_OPTIMAL</code>, <code>usage</code>
    containing <code>VK_IMAGE_USAGE_SAMPLED_BIT</code>, and a stencil format.
</p>
</li>
<li>
<p>
<a id="features-limits-storageImageSampleCounts"></a>
    <code>storageImageSampleCounts</code> is a bitmask<sup>1</sup> of
    <code><a href="VkSampleCountFlagBits.html">VkSampleCountFlagBits</a></code> bits indicating the sample counts supported
    for all 2D images created with <code>VK_IMAGE_TILING_OPTIMAL</code>, and
    <code>usage</code> containing <code>VK_IMAGE_USAGE_STORAGE_BIT</code>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxSampleMaskWords"></a> <code>maxSampleMaskWords</code> is the
    maximum number of array elements of a variable decorated with the
    <code>SampleMask</code> built-in decoration.
</p>
</li>
<li>
<p>
<a id="features-limits-timestampComputeAndGraphics"></a>
    <code>timestampComputeAndGraphics</code> indicates support for timestamps on
    all graphics and compute queues. If this limit is set to <code>VK_TRUE</code>,
    all queues that advertise the <code>VK_QUEUE_GRAPHICS_BIT</code> or
    <code>VK_QUEUE_COMPUTE_BIT</code> in the
    <code>VkQueueFamilyProperties</code>::<code>queueFlags</code> support
    <code>VkQueueFamilyProperties</code>::<code>timestampValidBits</code> of at least 36.
    See <a href="#queries-timestamps">Timestamp Queries</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-timestampPeriod"></a> <code>timestampPeriod</code> is the number
    of nanoseconds required for a timestamp query to be incremented by 1.
    See <a href="#queries-timestamps">Timestamp Queries</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-maxClipDistances"></a> <code>maxClipDistances</code> is the
    maximum number of clip distances that <span role="normative">can</span> be used in a single shader
    stage. The size of any array declared with the <code>ClipDistance</code>
    built-in decoration in a shader module <span role="normative">must</span> be less than or equal to
    this limit.
</p>
</li>
<li>
<p>
<a id="features-limits-maxCullDistances"></a> <code>maxCullDistances</code> is the
    maximum number of cull distances that <span role="normative">can</span> be used in a single shader
    stage. The size of any array declared with the <code>CullDistance</code>
    built-in decoration in a shader module <span role="normative">must</span> be less than or equal to
    this limit.
</p>
</li>
<li>
<p>
<a id="features-limits-maxCombinedClipAndCullDistances"></a>
    <code>maxCombinedClipAndCullDistances</code> is the maximum combined number of
    clip and cull distances that <span role="normative">can</span> be used in a single shader stage.
    The sum of the sizes of any pair of arrays declared with the
    <code>ClipDistance</code> and <code>CullDistance</code> built-in decoration used by
    a single shader stage in a shader module <span role="normative">must</span> be less than or equal to
    this limit.
</p>
</li>
<li>
<p>
<a id="features-limits-discreteQueuePriorities"></a>
    <code>discreteQueuePriorities</code> is the number of discrete priorities that
    <span role="normative">can</span> be assigned to a queue based on the value of each member of
    <code>VkDeviceQueueCreateInfo</code>::<code>pQueuePriorities</code>. This <span role="normative">must</span> be at
    least 2, and levels <span role="normative">must</span> be spread evenly over the range, with at least
    one level at 1.0, and another at 0.0. See <a href="#devsandqueues-priority">[devsandqueues-priority]</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-pointSizeRange"></a> <code>pointSizeRange</code>[2] is the range
    $[\mathit{minimum},\mathit{maximum}]$ of supported sizes
    for points. Values written to variables decorated with the
    <code>PointSize</code> built-in decoration are clamped to this range.
</p>
</li>
<li>
<p>
<a id="features-limits-lineWidthRange"></a> <code>lineWidthRange</code>[2] is the range
    $[\mathit{minimum},\mathit{maximum}]$ of supported widths
    for lines. Values specified by the <code>lineWidth</code> member of the
    <code>VkPipelineRasterizationStateCreateInfo</code> or the <code>lineWidth</code>
    parameter to <code>vkCmdSetLineWidth</code> are clamped to this range.
</p>
</li>
<li>
<p>
<a id="features-limits-pointSizeGranularity"></a> <code>pointSizeGranularity</code> is
    the granularity of supported point sizes. Not all point sizes in the
    range defined by <code>pointSizeRange</code> are supported. This limit
    specifies the granularity (or increment) between successive supported
    point sizes.
</p>
</li>
<li>
<p>
<a id="features-limits-lineWidthGranularity"></a> <code>lineWidthGranularity</code> is
    the granularity of supported line widths. Not all line widths in the
    range defined by <code>lineWidthRange</code> are supported. This limit
    specifies the granularity (or increment) between successive supported
    line widths.
</p>
</li>
<li>
<p>
<a id="features-limits-strictLines"></a> <code>strictLines</code> indicates whether
    lines are rasterized according to the preferred method of rasterization.
    If set to <code>VK_FALSE</code>, lines <span role="normative">may</span> be rasterized under a relaxed set
    of rules. If set to <code>VK_TRUE</code>, lines are rasterized as per the
    strict definition. See <a href="#primsrast-lines-basic">Basic Line Segment     Rasterization</a>.
</p>
</li>
<li>
<p>
<a id="features-limits-standardSampleLocations"></a>
    <code>standardSampleLocations</code> indicates whether rasterization uses the
    standard sample locations as documented in
    <a href="#primsrast-multisampling">Multisampling</a>. If set to <code>VK_TRUE</code>, the
    implementation uses the documented sample locations. If set to
    <code>VK_FALSE</code>, the implementation <span role="normative">may</span> use different sample locations.
</p>
</li>
<li>
<p>
<a id="features-limits-optimalBufferCopyOffsetAlignment"></a>
    <code>optimalBufferCopyOffsetAlignment</code> is the optimal buffer
    offset alignment in bytes for <code>vkCmdCopyBufferToImage</code> and
    <code>vkCmdCopyImageToBuffer</code>. The per texel alignment requirements are
    still enforced, this is just an additional alignment recommendation for
    optimal performance and power.
</p>
</li>
<li>
<p>
<a id="features-limits-optimalBufferCopyRowPitchAlignment"></a>
    <code>optimalBufferCopyRowPitchAlignment</code> is the optimal buffer
    row pitch alignment in bytes for <code>vkCmdCopyBufferToImage</code> and
    <code>vkCmdCopyImageToBuffer</code>. Row pitch is the number of bytes between
    texels with the same X coordinate in adjacent rows (Y coordinates differ
    by one). The per texel alignment requirements are still enforced, this
    is just an additional alignment recommendation for optimal performance
    and power.
</p>
</li>
<li>
<p>
<a id="features-limits-nonCoherentAtomSize"></a>
    <code>nonCoherentAtomSize</code> is the size and alignment in bytes that bounds
    concurrent access to
    <a href="#memory-device-hostaccess">host-mapped device memory</a>.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="dlist"><dl>
<dt class="hdlist1">
1
</dt>
<dd>
<p>
    For all bitmasks of type <code><a href="VkSampleCountFlags.html">VkSampleCountFlags</a></code> above, possible
    values include:
</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight 3.1.7
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #0000FF">typedef</span></span> <span style="font-weight: bold"><span style="color: #0000FF">enum</span></span> VkSampleCountFlagBits <span style="color: #FF0000">{</span>
    VK_SAMPLE_COUNT_1_BIT <span style="color: #990000">=</span> <span style="color: #993399">0x00000001</span><span style="color: #990000">,</span>
    VK_SAMPLE_COUNT_2_BIT <span style="color: #990000">=</span> <span style="color: #993399">0x00000002</span><span style="color: #990000">,</span>
    VK_SAMPLE_COUNT_4_BIT <span style="color: #990000">=</span> <span style="color: #993399">0x00000004</span><span style="color: #990000">,</span>
    VK_SAMPLE_COUNT_8_BIT <span style="color: #990000">=</span> <span style="color: #993399">0x00000008</span><span style="color: #990000">,</span>
    VK_SAMPLE_COUNT_16_BIT <span style="color: #990000">=</span> <span style="color: #993399">0x00000010</span><span style="color: #990000">,</span>
    VK_SAMPLE_COUNT_32_BIT <span style="color: #990000">=</span> <span style="color: #993399">0x00000020</span><span style="color: #990000">,</span>
    VK_SAMPLE_COUNT_64_BIT <span style="color: #990000">=</span> <span style="color: #993399">0x00000040</span><span style="color: #990000">,</span>
<span style="color: #FF0000">}</span> VkSampleCountFlagBits<span style="color: #990000">;</span></tt></pre></div></div>
</div></div>
<div class="paragraph"><p>The sample count limits defined above represent the minimum
supported sample counts for each image type. Individual images <span role="normative">may</span> support
additional sample counts, which are queried using
<code><a href="vkGetPhysicalDeviceImageFormatProperties.html">vkGetPhysicalDeviceImageFormatProperties</a></code> as described
in <a href="#features-supported-sample-counts">Supported Sample Counts</a>.</p></div>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_see_also">See Also</h2>
<div class="sectionbody">
<div class="paragraph"><p><code><a href="VkBool32.html">VkBool32</a></code>, <code><a href="VkDeviceSize.html">VkDeviceSize</a></code>, <code><a href="VkPhysicalDeviceProperties.html">VkPhysicalDeviceProperties</a></code>, <code><a href="VkSampleCountFlags.html">VkSampleCountFlags</a></code></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_document_notes">Document Notes</h2>
<div class="sectionbody">
<div class="paragraph"><p>For more information, see the Vulkan Specification at URL</p></div>
<div class="paragraph"><p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/xhtml/vkspec.html#VkPhysicalDeviceLimits">https://www.khronos.org/registry/vulkan/specs/1.0/xhtml/vkspec.html#VkPhysicalDeviceLimits</a></p></div>
<div class="paragraph"><p>This page is extracted from the Vulkan Specification.
Fixes and changes should be made to the Specification,not directly.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_copyright">Copyright</h2>
<div class="sectionbody">
<div class="paragraph"><p>Copyright (c) 2014-2016 Khronos Group. This work is licensed under a
<a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons
Attribution 4.0 International License</a>.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr></div>
<div id="footer">
<div id="footer-text">
Last updated
 2016-08-28 03:29:32 PDT
</div>
</div>
</body>
</html>
