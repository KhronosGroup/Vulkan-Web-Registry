<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="AsciiDoc 8.6.9">
<title>vkCmdBlitImage(3)</title>
<style type="text/css">
/*
  CSS stylesheet for XHTML produced by DocBook XSL stylesheets.
  Tested with XSL stylesheets 1.61.2, 1.67.2
*/

span.strong {
  font-weight: bold;
}

body blockquote {
  margin-top: .75em;
  line-height: 1.5;
  margin-bottom: .75em;
}

html body {
  margin: 1em 5% 1em 5%;
  font-family: tahoma, veranda, sans-serif;
}

body div {
  margin: 0;
}

h1, h2, h3, h4, h5, h6
{
  color: #527bbd;
  font-family: tahoma, verdana, sans-serif;
}

.type {
  color: #333333;
  font-family: "courier new", monospace;
  /* font-size: 1.2em; */
}

code {
  font-family: "courier new", monospace;
  /* font-size: 1.2em; */
}

div.toc p:first-child,
div.list-of-figures p:first-child,
div.list-of-tables p:first-child,
div.list-of-examples p:first-child,
div.example p.title,
div.sidebar p.title
{
  font-weight: bold;
  color: #527bbd;
  font-family: tahoma, verdana, sans-serif;
  margin-bottom: 0.2em;
}

div.refnamediv
{
  font-weight: bold;
  color: #333377;
}

em.parameter {
  font-style: normal;
  color: #000060;
  font-family: "courier new", monospace;
}

body h1 {
  margin: .0em 0 0 -4%;
  line-height: 1.3;
  border-bottom: 2px solid silver;
}

body h2 {
  margin: 0.5em 0 0 -4%;
  line-height: 1.3;
  border-bottom: 2px solid silver;
}

body h3 {
  margin: .8em 0 0 -3%;
  line-height: 1.3;
}

body h4 {
  margin: .8em 0 0 -3%;
  line-height: 1.3;
}

body h5 {
  margin: .8em 0 0 -2%;
  line-height: 1.3;
}

body h6 {
  margin: .8em 0 0 -1%;
  line-height: 1.3;
}

body hr {
  border: none; /* Broken on IE6 */
}
div.footnotes hr {
  border: 1px solid silver;
}

div.navheader th, div.navheader td, div.navfooter td {
  font-family: sans-serif;
  font-size: 0.9em;
  font-weight: bold;
  color: #527bbd;
}
div.navheader img, div.navfooter img {
  border-style: none;
}
div.navheader a, div.navfooter a {
  font-weight: normal;
}
div.navfooter hr {
  border: 1px solid silver;
}

body td {
  line-height: 1.2
}

body th {
  line-height: 1.2;
}

ol {
  line-height: 1.2;
}

ul, body dir, body menu {
  line-height: 1.2;
}

html {
  margin: 0;
  padding: 0;
}

body h1, body h2, body h3, body h4, body h5, body h6 {
  margin-left: 0
}

body pre {
  margin: 0.5em 10% 0.5em 1em;
  line-height: 1.0;
  color: #333333;
}

tt.literal, code.literal {
  color: navy;
}

.programlisting, .screen {
  border: 1px solid silver;
  background: #f4f4f4;
  margin: 0.5em 10% 0.5em 0;
  padding: 0.5em 1em;
  font-family: "courier new", monospace;
}

div.sidebar {
  background: #ffffee;
  margin: 1.0em 10% 0.5em 0;
  padding: 0.5em 1em;
  border: 1px solid silver;
}
div.sidebar * { padding: 0; }
div.sidebar div { margin: 0; }
div.sidebar p.title {
  margin-top: 0.5em;
  margin-bottom: 0.2em;
}

div.bibliomixed {
  margin: 0.5em 5% 0.5em 1em;
}

div.glossary dt {
  font-weight: bold;
}
div.glossary dd p {
  margin-top: 0.2em;
}

dl {
  margin: .8em 0;
  line-height: 1.2;
}

dt {
  margin-top: 0.5em;
}

dt span.term {
  font-style: normal;
  color: navy;
}

div.variablelist dd p {
  margin-top: 0;
}

div.itemizedlist li, div.orderedlist li {
  margin-left: -0.8em;
  margin-top: 0.5em;
}

ul, ol {
    list-style-position: outside;
}

div.sidebar ul, div.sidebar ol {
    margin-left: 2.8em;
}

div.itemizedlist p.title,
div.orderedlist p.title,
div.variablelist p.title
{
  margin-bottom: -0.8em;
}

div.revhistory table {
  border-collapse: collapse;
  border: none;
}
div.revhistory th {
  border: none;
  color: #527bbd;
  font-family: tahoma, verdana, sans-serif;
}
div.revhistory td {
  border: 1px solid silver;
}

/* Keep TOC and index lines close together. */
div.toc dl, div.toc dt,
div.list-of-figures dl, div.list-of-figures dt,
div.list-of-tables dl, div.list-of-tables dt,
div.indexdiv dl, div.indexdiv dt
{
  line-height: normal;
  margin-top: 0;
  margin-bottom: 0;
}

/*
  Table styling does not work because of overriding attributes in
  generated HTML.
*/
div.table table,
div.informaltable table
{
    margin-left: 0;
    margin-right: 5%;
    margin-bottom: 0.8em;
}
div.informaltable table
{
    margin-top: 0.4em
}
div.table thead,
div.table tfoot,
div.table tbody,
div.informaltable thead,
div.informaltable tfoot,
div.informaltable tbody
{
    /* No effect in IE6. */
    border-top: 3px solid #527bbd;
    border-bottom: 3px solid #527bbd;
}
div.table thead, div.table tfoot,
div.informaltable thead, div.informaltable tfoot
{
    font-weight: bold;
}

div.mediaobject img {
    margin-bottom: 0.8em;
}
div.figure p.title,
div.table p.title
{
  margin-top: 1em;
  margin-bottom: 0.4em;
}

div.calloutlist p
{
  margin-top: 0em;
  margin-bottom: 0.4em;
}

@media print {
  div.navheader, div.navfooter { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
    <!-- Asciidoc configuration file attribute substitution is applied when
         including this file, so care in formatting braces is required. Thus
         the spaces before left: below. -->
    <!-- Load KaTeX from relative path ../../katex.
         This can also be an absolute URL prefix, allowing use of either a
         local copy or the KaTeX CDN (see https://github.com/Khan/KaTeX for
         CDN URLs). -->
<link rel="stylesheet" href="../../katex/katex.min.css">
<script src="../../katex/katex.min.js"></script>
<script src="../../katex/contrib/auto-render.min.js"></script>
    <!-- Use KaTeX to render math once document is loaded, see
         https://github.com/Khan/KaTeX/tree/master/contrib/auto-render -->
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(
            document.body,
            {
                delimiters: [
                    { left: "$$", right: "$$", display: true},
                    { left: "\\[", right: "\\]", display: true},
                    { left: "$", right: "$", display: false},
                    { left: "\\(", right: "\\)", display: false}
                ]
            }
        );
    });
</script>
</head>
<body class="manpage" style="max-width:1024px">
<div id="header">
<h1>
vkCmdBlitImage(3) Manual Page
</h1>
<h2>NAME</h2>
<div class="sectionbody">
<p>vkCmdBlitImage -
   Copy regions of an image, potentially performing format conversion,
</p>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_c_specification">C Specification</h2>
<div class="sectionbody">
<div class="paragraph"><p>To copy regions of a source image into a destination image, potentially
performing format conversion, arbitrary scaling, and filtering, call:</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight 3.1.7
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">vkCmdBlitImage</span></span><span style="color: #990000">(</span>
    <span style="color: #008080">VkCommandBuffer</span>                             commandBuffer<span style="color: #990000">,</span>
    <span style="color: #008080">VkImage</span>                                     srcImage<span style="color: #990000">,</span>
    <span style="color: #008080">VkImageLayout</span>                               srcImageLayout<span style="color: #990000">,</span>
    <span style="color: #008080">VkImage</span>                                     dstImage<span style="color: #990000">,</span>
    <span style="color: #008080">VkImageLayout</span>                               dstImageLayout<span style="color: #990000">,</span>
    <span style="color: #008080">uint32_t</span>                                    regionCount<span style="color: #990000">,</span>
    <span style="font-weight: bold"><span style="color: #0000FF">const</span></span> VkImageBlit<span style="color: #990000">*</span>                          pRegions<span style="color: #990000">,</span>
    <span style="color: #008080">VkFilter</span>                                    filter<span style="color: #990000">);</span></tt></pre></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_parameters">Parameters</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
<code>commandBuffer</code> is the command buffer into which the command will be
    recorded.
</p>
</li>
<li>
<p>
<code>srcImage</code> is the source image.
</p>
</li>
<li>
<p>
<code>srcImageLayout</code> is the layout of the source image subresources for
    the blit.
</p>
</li>
<li>
<p>
<code>dstImage</code> is the destination image.
</p>
</li>
<li>
<p>
<code>dstImageLayout</code> is the layout of the destination image subresources
    for the blit.
</p>
</li>
<li>
<p>
<code>regionCount</code> is the number of regions to blit.
</p>
</li>
<li>
<p>
<code>pRegions</code> is a pointer to an array of <code><a href="VkImageBlit.html">VkImageBlit</a></code> structures
    specifying the regions to blit.
</p>
</li>
<li>
<p>
<code>filter</code> is a <code><a href="VkFilter.html">VkFilter</a></code> specifying the filter to apply if the
    blits require scaling.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>vkCmdBlitImage</code> <span role="normative">must</span> not be used for multisampled source or
destination images.
Use <code><a href="vkCmdResolveImage.html">vkCmdResolveImage</a></code> for this purpose.</p></div>
<div class="paragraph"><p>As the sizes of the source and destination extents <span role="normative">can</span> differ in any
dimension, texels in the source extent are scaled and filtered to the
destination extent.
Scaling occurs via the following operations:</p></div>
<div class="ulist"><ul>
<li>
<p>
For each destination texel, the integer coordinate of that texel is
      converted to an unnormalized texture coordinate, using the effective
      inverse of the equations described in
      <a href="#textures-unnormalized-to-integer">unnormalized to integer       conversion</a>:
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">u<sub>base</sub> = i + &#x00bd;</span>
</p>
</dd>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">v<sub>base</sub> = j + &#x00bd;</span>
</p>
</dd>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">w<sub>base</sub> = k + &#x00bd;</span>
</p>
</dd>
</dl></div>
</li>
<li>
<p>
These base coordinates are then offset by the first destination
      offset:
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">u<sub>offset</sub> = u<sub>base</sub> - x<sub>dst0</sub></span>
</p>
</dd>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">v<sub>offset</sub> = v<sub>base</sub> - y<sub>dst0</sub></span>
</p>
</dd>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">w<sub>offset</sub> = w<sub>base</sub> - z<sub>dst0</sub></span>
</p>
</dd>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">a<sub>offset</sub> = a - <code>baseArrayCount</code><sub>dst</sub></span>
</p>
</dd>
</dl></div>
</li>
<li>
<p>
The scale is determined from the source and destination regions, and
      applied to the offset coordinates:
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">scale_u = (x<sub>src1</sub> - x<sub>src0</sub>) / (x<sub>dst1</sub> - x<sub>dst0</sub>)</span>
</p>
</dd>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">scale_v = (y<sub>src1</sub> - y<sub>src0</sub>) / (y<sub>dst1</sub> - y<sub>dst0</sub>)</span>
</p>
</dd>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">scale_w = (z<sub>src1</sub> - z<sub>src0</sub>) / (z<sub>dst1</sub> - z<sub>dst0</sub>)</span>
</p>
</dd>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">u<sub>scaled</sub> = u<sub>offset</sub> * scale<sub>u</sub></span>
</p>
</dd>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">v<sub>scaled</sub> = v<sub>offset</sub> * scale<sub>v</sub></span>
</p>
</dd>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">w<sub>scaled</sub> = w<sub>offset</sub> * scale<sub>w</sub></span>
</p>
</dd>
</dl></div>
</li>
<li>
<p>
Finally the source offset is added to the scaled coordinates, to
      determine the final unnormalized coordinates used to sample from
      <code>srcImage</code>:<br>
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">u = u<sub>scaled</sub> + x<sub>src0</sub></span>
</p>
</dd>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">v = v<sub>scaled</sub> + y<sub>src0</sub></span>
</p>
</dd>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">w = w<sub>scaled</sub> + z<sub>src0</sub></span>
</p>
</dd>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">q = <code>mipLevel</code></span>
</p>
</dd>
<dt class="hdlist1">
 
</dt>
<dd>
<p>
<span class="eq">a = a<sub>offset</sub> + <code>baseArrayCount</code><sub>src</sub></span>
</p>
</dd>
</dl></div>
</li>
</ul></div>
<div class="paragraph"><p>These coordinates are used to sample from the source image, as described in
<a href="#textures">Image Operations chapter</a>, with the filter mode equal to that
of <code>filter</code>, a mipmap mode of <code>VK_SAMPLER_MIPMAP_MODE_NEAREST</code> and
an address mode of <code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE</code>.
Implementations <span role="normative">must</span> clamp at the edge of the source image, and <span role="normative">may</span>
additionally clamp to the edge of the source region.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph"><p>Due to allowable rounding errors in the generation of the source texture
coordinates, it is not always possible to guarantee exactly which source
texels will be sampled for a given blit.
As rounding errors are implementation dependent, the exact results of a
blitting operation are also implementation dependent.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Blits are done layer by layer starting with the <code>baseArrayLayer</code> member
of <code>srcSubresource</code> for the source and <code>dstSubresource</code> for the
destination.
<code>layerCount</code> layers are blitted to the destination image.</p></div>
<div class="paragraph"><p>3D textures are blitted slice by slice.
Slices in the source region bounded by <code>srcOffsets</code>[0].<code>z</code> and
<code>srcOffsets</code>[1].<code>z</code> are copied to slices in the destination region
bounded by <code>dstOffsets</code>[0].<code>z</code> and <code>dstOffsets</code>[1].<code>z</code>.
For each destination slice, a source z coordinate is linearly interpolated
between <code>srcOffsets</code>[0].<code>z</code> and <code>srcOffsets</code>[1].<code>z</code>.
If the <code>filter</code> parameter is <code>VK_FILTER_LINEAR</code> then the value
sampled from the source image is taken by doing linear filtering using the
interpolated z coordinate.
If <code>filter</code> parameter is <code>VK_FILTER_NEAREST</code> then value sampled from
the source image is taken from the single nearest slice (with undefined
rounding mode).</p></div>
<div class="paragraph"><p>The following filtering and conversion rules apply:</p></div>
<div class="ulist"><ul>
<li>
<p>
Integer formats <span role="normative">can</span> only be converted to other integer formats with the
    same signedness.
</p>
</li>
<li>
<p>
No format conversion is supported between depth/stencil images.
    The formats <span role="normative">must</span> match.
</p>
</li>
<li>
<p>
Format conversions on unorm, snorm, unscaled and packed float formats of
    the copied aspect of the image are performed by first converting the
    pixels to float values.
</p>
</li>
<li>
<p>
For sRGB source formats, nonlinear RGB values are converted to linear
    representation prior to filtering.
</p>
</li>
<li>
<p>
After filtering, the float values are first clamped and then cast to the
    destination image format.
    In case of sRGB destination format, linear RGB values are converted to
    nonlinear representation before writing the pixel to the image.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Signed and unsigned integers are converted by first clamping to the
representable range of the destination format, then casting the value.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist"><ul>
<li>
<p>
The source region specified by a given element of <code>pRegions</code> <span role="normative">must</span>
    be a region that is contained within <code>srcImage</code>
</p>
</li>
<li>
<p>
The destination region specified by a given element of <code>pRegions</code>
    <span role="normative">must</span> be a region that is contained within <code>dstImage</code>
</p>
</li>
<li>
<p>
The union of all destination regions, specified by the elements of
    <code>pRegions</code>, <span role="normative">must</span> not overlap in memory with any texel that <span role="normative">may</span> be
    sampled during the blit operation
</p>
</li>
<li>
<p>
<code>srcImage</code> <span role="normative">must</span> use a format that supports
    <code>VK_FORMAT_FEATURE_BLIT_SRC_BIT</code>, which is indicated by
    <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (for linear tiled
    images) or <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> (for
    optimally tiled images) - as returned by
    <code>vkGetPhysicalDeviceFormatProperties</code>
</p>
</li>
<li>
<p>
<code>srcImage</code> <span role="normative">must</span> have been created with
    <code>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code> usage flag
</p>
</li>
<li>
<p>
If <code>srcImage</code> is non-sparse then it <span role="normative">must</span> be bound completely and
    contiguously to a single <code>VkDeviceMemory</code> object
</p>
</li>
<li>
<p>
<code>srcImageLayout</code> <span role="normative">must</span> specify the layout of the image subresources
    of <code>srcImage</code> specified in <code>pRegions</code> at the time this command
    is executed on a <code>VkDevice</code>
</p>
</li>
<li>
<p>
<code>srcImageLayout</code> <span role="normative">must</span> be either of
    <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code> or
    <code>VK_IMAGE_LAYOUT_GENERAL</code>
</p>
</li>
<li>
<p>
<code>dstImage</code> <span role="normative">must</span> use a format that supports
    <code>VK_FORMAT_FEATURE_BLIT_DST_BIT</code>, which is indicated by
    <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (for linear tiled
    images) or <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> (for
    optimally tiled images) - as returned by
    <code>vkGetPhysicalDeviceFormatProperties</code>
</p>
</li>
<li>
<p>
<code>dstImage</code> <span role="normative">must</span> have been created with
    <code>VK_IMAGE_USAGE_TRANSFER_DST_BIT</code> usage flag
</p>
</li>
<li>
<p>
If <code>dstImage</code> is non-sparse then it <span role="normative">must</span> be bound completely and
    contiguously to a single <code>VkDeviceMemory</code> object
</p>
</li>
<li>
<p>
<code>dstImageLayout</code> <span role="normative">must</span> specify the layout of the image subresources
    of <code>dstImage</code> specified in <code>pRegions</code> at the time this command
    is executed on a <code>VkDevice</code>
</p>
</li>
<li>
<p>
<code>dstImageLayout</code> <span role="normative">must</span> be either of
    <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> or
    <code>VK_IMAGE_LAYOUT_GENERAL</code>
</p>
</li>
<li>
<p>
The sample count of <code>srcImage</code> and <code>dstImage</code> <span role="normative">must</span> both be
    equal to <code>VK_SAMPLE_COUNT_1_BIT</code>
</p>
</li>
<li>
<p>
If either of <code>srcImage</code> or <code>dstImage</code> was created with a signed
    integer <code><a href="VkFormat.html">VkFormat</a></code>, the other <span role="normative">must</span> also have been created with a
    signed integer <code><a href="VkFormat.html">VkFormat</a></code>
</p>
</li>
<li>
<p>
If either of <code>srcImage</code> or <code>dstImage</code> was created with an
    unsigned integer <code><a href="VkFormat.html">VkFormat</a></code>, the other <span role="normative">must</span> also have been created
    with an unsigned integer <code><a href="VkFormat.html">VkFormat</a></code>
</p>
</li>
<li>
<p>
If either of <code>srcImage</code> or <code>dstImage</code> was created with a
    depth/stencil format, the other <span role="normative">must</span> have exactly the same format
</p>
</li>
<li>
<p>
If <code>srcImage</code> was created with a depth/stencil format, <code>filter</code>
    <span role="normative">must</span> be <code>VK_FILTER_NEAREST</code>
</p>
</li>
<li>
<p>
<code>srcImage</code> <span role="normative">must</span> have been created with a <code>samples</code> value of
    <code>VK_SAMPLE_COUNT_1_BIT</code>
</p>
</li>
<li>
<p>
<code>dstImage</code> <span role="normative">must</span> have been created with a <code>samples</code> value of
    <code>VK_SAMPLE_COUNT_1_BIT</code>
</p>
</li>
<li>
<p>
If <code>filter</code> is <code>VK_FILTER_LINEAR</code>, <code>srcImage</code> <span role="normative">must</span> be of a
    format which supports linear filtering, as specified by the
    <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> flag in
    <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (for a linear
    image) or <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code>(for an
    optimally tiled image) returned by
    <code>vkGetPhysicalDeviceFormatProperties</code>
</p>
</li>
</ul></div>
</div></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist"><ul>
<li>
<p>
<code>commandBuffer</code> <span role="normative">must</span> be a valid <code>VkCommandBuffer</code> handle
</p>
</li>
<li>
<p>
<code>srcImage</code> <span role="normative">must</span> be a valid <code>VkImage</code> handle
</p>
</li>
<li>
<p>
<code>srcImageLayout</code> <span role="normative">must</span> be a valid <code><a href="VkImageLayout.html">VkImageLayout</a></code> value
</p>
</li>
<li>
<p>
<code>dstImage</code> <span role="normative">must</span> be a valid <code>VkImage</code> handle
</p>
</li>
<li>
<p>
<code>dstImageLayout</code> <span role="normative">must</span> be a valid <code><a href="VkImageLayout.html">VkImageLayout</a></code> value
</p>
</li>
<li>
<p>
<code>pRegions</code> <span role="normative">must</span> be a pointer to an array of <code>regionCount</code> valid <code>VkImageBlit</code> structures
</p>
</li>
<li>
<p>
<code>filter</code> <span role="normative">must</span> be a valid <code><a href="VkFilter.html">VkFilter</a></code> value
</p>
</li>
<li>
<p>
<code>commandBuffer</code> <span role="normative">must</span> be in the recording state
</p>
</li>
<li>
<p>
The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <span role="normative">must</span> support graphics operations
</p>
</li>
<li>
<p>
This command <span role="normative">must</span> only be called outside of a render pass instance
</p>
</li>
<li>
<p>
<code>regionCount</code> <span role="normative">must</span> be greater than <span class="monospaced">0</span>
</p>
</li>
<li>
<p>
Each of <code>commandBuffer</code>, <code>dstImage</code>, and <code>srcImage</code> <span role="normative">must</span> have been created, allocated, or retrieved from the same <code>VkDevice</code>
</p>
</li>
</ul></div>
</div></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist"><ul>
<li>
<p>
Host access to <code>commandBuffer</code> <span role="normative">must</span> be externally synchronized
</p>
</li>
<li>
<p>
Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <span role="normative">must</span> be externally synchronized
</p>
</li>
</ul></div>
</div></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Command Properties</div>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<thead>
<tr>
<th class="tableblock halign-left valign-top" ><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th>
<th class="tableblock halign-left valign-top" ><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th>
<th class="tableblock halign-left valign-top" ><a href="#VkQueueFlagBits">Supported Queue Types</a></th>
<th class="tableblock halign-left valign-top" ><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">Primary<br>
Secondary</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock">Outside</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock">Graphics</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock">Transfer</p></td>
</tr>
</tbody>
</table>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_see_also">See Also</h2>
<div class="sectionbody">
<div class="paragraph"><p><code><a href="VkCommandBuffer.html">VkCommandBuffer</a></code>, <code><a href="VkFilter.html">VkFilter</a></code>, <code><a href="VkImage.html">VkImage</a></code>, <code><a href="VkImageBlit.html">VkImageBlit</a></code>, <code><a href="VkImageLayout.html">VkImageLayout</a></code></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_document_notes">Document Notes</h2>
<div class="sectionbody">
<div class="paragraph"><p>For more information, see the Vulkan Specification at URL</p></div>
<div class="paragraph"><p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBlitImage">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBlitImage</a></p></div>
<div class="paragraph"><p>This page is extracted from the Vulkan Specification.
Fixes and changes should be made to the Specification,not directly.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_copyright">Copyright</h2>
<div class="sectionbody">
<div class="paragraph"><p>Copyright (c) 2014-2017 Khronos Group. This work is licensed under a
<a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons
Attribution 4.0 International License</a>.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr></div>
<div id="footer">
<div id="footer-text">
Last updated
 2017-01-17 20:18:13 PST
</div>
</div>
</body>
</html>
