<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>VkPhysicalDeviceMemoryProperties</title><link rel="stylesheet" type="text/css" href="vkman.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /></head><body><div xml:lang="en" class="refentry" lang="en"><a id="id-1"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VkPhysicalDeviceMemoryProperties — Structure specifying physical device memory properties</p></div><div class="refsect1"><a id="_c_specification"></a><h2>C Specification</h2><p>The <code class="code">VkPhysicalDeviceMemoryProperties</code> structure is defined as:</p><pre class="programlisting">typedef struct VkPhysicalDeviceMemoryProperties {
    uint32_t        memoryTypeCount;
    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
    uint32_t        memoryHeapCount;
    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties;</pre></div><div class="refsect1"><a id="_members"></a><h2>Members</h2><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>memoryTypeCount</code></em> is the number of valid elements in the
    <em class="parameter"><code>pMemoryRanges</code></em> array.
</li><li class="listitem">
<em class="parameter"><code>memoryTypes</code></em> is an array of <code class="code"><a class="link" href="#">VkMemoryType</a></code> structures
    describing the <span class="emphasis"><em>memory types</em></span> that <span class="normative">can</span> be used to access memory
    allocated from the heaps specified by <em class="parameter"><code>memoryHeaps</code></em>.
</li><li class="listitem">
<em class="parameter"><code>memoryHeapCount</code></em> is the number of valid elements in the
    <em class="parameter"><code>pMemoryRanges</code></em> array.
</li><li class="listitem">
<em class="parameter"><code>memoryHeaps</code></em> is an array of <code class="code"><a class="link" href="#">VkMemoryHeap</a></code> structures
    describing the <span class="emphasis"><em>memory heaps</em></span> from which memory <span class="normative">can</span> be allocated.
</li></ul></div></div><div class="refsect1"><a id="_description"></a><h2>Description</h2><p>The <code class="code">VkPhysicalDeviceMemoryProperties</code> structure describes a number of
<span class="emphasis"><em>memory heaps</em></span> as well as a number of <span class="emphasis"><em>memory types</em></span> that <span class="normative">can</span> be used to
access memory allocated in those heaps. Each heap describes a memory
resource of a particular size, and each memory type describes a set of
memory properties (e.g. host cached vs uncached) that <span class="normative">can</span> be used with a
given memory heap. Allocations using a particular memory type will consume
resources from the heap indicated by that memory type’s heap index. More
than one memory type <span class="normative">may</span> share each heap, and the heaps and memory types
provide a mechanism to advertise an accurate size of the physical memory
resources while allowing the memory to be used with a variety of different
properties.</p><p>The number of memory heaps is given by <em class="parameter"><code>memoryHeapCount</code></em> and is less
than or equal to <code class="code">VK_MAX_MEMORY_HEAPS</code>. Each heap is described by an
element of the <em class="parameter"><code>memoryHeaps</code></em> array, as a <code class="code">VkMemoryHeap</code> structure.
The number of memory types available across all memory heaps is given by
<em class="parameter"><code>memoryTypeCount</code></em> and is less than or equal to
<code class="code">VK_MAX_MEMORY_TYPES</code>. Each memory type is described by an element of
the <em class="parameter"><code>memoryTypes</code></em> array, as a <code class="code">VkMemoryType</code> structure.</p><p>At least one heap <span class="normative">must</span> include <code class="code">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</code> in
<code class="code"><a class="link" href="#">VkMemoryHeap</a></code>::<em class="parameter"><code>flags</code></em>. If there are multiple heaps that all have similar performance
characteristics, they <span class="normative">may</span> all include <code class="code">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</code>.
In a unified memory architecture (UMA) system, there is often only a single
memory heap which is considered to be equally “local” to the host and to the
device, and such an implementation <span class="normative">must</span> advertise the heap as device-local.</p><p>Each memory type returned by <code class="code"><a class="link" href="#">vkGetPhysicalDeviceMemoryProperties</a></code> <span class="normative">must</span>
have its <em class="parameter"><code>propertyFlags</code></em> set to one of the following values:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
0
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> | <code class="code">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> | <code class="code">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> | <code class="code">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code> | <code class="code">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> | <code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> | <code class="code">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> | <code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> | <code class="code">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> | <code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> | <code class="code">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code> | <code class="code">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> | <code class="code">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>
</li></ul></div><p>There <span class="normative">must</span> be at least one memory type with both the
<code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and
<code class="code">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> bits set in its <em class="parameter"><code>propertyFlags</code></em>.
There <span class="normative">must</span> be at least one memory type with the
<code class="code">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> bit set in its <em class="parameter"><code>propertyFlags</code></em>.</p><p>The memory types are sorted according to a preorder which serves to aid
in easily selecting an appropriate memory type. Given two memory types X and
Y, the preorder defines <span class="inlinemediaobject"><span class="phrase">
$X \leq Y$
</span></span> if:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
the memory property bits set for X are a strict subset of the memory
    property bits set for Y. Or,
</li><li class="listitem">
the memory property bits set for X are the same as the memory property
    bits set for Y, and X uses a memory heap with greater or equal
    performance (as determined in an implementation-specific manner).
</li></ul></div><p>Memory types are ordered in the list such that X is assigned a lesser
<em class="parameter"><code>memoryTypeIndex</code></em> than Y if <span class="inlinemediaobject"><span class="phrase">
$X \leq Y \land \neg(Y \leq X)$
</span></span> according to the
preorder. Note that the list of all allowed memory property flag
combinations above satisfies this preorder, but other orders would as
well. The goal of this ordering is to enable applications to use a simple
search loop in selecting the proper memory type, along the lines of:</p><pre class="programlisting">// Find a memory type in "memoryTypeBits" that includes all of "properties"
int32_t FindProperties(uint32_t memoryTypeBits, VkMemoryPropertyFlags properties)
{
    for (int32_t i = 0; i &lt; memoryTypeCount; ++i)
    {
        if ((memoryTypeBits &amp; (1 &lt;&lt; i)) &amp;&amp;
            ((memoryTypes[i].propertyFlags &amp; properties) == properties))
            return i;
    }
    return -1;
}

// Try to find an optimal memory type, or if it does not exist
// find any compatible memory type
VkMemoryRequirements memoryRequirements;
vkGetImageMemoryRequirements(device, image, &amp;memoryRequirements);
int32_t memoryType = FindProperties(memoryRequirements.memoryTypeBits, optimalProperties);
if (memoryType == -1)
    memoryType = FindProperties(memoryRequirements.memoryTypeBits, requiredProperties);</pre><p>The loop will find the first supported memory type that has all bits requested in
<span class="strong"><strong><code class="code">properties</code></strong></span> set. If there is no exact match, it will find a closest
match (i.e. a memory type with the fewest additional bits set), which has
some additional bits set but which are not detrimental to the behaviors
requested by <span class="strong"><strong><code class="code">properties</code></strong></span>. The application <span class="normative">can</span> first search for the optimal
properties, e.g. a memory type that is device-local or supports coherent cached
accesses, as appropriate for the intended usage, and if such a memory type is
not present <span class="normative">can</span> fallback to searching for a less optimal but guaranteed set of
properties such as "0" or "host-visible and coherent".</p></div><div class="refsect1"><a id="_see_also"></a><h2>See Also</h2><p><code class="code"><a class="link" href="#">VkMemoryHeap</a></code>, <code class="code"><a class="link" href="#">VkMemoryType</a></code>, <code class="code"><a class="link" href="#">vkGetPhysicalDeviceMemoryProperties</a></code></p></div><div class="refsect1"><a id="_document_notes"></a><h2>Document Notes</h2><p>For more information, see the Vulkan Specification at URL</p><p><a class="ulink" href="https://www.khronos.org/registry/vulkan/specs/1.0/xhtml/vkspec.html#VkPhysicalDeviceMemoryProperties" target="_top">https://www.khronos.org/registry/vulkan/specs/1.0/xhtml/vkspec.html#VkPhysicalDeviceMemoryProperties</a></p><p>This page is extracted from the Vulkan Specification.
Fixes and changes should be made to the Specification,not directly.</p></div><div class="refsect1"><a id="_copyright"></a><h2>Copyright</h2><p>Copyright (c) 2014-2016 Khronos Group. This work is licensed under a
<a class="ulink" href="http://creativecommons.org/licenses/by/4.0/" target="_top">Creative Commons
Attribution 4.0 International License</a>.</p></div></div></body></html>