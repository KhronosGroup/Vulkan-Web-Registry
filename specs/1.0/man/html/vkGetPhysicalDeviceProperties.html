<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>vkGetPhysicalDeviceProperties</title><link rel="stylesheet" type="text/css" href="vkman.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /></head><body><div xml:lang="en" class="refentry" lang="en"><a id="id-1"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>vkGetPhysicalDeviceProperties — Returns properties of a physical device.</p></div><div class="refsect1"><a id="_c_specification"></a><h2>C Specification</h2><pre class="programlisting">void vkGetPhysicalDeviceProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties*                 pProperties);</pre></div><div class="refsect1"><a id="_parameters"></a><h2>Parameters</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<em class="parameter"><code>physicalDevice</code></em>
</span></dt><dd>
    A handle to the physical device.
</dd><dt><span class="term">
<em class="parameter"><code>pProperties</code></em>
</span></dt><dd>
    A pointer to a structure that will be written with the device properties.
</dd></dl></div></div><div class="refsect1"><a id="_description"></a><h2>Description</h2><p><span class="strong"><strong><code class="code">vkGetPhysicalDeviceProperties</code></strong></span> returns the properties of the physical device specified in
<em class="parameter"><code>physicalDevice</code></em> in the structure pointed to by <em class="parameter"><code>pProperties</code></em>. <em class="parameter"><code>pProperties</code></em> points
to an instance of the <span class="type"><a class="ulink" href="VkPhysicalDeviceProperties.html" target="_top">VkPhysicalDeviceProperties</a></span> structure, the definition of which
is:</p><pre class="programlisting">typedef struct VkPhysicalDeviceProperties {
    uint32_t                            apiVersion;
    uint32_t                            driverVersion;
    uint32_t                            vendorID;
    uint32_t                            deviceID;
    VkPhysicalDeviceType                deviceType;
    char                                deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    uint8_t                             pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceLimits              limits;
    VkPhysicalDeviceSparseProperties    sparseProperties;
} VkPhysicalDeviceProperties;</pre><p>The data returned in the <em class="parameter"><code>pProperties</code></em> structure contains information about the physical
device and the driver associated with it.</p><p>The <em class="parameter"><code>apiVersion</code></em> member of <span class="type"><a class="ulink" href="VkPhysicalDeviceProperties.html" target="_top">VkPhysicalDeviceProperties</a></span> indicates the API version
supported by the physical device. Minor revisions of the API are backward compatible whereas
major versions of the API may break compatibility. The API version is represented as a 32-bit
field where bits 31 - 22 represent the major version, bits 21 - 12 represent the minor version,
and bits 11 - 0 represent the patch version.</p><p>The <em class="parameter"><code>driverVersion</code></em> member represents the vendor-specific version of the driver used to
enable the device.</p><p>The <em class="parameter"><code>vendorID</code></em> and <em class="parameter"><code>deviceID</code></em> members contain the PCI vendor and device identifiers,
respectively. Note that if the device is not physcially a PCI-compliant device, then the
values of <em class="parameter"><code>vendorID</code></em> and <em class="parameter"><code>deviceID</code></em> are platform dependent and may not be values assigned
by the PCI-SIG.</p><p>The <em class="parameter"><code>deviceType</code></em> member indicates the type of device represented by <em class="parameter"><code>physicalDevice</code></em>.
<em class="parameter"><code>deviceType</code></em> is a member of the <span class="type"><a class="ulink" href="VkPhysicalDeviceType.html" target="_top">VkPhysicalDeviceType</a></span> enumeration, the definition of
which is:</p><pre class="programlisting">typedef enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
} VkPhysicalDeviceType;</pre><p>When <em class="parameter"><code>deviceType</code></em> is <span class="type">VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU</span>, then the device is typically
one embedded in or tightly coupled with the host CPU that is running the application. When
<em class="parameter"><code>deviceType</code></em> is <span class="type">VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU</span>, then the device is typically
a separate physical device connected to the host CPU via a slower interlink such as PCI-Express.
If <em class="parameter"><code>deviceType</code></em> is <span class="type">VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU</span>, then the device is potentially
emulated (such a stub device or debugger endpoint), a virtual node in a virtualization environment or
otherwise does not fit either category. If the device is running entirely on the CPU, then
<em class="parameter"><code>deviceType</code></em> will be <span class="type">VK_PHYSICAL_DEVICE_TYPE_CPU</span>. If the device type is unknown or does
not fit any of these types, then <em class="parameter"><code>deviceType</code></em> may be <span class="type">VK_PHYSICAL_DEVICE_TYPE_OTHER</span>.</p><p>The <em class="parameter"><code>deviceName</code></em> member of <em class="parameter"><code>pProperties</code></em> contains a vendor-supplied human-readable name
for the device encoded as a UTF-8 string which is up to <span class="type">VK_MAX_PHYSICAL_DEVICE_NAME_SIZE</span>
characters long, including a null-terminator.</p><p><em class="parameter"><code>pipelineCacheUUID</code></em> is an array, of size <span class="type">VK_UUID_SIZE</span>, containing 8-bit values that represent
a universally unique signature that identifies the hardware and driver combination.</p><p><em class="parameter"><code>limits</code></em> is an instance of the <span class="type"><a class="ulink" href="VkPhysicalDeviceLimits.html" target="_top">VkPhysicalDeviceLimits</a></span> structure which contains limits
on the functionality provided by the device. The definition of <span class="type"><a class="ulink" href="VkPhysicalDeviceLimits.html" target="_top">VkPhysicalDeviceLimits</a></span> is:</p><pre class="programlisting">typedef struct VkPhysicalDeviceLimits {
    uint32_t              maxImageDimension1D;
    uint32_t              maxImageDimension2D;
    uint32_t              maxImageDimension3D;
    uint32_t              maxImageDimensionCube;
    uint32_t              maxImageArrayLayers;
    uint32_t              maxTexelBufferElements;
    uint32_t              maxUniformBufferRange;
    uint32_t              maxStorageBufferRange;
    uint32_t              maxPushConstantsSize;
    uint32_t              maxMemoryAllocationCount;
    uint32_t              maxSamplerAllocationCount;
    VkDeviceSize          bufferImageGranularity;
    VkDeviceSize          sparseAddressSpaceSize;
    uint32_t              maxBoundDescriptorSets;
    uint32_t              maxPerStageDescriptorSamplers;
    uint32_t              maxPerStageDescriptorUniformBuffers;
    uint32_t              maxPerStageDescriptorStorageBuffers;
    uint32_t              maxPerStageDescriptorSampledImages;
    uint32_t              maxPerStageDescriptorStorageImages;
    uint32_t              maxPerStageDescriptorInputAttachments;
    uint32_t              maxPerStageResources;
    uint32_t              maxDescriptorSetSamplers;
    uint32_t              maxDescriptorSetUniformBuffers;
    uint32_t              maxDescriptorSetUniformBuffersDynamic;
    uint32_t              maxDescriptorSetStorageBuffers;
    uint32_t              maxDescriptorSetStorageBuffersDynamic;
    uint32_t              maxDescriptorSetSampledImages;
    uint32_t              maxDescriptorSetStorageImages;
    uint32_t              maxDescriptorSetInputAttachments;
    uint32_t              maxVertexInputAttributes;
    uint32_t              maxVertexInputBindings;
    uint32_t              maxVertexInputAttributeOffset;
    uint32_t              maxVertexInputBindingStride;
    uint32_t              maxVertexOutputComponents;
    uint32_t              maxTessellationGenerationLevel;
    uint32_t              maxTessellationPatchSize;
    uint32_t              maxTessellationControlPerVertexInputComponents;
    uint32_t              maxTessellationControlPerVertexOutputComponents;
    uint32_t              maxTessellationControlPerPatchOutputComponents;
    uint32_t              maxTessellationControlTotalOutputComponents;
    uint32_t              maxTessellationEvaluationInputComponents;
    uint32_t              maxTessellationEvaluationOutputComponents;
    uint32_t              maxGeometryShaderInvocations;
    uint32_t              maxGeometryInputComponents;
    uint32_t              maxGeometryOutputComponents;
    uint32_t              maxGeometryOutputVertices;
    uint32_t              maxGeometryTotalOutputComponents;
    uint32_t              maxFragmentInputComponents;
    uint32_t              maxFragmentOutputAttachments;
    uint32_t              maxFragmentDualSrcAttachments;
    uint32_t              maxFragmentCombinedOutputResources;
    uint32_t              maxComputeSharedMemorySize;
    uint32_t              maxComputeWorkGroupCount[3];
    uint32_t              maxComputeWorkGroupInvocations;
    uint32_t              maxComputeWorkGroupSize[3];
    uint32_t              subPixelPrecisionBits;
    uint32_t              subTexelPrecisionBits;
    uint32_t              mipmapPrecisionBits;
    uint32_t              maxDrawIndexedIndexValue;
    uint32_t              maxDrawIndirectCount;
    float                 maxSamplerLodBias;
    float                 maxSamplerAnisotropy;
    uint32_t              maxViewports;
    uint32_t              maxViewportDimensions[2];
    float                 viewportBoundsRange[2];
    uint32_t              viewportSubPixelBits;
    size_t                minMemoryMapAlignment;
    VkDeviceSize          minTexelBufferOffsetAlignment;
    VkDeviceSize          minUniformBufferOffsetAlignment;
    VkDeviceSize          minStorageBufferOffsetAlignment;
    int32_t               minTexelOffset;
    uint32_t              maxTexelOffset;
    int32_t               minTexelGatherOffset;
    uint32_t              maxTexelGatherOffset;
    float                 minInterpolationOffset;
    float                 maxInterpolationOffset;
    uint32_t              subPixelInterpolationOffsetBits;
    uint32_t              maxFramebufferWidth;
    uint32_t              maxFramebufferHeight;
    uint32_t              maxFramebufferLayers;
    VkSampleCountFlags    framebufferColorSampleCounts;
    VkSampleCountFlags    framebufferDepthSampleCounts;
    VkSampleCountFlags    framebufferStencilSampleCounts;
    VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
    uint32_t              maxColorAttachments;
    VkSampleCountFlags    sampledImageColorSampleCounts;
    VkSampleCountFlags    sampledImageIntegerSampleCounts;
    VkSampleCountFlags    sampledImageDepthSampleCounts;
    VkSampleCountFlags    sampledImageStencilSampleCounts;
    VkSampleCountFlags    storageImageSampleCounts;
    uint32_t              maxSampleMaskWords;
    VkBool32              timestampComputeAndGraphics;
    float                 timestampPeriod;
    uint32_t              maxClipDistances;
    uint32_t              maxCullDistances;
    uint32_t              maxCombinedClipAndCullDistances;
    uint32_t              discreteQueuePriorities;
    float                 pointSizeRange[2];
    float                 lineWidthRange[2];
    float                 pointSizeGranularity;
    float                 lineWidthGranularity;
    VkBool32              strictLines;
    VkBool32              standardSampleLocations;
    VkDeviceSize          optimalBufferCopyOffsetAlignment;
    VkDeviceSize          optimalBufferCopyRowPitchAlignment;
    VkDeviceSize          nonCoherentAtomSize;
} VkPhysicalDeviceLimits;</pre></div><div class="refsect1"><a id="_valid_usage"></a><h2>Valid Usage</h2><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>physicalDevice</code></em> <span class="normative">must</span> be a valid <span class="type">VkPhysicalDevice</span> handle
</li><li class="listitem">
<em class="parameter"><code>pProperties</code></em> <span class="normative">must</span> be a pointer to a <span class="type">VkPhysicalDeviceProperties</span> structure
</li></ul></div></div><div class="refsect1"><a id="_see_also"></a><h2>See Also</h2><p><code class="code"><a class="ulink" href="vkGetPhysicalDeviceFeatures.html" target="_top">vkGetPhysicalDeviceFeatures</a></code>, <code class="code"><a class="ulink" href="vkGetPhysicalDeviceProperties.html" target="_top">vkGetPhysicalDeviceProperties</a></code></p></div><div class="refsect1"><a id="_copyright"></a><h2>Copyright</h2><p>Copyright © 2014-2016 Khronos Group. This material may be distributed subject to
the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. <a class="ulink" href="http://opencontent.org/openpub/" target="_top">http://opencontent.org/openpub/</a>.</p></div></div></body></html>