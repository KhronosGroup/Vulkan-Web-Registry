<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="The Khronos® Vulkan Working Group">
<title>Vulkan® 1.0.98 - A Specification (with all registered Vulkan extensions)</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: #fff; color: #222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

object, svg { display: inline-block; vertical-align: middle; }

.center { margin-left: auto; margin-right: auto; }

.spread { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.4; color: black; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #0068b0; text-decoration: none; line-height: inherit; }
a:hover, a:focus { color: #333; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: Noto, sans-serif; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 0.75em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Noto, sans-serif; font-weight: normal; font-style: normal; color: black; text-rendering: optimizeLegibility; margin-top: 0.5em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #4d4d4d; line-height: 0; }

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid #ddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; color: #264357; }

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 0.75em; list-style-position: outside; font-family: Noto, sans-serif; }

ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3em; font-weight: bold; }
dl dd { margin-bottom: 0.75em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: black; border-bottom: 1px dotted #ddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 0.75em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #ddd; }
blockquote cite { display: block; font-size: 0.8125em; color: #5e93b8; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #5e93b8; }

blockquote, blockquote p { line-height: 1.6; color: #333; }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #ddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
/* Tables */
table { background: #fff; margin-bottom: 1.25em; border: solid 1px #d8d8ce; }
table thead, table tfoot { background: #eee; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #6d6e71; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f8f8f8; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.4; }

body { -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; tab-size: 4; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }

a:hover, a:focus { text-decoration: underline; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: inherit; font-style: normal !important; letter-spacing: 0; padding: 0; background-color: transparent; -webkit-border-radius: 0; border-radius: 0; line-height: inherit; word-wrap: break-word; }
*:not(pre) > code.nobreak { word-wrap: normal; }
*:not(pre) > code.nowrap { white-space: nowrap; }

pre, pre > code { line-height: 1.6; color: #264357; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }

em em { font-style: normal; }

strong strong { font-weight: normal; }

.keyseq { color: #333333; }

kbd { font-family: Consolas, "Liberation Mono", Courier, monospace; display: inline-block; color: black; font-size: 0.65em; line-height: 1.45; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -moz-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: 0 0.15em; padding: 0.2em 0.5em; vertical-align: middle; position: relative; top: -0.1em; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menuref { color: #000; }

.menuseq b:not(.caret), .menuref { font-weight: inherit; }

.menuseq { word-spacing: -0.02em; }
.menuseq b.caret { font-size: 1.25em; line-height: 0.8; }
.menuseq i.caret { font-weight: bold; text-align: center; width: 0.45em; }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 1.5em; padding-right: 1.5em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: black; margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #ddd; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #ddd; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #ddd; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: #5e93b8; display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: #333; }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: #333; }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: black; border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 0 solid #ddd; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: Noto, sans-serif; list-style-type: none; }
#toc li { line-height: 1.3334; margin-top: 0.3334em; }
#toc a { text-decoration: none; }
#toc a:active { text-decoration: underline; }

#toctitle { color: black; font-size: 1.2em; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
  body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { margin-top: 0 !important; background-color: #fff; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #ddd; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #ddd; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
  #toc.toc2 { width: 20em; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background-color: none; padding: 1.25em; }

#footer-text { color: black; line-height: 1.44; }

#content { margin-bottom: 0.625em; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { #content { margin-bottom: 1.25em; }
  .sect1 { padding-bottom: 1.25em; } }
.sect1:last-child { padding-bottom: 0; }

.sect1 + .sect1 { border-top: 0 solid #ddd; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: black; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: black; }

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; }

table.tableblock > caption.title { white-space: nowrap; overflow: visible; max-width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: black; }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: initial; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: Noto, sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #ddd; color: #5e93b8; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: black; margin-top: 0; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint { background: #eee; }
.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint { background: #f2f1f1; }

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { border: 1px hidden #666; -webkit-border-radius: 0; border-radius: 0; word-wrap: break-word; padding: 1.25em 1.5625em 1.125em 1.5625em; font-size: 0.8125em; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.90625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 1em; } }

.literalblock.output pre { color: #eee; background-color: #264357; }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1.25em 1.5625em 1.125em 1.5625em; -webkit-border-radius: 0; border-radius: 0; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: #999; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

table.pyhltable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; line-height: 1.6; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

pre.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #ddd; }

pre.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background: none !important; padding-right: 0 !important; }

.quoteblock { margin: 0 1em 0.75em 1.5em; display: table; }
.quoteblock > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock blockquote p { color: #333; font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: black; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.5em; margin-right: 0.5ex; text-align: right; }
.quoteblock .quoteblock { margin-left: 0; margin-right: 0; padding: 0.5em 0; border-left: 3px solid #5e93b8; }
.quoteblock .quoteblock blockquote { padding: 0 0 0 0.75em; }
.quoteblock .quoteblock blockquote:before { display: none; }

.verseblock { margin: 0 1em 0.75em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: #333; font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.8125em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.025em; color: #5e93b8; }

.quoteblock.abstract { margin: 0 0 0.75em 0; display: block; }
.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p { text-align: left; word-spacing: 0; }
.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before { display: none; }

table.tableblock { max-width: 100%; border-collapse: separate; }
table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid #d8d8ce; }

table.grid-all > thead > tr > .tableblock, table.grid-all > tbody > tr > .tableblock { border-width: 0 1px 1px 0; }

table.grid-all > tfoot > tr > .tableblock { border-width: 1px 1px 0 0; }

table.grid-cols > * > tr > .tableblock { border-width: 0 1px 0 0; }

table.grid-rows > thead > tr > .tableblock, table.grid-rows > tbody > tr > .tableblock { border-width: 0 0 1px 0; }

table.grid-rows > tfoot > tr > .tableblock { border-width: 1px 0 0 0; }

table.grid-all > * > tr > .tableblock:last-child, table.grid-cols > * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-all > tbody > tr:last-child > .tableblock, table.grid-all > thead:last-child > tr > .tableblock, table.grid-rows > tbody > tr:last-child > .tableblock, table.grid-rows > thead:last-child > tr > .tableblock { border-bottom-width: 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot { border-width: 1px 0; }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.4; background: #eee; }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: #222; font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 1em; }

td > div.verse { white-space: pre; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.375em; }

ul.checklist, ul.none, ol.none, ul.no-bullet, ol.no-bullet, ol.unnumbered, ul.unstyled, ol.unstyled { list-style-type: none; }

ul.no-bullet, ol.no-bullet, ol.unnumbered { margin-left: 0.625em; }

ul.unstyled, ol.unstyled { margin-left: 0; }

ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1.25em; font-size: 0.8em; position: relative; bottom: 0.125em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }

ul.inline { display: -ms-flexbox; display: -webkit-box; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; list-style: none; margin: 0 0 0.375em -0.75em; }

ul.inline > li { margin-left: 0.75em; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1, td.hdlist2 { vertical-align: top; padding: 0 0.625em; }

td.hdlist1 { font-weight: bold; padding-bottom: 0.75em; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0.4em 0.75em 0 0.75em; line-height: 1; vertical-align: top; }
.colist > table tr > td:first-of-type img { max-width: initial; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px #fff; -webkit-box-shadow: 0 0 0 1px #ddd; box-shadow: 0 0 0 1px #ddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; display: inline-block; }
a.image object { pointer-events: none; }

sup.footnote, sup.footnoteref { font-size: 0.875em; position: static; vertical-align: super; }
sup.footnote a, sup.footnoteref a { text-decoration: none; }
sup.footnote a:active, sup.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -0.25em 0 0.75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em 0 0.225em; line-height: 1.3334; font-size: 0.875em; margin-left: 1.2em; margin-bottom: 0.2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; margin-left: -1.05em; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }
a span.icon > .fa { cursor: inherit; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #29475c; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: black; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { border-bottom: 1px solid #ddd; }

.sect1 { padding-bottom: 0; }

#toctitle { color: #00406F; font-weight: normal; margin-top: 1.5em; }

.sidebarblock { border-color: #aaa; }

code { -webkit-border-radius: 4px; border-radius: 4px; }

p.tableblock.header { color: #6d6e71; }

.literalblock pre, .listingblock pre { background: #eee; }

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
<link rel="stylesheet" href="../katex/katex.min.css">
<script src="../katex/katex.min.js"></script>
<script src="../katex/contrib/auto-render.min.js"></script>
    <!-- Use KaTeX to render math once document is loaded, see
         https://github.com/Khan/KaTeX/tree/master/contrib/auto-render -->
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(
            document.body,
            {
                delimiters: [
                    { left: "$$", right: "$$", display: true},
                    { left: "\\[", right: "\\]", display: true},
                    { left: "$", right: "$", display: false},
                    { left: "\\(", right: "\\)", display: false}
                ]
            }
        );
    });
</script></head>
<body class="book toc2 toc-left" style="max-width: 100;">
<div id="header">
<h1>Vulkan<sup>®</sup> 1.0.98 - A Specification (with all registered Vulkan extensions)</h1>
<div class="details">
<span id="author" class="author">The Khronos<sup>®</sup> Vulkan Working Group</span><br>
<span id="revnumber">version 1.0.98,</span>
<span id="revdate">2019-01-13 14:04:18Z</span>
<br><span id="revremark">from git branch: github-master commit: f1a7c4b4f3031f985396f1aa617c51fd8a01c8c8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="chap1.html#introduction">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="chap1.html#introduction-conventions">1.1. Document Conventions</a></li>
</ul>
</li>
<li><a href="chap2.html#fundamentals">2. Fundamentals</a>
<ul class="sectlevel2">
<li><a href="chap2.html#fundamentals-host-environment">2.1. Host and Device Environment</a></li>
<li><a href="chap2.html#fundamentals-execmodel">2.2. Execution Model</a></li>
<li><a href="chap2.html#fundamentals-objectmodel-overview">2.3. Object Model</a></li>
<li><a href="chap2.html#fundamentals-abi">2.4. Application Binary Interface</a></li>
<li><a href="chap2.html#fundamentals-commandsyntax">2.5. Command Syntax and Duration</a></li>
<li><a href="chap2.html#fundamentals-threadingbehavior">2.6. Threading Behavior</a></li>
<li><a href="chap2.html#fundamentals-errors">2.7. Errors</a></li>
<li><a href="chap2.html#fundamentals-numerics">2.8. Numeric Representation and Computation</a></li>
<li><a href="chap2.html#fundamentals-fixedconv">2.9. Fixed-Point Data Conversions</a></li>
<li><a href="chap2.html#fundamentals-versionnum">2.10. API Version Numbers and Semantics</a></li>
<li><a href="chap2.html#fundamentals-common-objects">2.11. Common Object Types</a></li>
</ul>
</li>
<li><a href="chap3.html#initialization">3. Initialization</a>
<ul class="sectlevel2">
<li><a href="chap3.html#initialization-functionpointers">3.1. Command Function Pointers</a></li>
<li><a href="chap3.html#initialization-instances">3.2. Instances</a></li>
</ul>
</li>
<li><a href="chap4.html#devsandqueues">4. Devices and Queues</a>
<ul class="sectlevel2">
<li><a href="chap4.html#devsandqueues-physical-device-enumeration">4.1. Physical Devices</a></li>
<li><a href="chap4.html#devsandqueues-devices">4.2. Devices</a></li>
<li><a href="chap4.html#devsandqueues-queues">4.3. Queues</a></li>
</ul>
</li>
<li><a href="chap5.html#commandbuffers">5. Command Buffers</a>
<ul class="sectlevel2">
<li><a href="chap5.html#commandbuffers-lifecycle">5.1. Command Buffer Lifecycle</a></li>
<li><a href="chap5.html#commandbuffers-pools">5.2. Command Pools</a></li>
<li><a href="chap5.html#commandbuffer-allocation">5.3. Command Buffer Allocation and Management</a></li>
<li><a href="chap5.html#commandbuffers-recording">5.4. Command Buffer Recording</a></li>
<li><a href="chap5.html#commandbuffers-submission">5.5. Command Buffer Submission</a></li>
<li><a href="chap5.html#commandbuffers-submission-progress">5.6. Queue Forward Progress</a></li>
<li><a href="chap5.html#commandbuffers-secondary">5.7. Secondary Command Buffer Execution</a></li>
<li><a href="chap5.html#commandbuffers-devicemask">5.8. Command Buffer Device Mask</a></li>
</ul>
</li>
<li><a href="chap6.html#synchronization">6. Synchronization and Cache Control</a>
<ul class="sectlevel2">
<li><a href="chap6.html#synchronization-dependencies">6.1. Execution and Memory Dependencies</a></li>
<li><a href="chap6.html#synchronization-implicit">6.2. Implicit Synchronization Guarantees</a></li>
<li><a href="chap6.html#synchronization-fences">6.3. Fences</a></li>
<li><a href="chap6.html#synchronization-semaphores">6.4. Semaphores</a></li>
<li><a href="chap6.html#synchronization-events">6.5. Events</a></li>
<li><a href="chap6.html#synchronization-pipeline-barriers">6.6. Pipeline Barriers</a></li>
<li><a href="chap6.html#synchronization-memory-barriers">6.7. Memory Barriers</a></li>
<li><a href="chap6.html#synchronization-wait-idle">6.8. Wait Idle Operations</a></li>
<li><a href="chap6.html#synchronization-submission-host-writes">6.9. Host Write Ordering Guarantees</a></li>
<li><a href="chap6.html#synchronization-device-group">6.10. Synchronization and Multiple Physical Devices</a></li>
<li><a href="chap6.html#calibrated-timestamps">6.11. Calibrated timestamps</a></li>
</ul>
</li>
<li><a href="chap7.html#renderpass">7. Render Pass</a>
<ul class="sectlevel2">
<li><a href="chap7.html#renderpass-creation">7.1. Render Pass Creation</a></li>
<li><a href="chap7.html#renderpass-compatibility">7.2. Render Pass Compatibility</a></li>
<li><a href="chap7.html#_framebuffers">7.3. Framebuffers</a></li>
<li><a href="chap7.html#renderpass-commands">7.4. Render Pass Commands</a></li>
</ul>
</li>
<li><a href="chap8.html#shaders">8. Shaders</a>
<ul class="sectlevel2">
<li><a href="chap8.html#shader-modules">8.1. Shader Modules</a></li>
<li><a href="chap8.html#shaders-execution">8.2. Shader Execution</a></li>
<li><a href="chap8.html#shaders-execution-memory-ordering">8.3. Shader Memory Access Ordering</a></li>
<li><a href="chap8.html#shaders-inputs">8.4. Shader Inputs and Outputs</a></li>
<li><a href="chap8.html#shaders-task">8.5. Task Shaders</a></li>
<li><a href="chap8.html#shaders-mesh">8.6. Mesh Shaders</a></li>
<li><a href="chap8.html#shaders-vertex">8.7. Vertex Shaders</a></li>
<li><a href="chap8.html#shaders-tessellation-control">8.8. Tessellation Control Shaders</a></li>
<li><a href="chap8.html#shaders-tessellation-evaluation">8.9. Tessellation Evaluation Shaders</a></li>
<li><a href="chap8.html#shaders-geometry">8.10. Geometry Shaders</a></li>
<li><a href="chap8.html#shaders-fragment">8.11. Fragment Shaders</a></li>
<li><a href="chap8.html#shaders-compute">8.12. Compute Shaders</a></li>
<li><a href="chap8.html#shaders-interpolation-decorations">8.13. Interpolation Decorations</a></li>
<li><a href="chap8.html#shaders-ray-generation">8.14. Ray Generation Shaders</a></li>
<li><a href="chap8.html#shaders-intersection">8.15. Intersection Shaders</a></li>
<li><a href="chap8.html#shaders-any-hit">8.16. Any-Hit Shaders</a></li>
<li><a href="chap8.html#shaders-closest-hit">8.17. Closest Hit Shaders</a></li>
<li><a href="chap8.html#shaders-miss">8.18. Miss Shaders</a></li>
<li><a href="chap8.html#shaders-callable">8.19. Callable Shaders</a></li>
<li><a href="chap8.html#shaders-staticuse">8.20. Static Use</a></li>
<li><a href="chap8.html#shaders-invocationgroups">8.21. Invocation and Derivative Groups</a></li>
<li><a href="chap8.html#shaders-validation-cache">8.22. Validation Cache</a></li>
</ul>
</li>
<li><a href="chap9.html#pipelines">9. Pipelines</a>
<ul class="sectlevel2">
<li><a href="chap9.html#pipelines-compute">9.1. Compute Pipelines</a></li>
<li><a href="chap9.html#pipelines-graphics">9.2. Graphics Pipelines</a></li>
<li><a href="chap9.html#pipelines-destruction">9.3. Pipeline destruction</a></li>
<li><a href="chap9.html#pipelines-multiple">9.4. Multiple Pipeline Creation</a></li>
<li><a href="chap9.html#pipelines-pipeline-derivatives">9.5. Pipeline Derivatives</a></li>
<li><a href="chap9.html#pipelines-cache">9.6. Pipeline Cache</a></li>
<li><a href="chap9.html#pipelines-specialization-constants">9.7. Specialization Constants</a></li>
<li><a href="chap9.html#pipelines-binding">9.8. Pipeline Binding</a></li>
<li><a href="chap9.html#pipelines-dynamic-state">9.9. Dynamic State</a></li>
<li><a href="chap9.html#pipelines-shader-information">9.10. Pipeline Shader Information</a></li>
<li><a href="chap9.html#pipelines-raytracing">9.11. Ray Tracing Pipeline</a></li>
</ul>
</li>
<li><a href="chap10.html#memory">10. Memory Allocation</a>
<ul class="sectlevel2">
<li><a href="chap10.html#memory-host">10.1. Host Memory</a></li>
<li><a href="chap10.html#memory-device">10.2. Device Memory</a></li>
</ul>
</li>
<li><a href="chap11.html#resources">11. Resource Creation</a>
<ul class="sectlevel2">
<li><a href="chap11.html#resources-buffers">11.1. Buffers</a></li>
<li><a href="chap11.html#resources-buffer-views">11.2. Buffer Views</a></li>
<li><a href="chap11.html#resources-images">11.3. Images</a></li>
<li><a href="chap11.html#resources-image-layouts">11.4. Image Layouts</a></li>
<li><a href="chap11.html#resources-image-views">11.5. Image Views</a></li>
<li><a href="chap11.html#resources-association">11.6. Resource Memory Association</a></li>
<li><a href="chap11.html#resources-sharing">11.7. Resource Sharing Mode</a></li>
<li><a href="chap11.html#resources-memory-aliasing">11.8. Memory Aliasing</a></li>
<li><a href="chap11.html#resources-acceleration-structures">11.9. Acceleration Structures</a></li>
</ul>
</li>
<li><a href="chap12.html#samplers">12. Samplers</a>
<ul class="sectlevel2">
<li><a href="chap12.html#samplers-YCbCr-conversion">12.1. Sampler Y’C<sub>B</sub>C<sub>R</sub> conversion</a></li>
</ul>
</li>
<li><a href="chap13.html#descriptorsets">13. Resource Descriptors</a>
<ul class="sectlevel2">
<li><a href="chap13.html#descriptorsets-types">13.1. Descriptor Types</a></li>
<li><a href="chap13.html#descriptorsets-sets">13.2. Descriptor Sets</a></li>
<li><a href="chap13.html#_physical_storage_buffer_access">13.3. Physical Storage Buffer Access</a></li>
</ul>
</li>
<li><a href="chap14.html#interfaces">14. Shader Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap14.html#interfaces-iointerfaces">14.1. Shader Input and Output Interfaces</a></li>
<li><a href="chap14.html#interfaces-vertexinput">14.2. Vertex Input Interface</a></li>
<li><a href="chap14.html#interfaces-fragmentoutput">14.3. Fragment Output Interface</a></li>
<li><a href="chap14.html#interfaces-inputattachment">14.4. Fragment Input Attachment Interface</a></li>
<li><a href="chap14.html#interfaces-resources">14.5. Shader Resource Interface</a></li>
<li><a href="chap14.html#interfaces-builtin-variables">14.6. Built-In Variables</a></li>
</ul>
</li>
<li><a href="chap15.html#textures">15. Image Operations</a>
<ul class="sectlevel2">
<li><a href="chap15.html#_image_operations_overview">15.1. Image Operations Overview</a></li>
<li><a href="chap15.html#_conversion_formulas">15.2. Conversion Formulas</a></li>
<li><a href="chap15.html#_texel_input_operations">15.3. Texel Input Operations</a></li>
<li><a href="chap15.html#_texel_output_operations">15.4. Texel Output Operations</a></li>
<li><a href="chap15.html#_derivative_operations">15.5. Derivative Operations</a></li>
<li><a href="chap15.html#textures-normalized-operations">15.6. Normalized Texel Coordinate Operations</a></li>
<li><a href="chap15.html#_unnormalized_texel_coordinate_operations">15.7. Unnormalized Texel Coordinate Operations</a></li>
<li><a href="chap15.html#textures-integer-coordinate-operations">15.8. Integer Texel Coordinate Operations</a></li>
<li><a href="chap15.html#textures-sample-operations">15.9. Image Sample Operations</a></li>
<li><a href="chap15.html#textures-footprint">15.10. Texel Footprint Evaluation</a></li>
<li><a href="chap15.html#textures-instructions">15.11. Image Operation Steps</a></li>
</ul>
</li>
<li><a href="chap16.html#fragmentdensitymapops">16. Fragment Density Map Operations</a>
<ul class="sectlevel2">
<li><a href="chap16.html#_fragment_density_map_operations_overview">16.1. Fragment Density Map Operations Overview</a></li>
<li><a href="chap16.html#fragmentdensitymap-fetch-density-value">16.2. Fetch Density Value</a></li>
<li><a href="chap16.html#fragmentdensitymap-conversion-to-fragment-area">16.3. Fragment Area Conversion</a></li>
</ul>
</li>
<li><a href="chap17.html#queries">17. Queries</a>
<ul class="sectlevel2">
<li><a href="chap17.html#queries-pools">17.1. Query Pools</a></li>
<li><a href="chap17.html#queries-operation">17.2. Query Operation</a></li>
<li><a href="chap17.html#queries-occlusion">17.3. Occlusion Queries</a></li>
<li><a href="chap17.html#queries-pipestats">17.4. Pipeline Statistics Queries</a></li>
<li><a href="chap17.html#queries-timestamps">17.5. Timestamp Queries</a></li>
<li><a href="chap17.html#queries-transform-feedback">17.6. Transform Feedback Queries</a></li>
</ul>
</li>
<li><a href="chap18.html#clears">18. Clear Commands</a>
<ul class="sectlevel2">
<li><a href="chap18.html#clears-outside">18.1. Clearing Images Outside A Render Pass Instance</a></li>
<li><a href="chap18.html#clears-inside">18.2. Clearing Images Inside A Render Pass Instance</a></li>
<li><a href="chap18.html#clears-values">18.3. Clear Values</a></li>
<li><a href="chap18.html#clears-filling-buffers">18.4. Filling Buffers</a></li>
<li><a href="chap18.html#clears-updating-buffers">18.5. Updating Buffers</a></li>
</ul>
</li>
<li><a href="chap19.html#copies">19. Copy Commands</a>
<ul class="sectlevel2">
<li><a href="chap19.html#_common_operation">19.1. Common Operation</a></li>
<li><a href="chap19.html#copies-buffers">19.2. Copying Data Between Buffers</a></li>
<li><a href="chap19.html#copies-images">19.3. Copying Data Between Images</a></li>
<li><a href="chap19.html#copies-buffers-images">19.4. Copying Data Between Buffers and Images</a></li>
<li><a href="chap19.html#copies-imagescaling">19.5. Image Copies with Scaling</a></li>
<li><a href="chap19.html#copies-resolve">19.6. Resolving Multisample Images</a></li>
<li><a href="chap19.html#copies-buffer-markers">19.7. Buffer Markers</a></li>
</ul>
</li>
<li><a href="chap20.html#drawing">20. Drawing Commands</a>
<ul class="sectlevel2">
<li><a href="chap20.html#drawing-primitive-topologies">20.1. Primitive Topologies</a></li>
<li><a href="chap20.html#drawing-primitive-order">20.2. Primitive Order</a></li>
<li><a href="chap20.html#drawing-primitive-shading">20.3. Programmable Primitive Shading</a></li>
<li><a href="chap20.html#drawing-conditional-rendering">20.4. Conditional Rendering</a></li>
<li><a href="chap20.html#drawing-mesh-shading">20.5. Programmable Mesh Shading</a></li>
</ul>
</li>
<li><a href="chap21.html#fxvertex">21. Fixed-Function Vertex Processing</a>
<ul class="sectlevel2">
<li><a href="chap21.html#fxvertex-attrib">21.1. Vertex Attributes</a></li>
<li><a href="chap21.html#fxvertex-input">21.2. Vertex Input Description</a></li>
<li><a href="chap21.html#_vertex_attribute_divisor_in_instanced_rendering">21.3. Vertex Attribute Divisor in Instanced Rendering</a></li>
<li><a href="chap21.html#fxvertex-example">21.4. Example</a></li>
</ul>
</li>
<li><a href="chap22.html#tessellation">22. Tessellation</a>
<ul class="sectlevel2">
<li><a href="chap22.html#_tessellator">22.1. Tessellator</a></li>
<li><a href="chap22.html#_tessellator_patch_discard">22.2. Tessellator Patch Discard</a></li>
<li><a href="chap22.html#tessellation-tessellator-spacing">22.3. Tessellator Spacing</a></li>
<li><a href="chap22.html#tessellation-primitive-order">22.4. Tessellation Primitive Ordering</a></li>
<li><a href="chap22.html#tessellation-triangle-tessellation">22.5. Triangle Tessellation</a></li>
<li><a href="chap22.html#tessellation-quad-tessellation">22.6. Quad Tessellation</a></li>
<li><a href="chap22.html#tessellation-isoline-tessellation">22.7. Isoline Tessellation</a></li>
<li><a href="chap22.html#_tessellation_pipeline_state">22.8. Tessellation Pipeline State</a></li>
</ul>
</li>
<li><a href="chap23.html#geometry">23. Geometry Shading</a>
<ul class="sectlevel2">
<li><a href="chap23.html#geometry-input">23.1. Geometry Shader Input Primitives</a></li>
<li><a href="chap23.html#geometry-output">23.2. Geometry Shader Output Primitives</a></li>
<li><a href="chap23.html#geometry-invocations">23.3. Multiple Invocations of Geometry Shaders</a></li>
<li><a href="chap23.html#geometry-ordering">23.4. Geometry Shader Primitive Ordering</a></li>
<li><a href="chap23.html#geometry-passthrough">23.5. Geometry Shader Passthrough</a></li>
</ul>
</li>
<li><a href="chap24.html#mesh">24. Mesh Shading</a>
<ul class="sectlevel2">
<li><a href="chap24.html#mesh-task-input">24.1. Task Shader Input</a></li>
<li><a href="chap24.html#mesh-task-output">24.2. Task Shader Output</a></li>
<li><a href="chap24.html#mesh-generation">24.3. Mesh Generation</a></li>
<li><a href="chap24.html#mesh-input">24.4. Mesh Shader Input</a></li>
<li><a href="chap24.html#mesh-output">24.5. Mesh Shader Output Primitives</a></li>
<li><a href="chap24.html#mesh-output-perview">24.6. Mesh Shader Per-View Outputs</a></li>
<li><a href="chap24.html#mesh-ordering">24.7. Mesh Shader Primitive Ordering</a></li>
</ul>
</li>
<li><a href="chap25.html#vertexpostproc">25. Fixed-Function Vertex Post-Processing</a>
<ul class="sectlevel2">
<li><a href="chap25.html#vertexpostproc-transform-feedback">25.1. Transform Feedback</a></li>
<li><a href="chap25.html#vertexpostproc-viewport-swizzle">25.2. Viewport Swizzle</a></li>
<li><a href="chap25.html#vertexpostproc-flatshading">25.3. Flat Shading</a></li>
<li><a href="chap25.html#vertexpostproc-clipping">25.4. Primitive Clipping</a></li>
<li><a href="chap25.html#vertexpostproc-clipping-shader-outputs">25.5. Clipping Shader Outputs</a></li>
<li><a href="chap25.html#vertexpostproc-viewportwscaling">25.6. Controlling Viewport W Scaling</a></li>
<li><a href="chap25.html#vertexpostproc-coord-transform">25.7. Coordinate Transformations</a></li>
<li><a href="chap25.html#vertexpostproc-viewport">25.8. Controlling the Viewport</a></li>
</ul>
</li>
<li><a href="chap26.html#primsrast">26. Rasterization</a>
<ul class="sectlevel2">
<li><a href="chap26.html#primsrast-discard">26.1. Discarding Primitives Before Rasterization</a></li>
<li><a href="chap26.html#primsrast-stream">26.2. Controlling the Vertex Stream Used for Rasterization</a></li>
<li><a href="chap26.html#primrast-order">26.3. Rasterization Order</a></li>
<li><a href="chap26.html#primsrast-multisampling">26.4. Multisampling</a></li>
<li><a href="chap26.html#primrast-samplelocations">26.5. Custom Sample Locations</a></li>
<li><a href="chap26.html#primsrast-shading-rate-image">26.6. Shading Rate Image</a></li>
<li><a href="chap26.html#primsrast-sampleshading">26.7. Sample Shading</a></li>
<li><a href="chap26.html#primsrast-barycentric">26.8. Barycentric Interpolation</a></li>
<li><a href="chap26.html#primsrast-points">26.9. Points</a></li>
<li><a href="chap26.html#primsrast-lines">26.10. Line Segments</a></li>
<li><a href="chap26.html#primsrast-polygons">26.11. Polygons</a></li>
</ul>
</li>
<li><a href="chap27.html#fragops">27. Fragment Operations</a>
<ul class="sectlevel2">
<li><a href="chap27.html#fragops-early">27.1. Early Per-Fragment Tests</a></li>
<li><a href="chap27.html#fragops-discard-rectangles">27.2. Discard Rectangles Test</a></li>
<li><a href="chap27.html#fragops-scissor">27.3. Scissor Test</a></li>
<li><a href="chap27.html#fragops-exclusive-scissor">27.4. Exclusive Scissor Test</a></li>
<li><a href="chap27.html#fragops-samplemask">27.5. Sample Mask</a></li>
<li><a href="chap27.html#fragops-early-mode">27.6. Early Fragment Test Mode</a></li>
<li><a href="chap27.html#fragops-late">27.7. Late Per-Fragment Tests</a></li>
<li><a href="chap27.html#fragops-mixed-attachment-samples">27.8. Mixed attachment samples</a></li>
<li><a href="chap27.html#fragops-covg">27.9. Multisample Coverage</a></li>
<li><a href="chap27.html#fragops-ds-state">27.10. Depth and Stencil Operations</a></li>
<li><a href="chap27.html#fragops-dbt">27.11. Depth Bounds Test</a></li>
<li><a href="chap27.html#fragops-stencil">27.12. Stencil Test</a></li>
<li><a href="chap27.html#fragops-depth">27.13. Depth Test</a></li>
<li><a href="chap27.html#fragops-rep-frag-test">27.14. Representative Fragment Test</a></li>
<li><a href="chap27.html#fragops-samplecount">27.15. Sample Counting</a></li>
<li><a href="chap27.html#fragops-coverage-to-color">27.16. Fragment Coverage To Color</a></li>
<li><a href="chap27.html#fragops-coverage-reduction">27.17. Coverage Reduction</a></li>
</ul>
</li>
<li><a href="chap28.html#framebuffer">28. The Framebuffer</a>
<ul class="sectlevel2">
<li><a href="chap28.html#framebuffer-blending">28.1. Blending</a></li>
<li><a href="chap28.html#framebuffer-logicop">28.2. Logical Operations</a></li>
<li><a href="chap28.html#framebuffer-color-write-mask">28.3. Color Write Mask</a></li>
</ul>
</li>
<li><a href="chap29.html#dispatch">29. Dispatching Commands</a></li>
<li><a href="chap30.html#device-generated-commands">30. Device-Generated Commands</a>
<ul class="sectlevel2">
<li><a href="chap30.html#_features_and_limitations">30.1. Features and Limitations</a></li>
<li><a href="chap30.html#_binding_object_table">30.2. Binding Object Table</a></li>
<li><a href="chap30.html#indirectmdslayout">30.3. Indirect Commands Layout</a></li>
<li><a href="chap30.html#_indirect_commands_generation">30.4. Indirect Commands Generation</a></li>
</ul>
</li>
<li><a href="chap31.html#sparsememory">31. Sparse Resources</a>
<ul class="sectlevel2">
<li><a href="chap31.html#sparsememory-sparseresourcefeatures">31.1. Sparse Resource Features</a></li>
<li><a href="chap31.html#sparsememory-fully-resident">31.2. Sparse Buffers and Fully-Resident Images</a></li>
<li><a href="chap31.html#sparsememory-partially-resident-buffers">31.3. Sparse Partially-Resident Buffers</a></li>
<li><a href="chap31.html#sparsememory-partially-resident-images">31.4. Sparse Partially-Resident Images</a></li>
<li><a href="chap31.html#sparsememory-sparse-memory-aliasing">31.5. Sparse Memory Aliasing</a></li>
<li><a href="chap31.html#_sparse_resource_implementation_guidelines">31.6. Sparse Resource Implementation Guidelines</a></li>
<li><a href="chap31.html#sparsememory-resourceapi">31.7. Sparse Resource API</a></li>
<li><a href="chap31.html#sparsememory-examples">31.8. Examples</a></li>
</ul>
</li>
<li><a href="#wsi">32. Window System Integration (WSI)</a>
<ul class="sectlevel2">
<li><a href="#_wsi_platform">32.1. WSI Platform</a></li>
<li><a href="#_wsi_surface">32.2. WSI Surface</a></li>
<li><a href="#display">32.3. Presenting Directly to Display Devices</a></li>
<li><a href="#_querying_for_wsi_support">32.4. Querying for WSI Support</a></li>
<li><a href="#_surface_queries">32.5. Surface Queries</a></li>
<li><a href="#_device_group_queries">32.6. Device Group Queries</a></li>
<li><a href="#_display_timing_queries">32.7. Display Timing Queries</a></li>
<li><a href="#_wsi_swapchain">32.8. WSI Swapchain</a></li>
<li><a href="#_hdr_metadata">32.9. Hdr Metadata</a></li>
</ul>
</li>
<li><a href="chap33.html#raytracing">33. Ray Tracing</a>
<ul class="sectlevel2">
<li><a href="chap33.html#raytracing-commands">33.1. Ray Tracing Commands</a></li>
<li><a href="chap33.html#shader-binding-table">33.2. Shader Binding Table</a></li>
<li><a href="chap33.html#acceleration-structure">33.3. Acceleration Structures</a></li>
</ul>
</li>
<li><a href="chap34.html#extended-functionality">34. Extended Functionality</a>
<ul class="sectlevel2">
<li><a href="chap34.html#extended-functionality-layers">34.1. Layers</a></li>
<li><a href="chap34.html#extended-functionality-extensions">34.2. Extensions</a></li>
<li><a href="chap34.html#extended-functionality-extensions-dependencies">34.3. Extension Dependencies</a></li>
<li><a href="chap34.html#extended-functionality-extensions-compatibility">34.4. Extension Compatibility</a></li>
</ul>
</li>
<li><a href="chap35.html#features">35. Features, Limits, and Formats</a>
<ul class="sectlevel2">
<li><a href="chap35.html#features-features">35.1. Features</a></li>
<li><a href="chap35.html#features-limits">35.2. Limits</a></li>
<li><a href="chap35.html#features-limits-multisample">35.3. Additional Multisampling Capabilities</a></li>
<li><a href="chap35.html#features-formats">35.4. Formats</a></li>
<li><a href="chap35.html#_additional_image_capabilities">35.5. Additional Image Capabilities</a></li>
<li><a href="chap35.html#_additional_buffer_capabilities">35.6. Additional Buffer Capabilities</a></li>
<li><a href="chap35.html#_optional_semaphore_capabilities">35.7. Optional Semaphore Capabilities</a></li>
<li><a href="chap35.html#_optional_fence_capabilities">35.8. Optional Fence Capabilities</a></li>
<li><a href="chap35.html#features-timestamp-calibration">35.9. Timestamp Calibration Capabilities</a></li>
</ul>
</li>
<li><a href="chap36.html#_debugging">36. Debugging</a>
<ul class="sectlevel2">
<li><a href="chap36.html#debugging-debug-utils">36.1. Debug Utilities</a></li>
<li><a href="chap36.html#debugging-debug-markers">36.2. Debug Markers</a></li>
<li><a href="chap36.html#debugging-debug-report-callbacks">36.3. Debug Report Callbacks</a></li>
<li><a href="chap36.html#_device_loss_debugging">36.4. Device Loss Debugging</a></li>
</ul>
</li>
<li><a href="chap37.html#spirvenv">Appendix A: Vulkan Environment for SPIR-V</a>
<ul class="sectlevel2">
<li><a href="chap37.html#_versions_and_formats">Versions and Formats</a></li>
<li><a href="chap37.html#spirvenv-capabilities">Capabilities</a></li>
<li><a href="chap37.html#spirvenv-module-validation">Validation Rules within a Module</a></li>
<li><a href="chap37.html#spirvenv-precision-operation">Precision and Operation of SPIR-V Instructions</a></li>
<li><a href="chap37.html#spirvenv-image-formats">Compatibility Between SPIR-V Image Formats And Vulkan Formats</a></li>
</ul>
</li>
<li><a href="chap38.html#memory-model">Appendix B: Memory Model</a>
<ul class="sectlevel2">
<li><a href="chap38.html#memory-model-agent">Agent</a></li>
<li><a href="chap38.html#memory-model-memory-location">Memory Location</a></li>
<li><a href="chap38.html#memory-model-allocation">Allocation</a></li>
<li><a href="chap38.html#memory-model-memory-operation">Memory Operation</a></li>
<li><a href="chap38.html#memory-model-references">Reference</a></li>
<li><a href="chap38.html#memory-model-program-order">Program-Order</a></li>
<li><a href="chap38.html#memory-model-scope">Scope</a></li>
<li><a href="chap38.html#memory-model-atomic-operation">Atomic Operation</a></li>
<li><a href="chap38.html#memory-model-scoped-modification-order">Scoped Modification Order</a></li>
<li><a href="chap38.html#memory-model-memory-semantics">Memory Semantics</a></li>
<li><a href="chap38.html#memory-model-release-sequence">Release Sequence</a></li>
<li><a href="chap38.html#memory-model-synchronizes-with">Synchronizes-With</a></li>
<li><a href="chap38.html#memory-model-system-synchronizes-with">System-Synchronizes-With</a></li>
<li><a href="chap38.html#memory-model-non-private">Private vs. Non-Private</a></li>
<li><a href="chap38.html#memory-model-inter-thread-happens-before">Inter-Thread-Happens-Before</a></li>
<li><a href="chap38.html#memory-model-happens-before">Happens-Before</a></li>
<li><a href="chap38.html#memory-model-availability-visibility">Availability and Visibility</a></li>
<li><a href="chap38.html#memory-model-vulkan-availability-visibility">Availability, Visibility, and Domain Operations</a></li>
<li><a href="chap38.html#memory-model-availability-visibility-semantics">Availability and Visibility Semantics</a></li>
<li><a href="chap38.html#memory-model-instruction-av-vis">Per-Instruction Availability and Visibility Semantics</a></li>
<li><a href="chap38.html#memory-model-location-ordered">Location-Ordered</a></li>
<li><a href="chap38.html#memory-model-access-data-race">Data Race</a></li>
<li><a href="chap38.html#memory-model-visible-to">Visible-To</a></li>
<li><a href="chap38.html#memory-model-scoped-modification-order-coherence">Scoped Modification Order Coherence</a></li>
<li><a href="chap38.html#memory-model-shader-io">Shader I/O</a></li>
<li><a href="chap38.html#memory-model-deallocation">Deallocation</a></li>
<li><a href="chap38.html#memory-model-informative-descriptions">Informative Descriptions</a></li>
<li><a href="chap38.html#memory-model-tessellation-output-ordering">Tessellation Output Ordering</a></li>
</ul>
</li>
<li><a href="chap39.html#_compressed_image_formats">Appendix C: Compressed Image Formats</a>
<ul class="sectlevel2">
<li><a href="chap39.html#appendix-compressedtex-bc">Block-Compressed Image Formats</a></li>
<li><a href="chap39.html#appendix-compressedtex-etc2">ETC Compressed Image Formats</a></li>
<li><a href="chap39.html#appendix-compressedtex-astc">ASTC Compressed Image Formats</a></li>
</ul>
</li>
<li><a href="chap40.html#extensions">Appendix D: Layers &amp; Extensions (Informative)</a>
<ul class="sectlevel2">
<li><a href="chap40.html#extension-appendices-list">List of Current Extensions</a></li>
<li><a href="chap40.html#provisional-extension-appendices-list">List of Provisional Extensions</a></li>
<li><a href="chap40.html#deprecated-extension-appendices-list">List of Deprecated Extensions</a></li>
</ul>
</li>
<li><a href="chap41.html#boilerplate">Appendix E: API Boilerplate</a>
<ul class="sectlevel2">
<li><a href="chap41.html#boilerplate-headers">Vulkan Header Files</a></li>
<li><a href="chap41.html#boilerplate-wsi-header">Window System-Specific Header Control (Informative)</a></li>
</ul>
</li>
<li><a href="chap42.html#invariance">Appendix F: Invariance</a>
<ul class="sectlevel2">
<li><a href="chap42.html#_repeatability">Repeatability</a></li>
<li><a href="chap42.html#_multi_pass_algorithms">Multi-pass Algorithms</a></li>
<li><a href="chap42.html#_invariance_rules">Invariance Rules</a></li>
<li><a href="chap42.html#_tessellation_invariance">Tessellation Invariance</a></li>
</ul>
</li>
<li><a href="chap43.html#glossary">Glossary</a></li>
<li><a href="chap44.html#_common_abbreviations">Common Abbreviations</a></li>
<li><a href="chap45.html#_prefixes">Prefixes</a></li>
<li><a href="chap46.html#credits">Appendix G: Credits (Informative)</a>
<ul class="sectlevel2">
<li><a href="chap46.html#_working_group_contributors_to_vulkan_1_1_and_1_0">Working Group Contributors to Vulkan 1.1 and 1.0</a></li>
<li><a href="chap46.html#_working_group_contributors_to_vulkan_1_1">Working Group Contributors to Vulkan 1.1</a></li>
<li><a href="chap46.html#_working_group_contributors_to_vulkan_1_0">Working Group Contributors to Vulkan 1.0</a></li>
<li><a href="chap46.html#_other_credits">Other Credits</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content"><div class="sect1">
<h2 id="wsi">32. Window System Integration (WSI)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter discusses the window system integration (WSI) between the
Vulkan API and the various forms of displaying the results of rendering to a
user.
Since the Vulkan API <strong class="purple">can</strong> be used without displaying results, WSI is
provided through the use of optional Vulkan extensions.
This chapter provides an overview of WSI.
See the appendix for additional details of each WSI extension, including
which extensions <strong class="purple">must</strong> be enabled in order to use each of the functions
described in this chapter.</p>
</div>
<div class="sect2">
<h3 id="_wsi_platform">32.1. WSI Platform</h3>
<div class="paragraph">
<p>A platform is an abstraction for a window system, OS, etc.
Some examples include MS Windows, Android, and Wayland.
The Vulkan API <strong class="purple">may</strong> be integrated in a unique manner for each platform.</p>
</div>
<div class="paragraph">
<p>The Vulkan API does not define any type of platform object.
Platform-specific WSI extensions are defined, which contain
platform-specific functions for using WSI.
Use of these extensions is guarded by preprocessor symbols as defined in the
<a href="chap41.html#boilerplate-wsi-header">Window System-Specific Header Control</a> appendix.</p>
</div>
<div class="paragraph">
<p>In order for an application to be compiled to use WSI with a given platform,
it must either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>#define the appropriate preprocessor symbol prior to including the
<code>vulkan.h</code> header file, or</p>
</li>
<li>
<p>include <code>vulkan_core.h</code> and any native platform headers, followed by the
appropriate platform-specific header.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The preprocessor symbols and platform-specific headers are defined in the
<a href="chap41.html#boilerplate-wsi-header-table">Window System Extensions and Headers</a>
table.</p>
</div>
<div class="paragraph">
<p>Each platform-specific extension is an instance extension.
The application <strong class="purple">must</strong> enable instance extensions with <code>vkCreateInstance</code>
before using them.</p>
</div>
</div>
<div class="sect2">
<h3 id="_wsi_surface">32.2. WSI Surface</h3>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Native platform surface or window objects are abstracted by surface objects,
which are represented by <code>VkSurfaceKHR</code> handles:</p>
</div>
<div id="VkSurfaceKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>VK_KHR_surface</code> extension declares the <code>VkSurfaceKHR</code> object, and
provides a function for destroying <code>VkSurfaceKHR</code> objects.
Separate platform-specific extensions each provide a function for creating a
<code>VkSurfaceKHR</code> object for the respective platform.
From the application’s perspective this is an opaque handle, just like the
handles of other Vulkan objects.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>On certain platforms, the Vulkan loader and ICDs <strong class="purple">may</strong> have conventions that
treat the handle as a pointer to a struct that contains the
platform-specific information about the surface.
This will be described in the documentation for the loader-ICD interface,
and in the <code>vk_icd.h</code> header file of the LoaderAndTools source-code
repository.
This does not affect the loader-layer interface; layers <strong class="purple">may</strong> wrap
<code>VkSurfaceKHR</code> objects.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="platformCreateSurface_android">32.2.1. Android Platform</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create a <code>VkSurfaceKHR</code> object for an Android native window, call:</p>
</div>
<div id="vkCreateAndroidSurfaceKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateAndroidSurfaceKHR(
    VkInstance                                  instance,
    <span class="directive">const</span> VkAndroidSurfaceCreateInfoKHR*        pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>instance</code> is the instance to associate the surface with.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to an instance of the
<code>VkAndroidSurfaceCreateInfoKHR</code> structure containing parameters
affecting the creation of the surface object.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
surface object when there is no more specific allocator available (see
<a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
<li>
<p><code>pSurface</code> points to a <a href="#VkSurfaceKHR">VkSurfaceKHR</a> handle in which the
created surface object is returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>During the lifetime of a surface created using a particular
<a href="#ANativeWindow">ANativeWindow</a> handle any attempts to create another surface for the
same <a href="#ANativeWindow">ANativeWindow</a> and any attempts to connect to the same
<a href="#ANativeWindow">ANativeWindow</a> through other platform mechanisms will fail.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>In particular, only one <code>VkSurfaceKHR</code> <strong class="purple">can</strong> exist at a time for a given
window.
Similarly, a native window <strong class="purple">cannot</strong> be used by both a <code>VkSurfaceKHR</code> and
<code>EGLSurface</code> simultaneously.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If successful, <code>vkCreateAndroidSurfaceKHR</code> increments the
<a href="#ANativeWindow">ANativeWindow</a>’s reference count, and <code>vkDestroySurfaceKHR</code> will
decrement it.</p>
</div>
<div class="paragraph">
<p>On Android, when a swapchain’s <code>imageExtent</code> does not match the
surface’s <code>currentExtent</code>, the presentable images will be scaled to the
surface’s dimensions during presentation.
<code>minImageExtent</code> is <span class="eq">(1,1)</span>, and <code>maxImageExtent</code> is the maximum
image size supported by the consumer.
For the system compositor, <code>currentExtent</code> is the window size (i.e. the
consumer’s preferred size).</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateAndroidSurfaceKHR-instance-parameter"></a> <code>instance</code> <strong class="purple">must</strong> be a valid <code>VkInstance</code> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateAndroidSurfaceKHR-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAndroidSurfaceCreateInfoKHR</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateAndroidSurfaceKHR-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateAndroidSurfaceKHR-pSurface-parameter"></a> <code>pSurface</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkSurfaceKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_NATIVE_WINDOW_IN_USE_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkAndroidSurfaceCreateInfoKHR</code> structure is defined as:</p>
</div>
<div id="VkAndroidSurfaceCreateInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkAndroidSurfaceCreateInfoKHR {
    VkStructureType                   sType;
    <span class="directive">const</span> <span class="directive">void</span>*                       pNext;
    VkAndroidSurfaceCreateFlagsKHR    flags;
    <span class="keyword">struct</span> ANativeWindow*             window;
} VkAndroidSurfaceCreateInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
<li>
<p><code>window</code> is a pointer to the <a href="#ANativeWindow">ANativeWindow</a> to associate the
surface with.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkAndroidSurfaceCreateInfoKHR-window-01248"></a>
<code>window</code> <strong class="purple">must</strong> point to a valid Android <a href="#ANativeWindow">ANativeWindow</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkAndroidSurfaceCreateInfoKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkAndroidSurfaceCreateInfoKHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkAndroidSurfaceCreateInfoKHR-flags-zerobitmask"></a> <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To remove an unnecessary compile-time dependency, an incomplete type
definition of <a href="#ANativeWindow">ANativeWindow</a> is provided in the Vulkan headers:</p>
</div>
<div id="ANativeWindow" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">struct</span> ANativeWindow;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The actual <a href="#ANativeWindow">ANativeWindow</a> type is defined in Android NDK headers.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="platformCreateSurface_wayland">32.2.2. Wayland Platform</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create a <code>VkSurfaceKHR</code> object for a Wayland surface, call:</p>
</div>
<div id="vkCreateWaylandSurfaceKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateWaylandSurfaceKHR(
    VkInstance                                  instance,
    <span class="directive">const</span> VkWaylandSurfaceCreateInfoKHR*        pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>instance</code> is the instance to associate the surface with.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to an instance of the
<a href="#VkWaylandSurfaceCreateInfoKHR">VkWaylandSurfaceCreateInfoKHR</a> structure containing parameters
affecting the creation of the surface object.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
surface object when there is no more specific allocator available (see
<a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
<li>
<p><code>pSurface</code> points to a <a href="#VkSurfaceKHR">VkSurfaceKHR</a> handle in which the
created surface object is returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateWaylandSurfaceKHR-instance-parameter"></a> <code>instance</code> <strong class="purple">must</strong> be a valid <code>VkInstance</code> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateWaylandSurfaceKHR-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkWaylandSurfaceCreateInfoKHR</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateWaylandSurfaceKHR-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateWaylandSurfaceKHR-pSurface-parameter"></a> <code>pSurface</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkSurfaceKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkWaylandSurfaceCreateInfoKHR</code> structure is defined as:</p>
</div>
<div id="VkWaylandSurfaceCreateInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkWaylandSurfaceCreateInfoKHR {
    VkStructureType                   sType;
    <span class="directive">const</span> <span class="directive">void</span>*                       pNext;
    VkWaylandSurfaceCreateFlagsKHR    flags;
    <span class="keyword">struct</span> wl_display*                display;
    <span class="keyword">struct</span> wl_surface*                surface;
} VkWaylandSurfaceCreateInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
<li>
<p><code>display</code> and <code>surface</code> are pointers to the Wayland
<code>wl_display</code> and <code>wl_surface</code> to associate the surface with.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWaylandSurfaceCreateInfoKHR-display-01304"></a>
<code>display</code> <strong class="purple">must</strong> point to a valid Wayland <code>wl_display</code>.</p>
</li>
<li>
<p><a id="VUID-VkWaylandSurfaceCreateInfoKHR-surface-01305"></a>
<code>surface</code> <strong class="purple">must</strong> point to a valid Wayland <code>wl_surface</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWaylandSurfaceCreateInfoKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkWaylandSurfaceCreateInfoKHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkWaylandSurfaceCreateInfoKHR-flags-zerobitmask"></a> <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>On Wayland, <code>currentExtent</code> is the special value <span class="eq">(0xFFFFFFFF,
0xFFFFFFFF)</span>, indicating that the surface size will be determined by the
extent of a swapchain targeting the surface.
Whatever the application sets a swapchain’s <code>imageExtent</code> to will be the
size of the window, after the first image is presented.
<code>minImageExtent</code> is <span class="eq">(1,1)</span>, and <code>maxImageExtent</code> is the maximum
supported surface size.
Any calls to <a href="#vkGetPhysicalDeviceSurfacePresentModesKHR">vkGetPhysicalDeviceSurfacePresentModesKHR</a> on a surface
created with <code>vkCreateWaylandSurfaceKHR</code> are <strong class="purple">required</strong> to return
<code>VK_PRESENT_MODE_MAILBOX_KHR</code> as one of the valid present modes.</p>
</div>
<div class="paragraph">
<p>Some Vulkan functions <strong class="purple">may</strong> send protocol over the specified <code>wl_display</code>
connection when using a swapchain or presentable images created from a
<code>VkSurfaceKHR</code> referring to a <code>wl_surface</code>.
Applications <strong class="purple">must</strong> therefore ensure that both the <code>wl_display</code> and the
<code>wl_surface</code> remain valid for the lifetime of any <code>VkSwapchainKHR</code>
objects created from a particular <code>wl_display</code> and <code>wl_surface</code>.
Also, calling <a href="#vkQueuePresentKHR">vkQueuePresentKHR</a> will result in Vulkan sending
<code>wl_surface</code>.commit requests to the underlying <code>wl_surface</code> of each
<code>VkSwapchainKHR</code> objects referenced by <code>pPresentInfo</code>.
If the swapchain is created with a present mode of
<code>VK_PRESENT_MODE_MAILBOX_KHR</code> or <code>VK_PRESENT_MODE_IMMEDIATE_KHR</code>,
then the corresponding <code>wl_surface</code>.attach, <code>wl_surface</code>.damage, and
<code>wl_surface</code>.commit request <strong class="purple">must</strong> be issued by the implementation during
the call to <a href="#vkQueuePresentKHR">vkQueuePresentKHR</a> and <strong class="purple">must</strong> not be issued by the
implementation outside of <a href="#vkQueuePresentKHR">vkQueuePresentKHR</a>.
This ensures that any Wayland requests sent by the client after the call to
<a href="#vkQueuePresentKHR">vkQueuePresentKHR</a> returns will be received by the compositor after the
<code>wl_surface</code>.commit.
Regardless of the mode of swapchain creation, a new <code>wl_event_queue</code>
<strong class="purple">must</strong> be created for each successful <a href="#vkCreateWaylandSurfaceKHR">vkCreateWaylandSurfaceKHR</a> call,
and every Wayland object created by the implementation <strong class="purple">must</strong> be assigned to
this event queue.
If the platform provides Wayland 1.11 or greater, this <strong class="purple">must</strong> be implemented
by the use of Wayland proxy object wrappers, to avoid race conditions.</p>
</div>
<div class="paragraph">
<p>If the application wishes to synchronize any window changes with a
particular frame, such requests <strong class="purple">must</strong> be sent to the Wayland display server
prior to calling <a href="#vkQueuePresentKHR">vkQueuePresentKHR</a>.
For full control over interactions between Vulkan rendering and other
Wayland protocol requests and events, a present mode of
<code>VK_PRESENT_MODE_MAILBOX_KHR</code> <strong class="purple">should</strong> be used.</p>
</div>
</div>
<div class="sect3">
<h4 id="platformCreateSurface_win32">32.2.3. Win32 Platform</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create a <code>VkSurfaceKHR</code> object for a Win32 window, call:</p>
</div>
<div id="vkCreateWin32SurfaceKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateWin32SurfaceKHR(
    VkInstance                                  instance,
    <span class="directive">const</span> VkWin32SurfaceCreateInfoKHR*          pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>instance</code> is the instance to associate the surface with.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to an instance of the
<code>VkWin32SurfaceCreateInfoKHR</code> structure containing parameters
affecting the creation of the surface object.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
surface object when there is no more specific allocator available (see
<a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
<li>
<p><code>pSurface</code> points to a <a href="#VkSurfaceKHR">VkSurfaceKHR</a> handle in which the
created surface object is returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateWin32SurfaceKHR-instance-parameter"></a> <code>instance</code> <strong class="purple">must</strong> be a valid <code>VkInstance</code> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateWin32SurfaceKHR-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkWin32SurfaceCreateInfoKHR</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateWin32SurfaceKHR-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateWin32SurfaceKHR-pSurface-parameter"></a> <code>pSurface</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkSurfaceKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkWin32SurfaceCreateInfoKHR</code> structure is defined as:</p>
</div>
<div id="VkWin32SurfaceCreateInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkWin32SurfaceCreateInfoKHR {
    VkStructureType                 sType;
    <span class="directive">const</span> <span class="directive">void</span>*                     pNext;
    VkWin32SurfaceCreateFlagsKHR    flags;
    HINSTANCE                       hinstance;
    HWND                            hwnd;
} VkWin32SurfaceCreateInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
<li>
<p><code>hinstance</code> and <code>hwnd</code> are the Win32 <code>HINSTANCE</code> and
<code>HWND</code> for the window to associate the surface with.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWin32SurfaceCreateInfoKHR-hinstance-01307"></a>
<code>hinstance</code> <strong class="purple">must</strong> be a valid Win32 <code>HINSTANCE</code>.</p>
</li>
<li>
<p><a id="VUID-VkWin32SurfaceCreateInfoKHR-hwnd-01308"></a>
<code>hwnd</code> <strong class="purple">must</strong> be a valid Win32 <code>HWND</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWin32SurfaceCreateInfoKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkWin32SurfaceCreateInfoKHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkWin32SurfaceCreateInfoKHR-flags-zerobitmask"></a> <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>With Win32, <code>minImageExtent</code>, <code>maxImageExtent</code>, and
<code>currentExtent</code> <strong class="purple">must</strong> always equal the window size.</p>
</div>
<div class="paragraph">
<p>The <code>currentExtent</code> of a Win32 surface <strong class="purple">must</strong> have both <code>width</code> and
<code>height</code> greater than 0, or both of them 0.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Due to above restrictions, it is only possible to create a new swapchain on
this platform with <code>imageExtent</code> being equal to the current size of the
window.</p>
</div>
<div class="paragraph">
<p>The window size <strong class="purple">may</strong> become <span class="eq">(0, 0)</span> on this platform (e.g. when the
window is minimized), and so a swapchain <strong class="purple">cannot</strong> be created until the size
changes.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="platformCreateSurface_xcb">32.2.4. XCB Platform</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create a <code>VkSurfaceKHR</code> object for an X11 window, using the XCB
client-side library, call:</p>
</div>
<div id="vkCreateXcbSurfaceKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateXcbSurfaceKHR(
    VkInstance                                  instance,
    <span class="directive">const</span> VkXcbSurfaceCreateInfoKHR*            pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>instance</code> is the instance to associate the surface with.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to an instance of the
<code>VkXcbSurfaceCreateInfoKHR</code> structure containing parameters
affecting the creation of the surface object.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
surface object when there is no more specific allocator available (see
<a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
<li>
<p><code>pSurface</code> points to a <a href="#VkSurfaceKHR">VkSurfaceKHR</a> handle in which the
created surface object is returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateXcbSurfaceKHR-instance-parameter"></a> <code>instance</code> <strong class="purple">must</strong> be a valid <code>VkInstance</code> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateXcbSurfaceKHR-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkXcbSurfaceCreateInfoKHR</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateXcbSurfaceKHR-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateXcbSurfaceKHR-pSurface-parameter"></a> <code>pSurface</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkSurfaceKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkXcbSurfaceCreateInfoKHR</code> structure is defined as:</p>
</div>
<div id="VkXcbSurfaceCreateInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkXcbSurfaceCreateInfoKHR {
    VkStructureType               sType;
    <span class="directive">const</span> <span class="directive">void</span>*                   pNext;
    VkXcbSurfaceCreateFlagsKHR    flags;
    xcb_connection_t*             connection;
    xcb_window_t                  window;
} VkXcbSurfaceCreateInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
<li>
<p><code>connection</code> is a pointer to an <code>xcb_connection_t</code> to the X
server.</p>
</li>
<li>
<p><code>window</code> is the <code>xcb_window_t</code> for the X11 window to associate
the surface with.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkXcbSurfaceCreateInfoKHR-connection-01310"></a>
<code>connection</code> <strong class="purple">must</strong> point to a valid X11 <code>xcb_connection_t</code>.</p>
</li>
<li>
<p><a id="VUID-VkXcbSurfaceCreateInfoKHR-window-01311"></a>
<code>window</code> <strong class="purple">must</strong> be a valid X11 <code>xcb_window_t</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkXcbSurfaceCreateInfoKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkXcbSurfaceCreateInfoKHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkXcbSurfaceCreateInfoKHR-flags-zerobitmask"></a> <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>With Xcb, <code>minImageExtent</code>, <code>maxImageExtent</code>, and
<code>currentExtent</code> <strong class="purple">must</strong> always equal the window size.</p>
</div>
<div class="paragraph">
<p>The <code>currentExtent</code> of an Xcb surface <strong class="purple">must</strong> have both <code>width</code> and
<code>height</code> greater than 0, or both of them 0.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Due to above restrictions, it is only possible to create a new swapchain on
this platform with <code>imageExtent</code> being equal to the current size of the
window.</p>
</div>
<div class="paragraph">
<p>The window size <strong class="purple">may</strong> become <span class="eq">(0, 0)</span> on this platform (e.g. when the
window is minimized), and so a swapchain <strong class="purple">cannot</strong> be created until the size
changes.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Some Vulkan functions <strong class="purple">may</strong> send protocol over the specified xcb connection
when using a swapchain or presentable images created from a
<a href="#VkSurfaceKHR">VkSurfaceKHR</a> referring to an xcb window.
Applications <strong class="purple">must</strong> therefore ensure the xcb connection is available to
Vulkan for the duration of any functions that manipulate such swapchains or
their presentable images, and any functions that build or queue command
buffers that operate on such presentable images.
Specifically, applications using Vulkan with xcb-based swapchains <strong class="purple">must</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Avoid holding a server grab on an xcb connection while waiting for
Vulkan operations to complete using a swapchain derived from a different
xcb connection referring to the same X server instance.
Failing to do so <strong class="purple">may</strong> result in deadlock.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="platformCreateSurface_xlib">32.2.5. Xlib Platform</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create a <code>VkSurfaceKHR</code> object for an X11 window, using the Xlib
client-side library, call:</p>
</div>
<div id="vkCreateXlibSurfaceKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateXlibSurfaceKHR(
    VkInstance                                  instance,
    <span class="directive">const</span> VkXlibSurfaceCreateInfoKHR*           pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>instance</code> is the instance to associate the surface with.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to an instance of the
<code>VkXlibSurfaceCreateInfoKHR</code> structure containing the parameters
affecting the creation of the surface object.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
surface object when there is no more specific allocator available (see
<a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
<li>
<p><code>pSurface</code> points to a <a href="#VkSurfaceKHR">VkSurfaceKHR</a> handle in which the
created surface object is returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateXlibSurfaceKHR-instance-parameter"></a> <code>instance</code> <strong class="purple">must</strong> be a valid <code>VkInstance</code> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateXlibSurfaceKHR-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkXlibSurfaceCreateInfoKHR</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateXlibSurfaceKHR-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateXlibSurfaceKHR-pSurface-parameter"></a> <code>pSurface</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkSurfaceKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkXlibSurfaceCreateInfoKHR</code> structure is defined as:</p>
</div>
<div id="VkXlibSurfaceCreateInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkXlibSurfaceCreateInfoKHR {
    VkStructureType                sType;
    <span class="directive">const</span> <span class="directive">void</span>*                    pNext;
    VkXlibSurfaceCreateFlagsKHR    flags;
    Display*                       dpy;
    Window                         window;
} VkXlibSurfaceCreateInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
<li>
<p><code>dpy</code> is a pointer to an Xlib <code>Display</code> connection to the X
server.</p>
</li>
<li>
<p><code>window</code> is an Xlib <code>Window</code> to associate the surface with.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkXlibSurfaceCreateInfoKHR-dpy-01313"></a>
<code>dpy</code> <strong class="purple">must</strong> point to a valid Xlib <code>Display</code>.</p>
</li>
<li>
<p><a id="VUID-VkXlibSurfaceCreateInfoKHR-window-01314"></a>
<code>window</code> <strong class="purple">must</strong> be a valid Xlib <code>Window</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkXlibSurfaceCreateInfoKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkXlibSurfaceCreateInfoKHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkXlibSurfaceCreateInfoKHR-flags-zerobitmask"></a> <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>With Xlib, <code>minImageExtent</code>, <code>maxImageExtent</code>, and
<code>currentExtent</code> <strong class="purple">must</strong> always equal the window size.</p>
</div>
<div class="paragraph">
<p>The <code>currentExtent</code> of an Xlib surface <strong class="purple">must</strong> have both <code>width</code> and
<code>height</code> greater than 0, or both of them 0.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Due to above restrictions, it is only possible to create a new swapchain on
this platform with <code>imageExtent</code> being equal to the current size of the
window.</p>
</div>
<div class="paragraph">
<p>The window size <strong class="purple">may</strong> become <span class="eq">(0, 0)</span> on this platform (e.g. when the
window is minimized), and so a swapchain <strong class="purple">cannot</strong> be created until the size
changes.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Some Vulkan functions <strong class="purple">may</strong> send protocol over the specified Xlib
<code>Display</code> connection when using a swapchain or presentable images created
from a <a href="#VkSurfaceKHR">VkSurfaceKHR</a> referring to an Xlib window.
Applications <strong class="purple">must</strong> therefore ensure the display connection is available to
Vulkan for the duration of any functions that manipulate such swapchains or
their presentable images, and any functions that build or queue command
buffers that operate on such presentable images.
Specifically, applications using Vulkan with Xlib-based swapchains <strong class="purple">must</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Avoid holding a server grab on a display connection while waiting for
Vulkan operations to complete using a swapchain derived from a different
display connection referring to the same X server instance.
Failing to do so <strong class="purple">may</strong> result in deadlock.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some implementations may require threads to implement some presentation
modes so applications <strong class="purple">must</strong> call <code>XInitThreads</code>() before calling any
other Xlib functions.</p>
</div>
</div>
<div class="sect3">
<h4 id="platformCreateSurface_imagepipe">32.2.6. Fuchsia Platform</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create a <code>VkSurfaceKHR</code> object for a Fuchsia ImagePipe, call:</p>
</div>
<div id="vkCreateImagePipeSurfaceFUCHSIA" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateImagePipeSurfaceFUCHSIA(
    VkInstance                                  instance,
    <span class="directive">const</span> VkImagePipeSurfaceCreateInfoFUCHSIA*  pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>instance</code> is the instance to associate with the surface.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to an instance of the
<a href="#VkImagePipeSurfaceCreateInfoFUCHSIA">VkImagePipeSurfaceCreateInfoFUCHSIA</a> structure containing
parameters affecting the creation of the surface object.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
surface object when there is no more specific allocator available (see
<a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
<li>
<p><code>pSurface</code> points to a <a href="#VkSurfaceKHR">VkSurfaceKHR</a> handle in which the
created surface object is returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateImagePipeSurfaceFUCHSIA-instance-parameter"></a> <code>instance</code> <strong class="purple">must</strong> be a valid <code>VkInstance</code> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateImagePipeSurfaceFUCHSIA-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkImagePipeSurfaceCreateInfoFUCHSIA</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateImagePipeSurfaceFUCHSIA-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateImagePipeSurfaceFUCHSIA-pSurface-parameter"></a> <code>pSurface</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkSurfaceKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkImagePipeSurfaceCreateInfoFUCHSIA</code> structure is defined as:</p>
</div>
<div id="VkImagePipeSurfaceCreateInfoFUCHSIA" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkImagePipeSurfaceCreateInfoFUCHSIA {
    VkStructureType                         sType;
    <span class="directive">const</span> <span class="directive">void</span>*                             pNext;
    VkImagePipeSurfaceCreateFlagsFUCHSIA    flags;
    zx_handle_t                             imagePipeHandle;
} VkImagePipeSurfaceCreateInfoFUCHSIA;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
<li>
<p><code>imagePipeHandle</code> is a <code>zx_handle_t</code> referring to the ImagePipe
to associate with the surface.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-imagePipeHandle-00000"></a>
<code>imagePipeHandle</code> <strong class="purple">must</strong> be a valid <code>zx_handle_t</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA</code></p>
</li>
<li>
<p><a id="VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-flags-zerobitmask"></a> <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>On Fuchsia, the surface <code>currentExtent</code> is the special value
<span class="eq">(0xFFFFFFFF, 0xFFFFFFFF)</span>, indicating that the surface size will be
determined by the extent of a swapchain targeting the surface.</p>
</div>
</div>
<div class="sect3">
<h4 id="platformCreateSurface_ios">32.2.7. iOS Platform</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create a <code>VkSurfaceKHR</code> object for an iOS <code>UIView</code>, call:</p>
</div>
<div id="vkCreateIOSSurfaceMVK" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateIOSSurfaceMVK(
    VkInstance                                  instance,
    <span class="directive">const</span> VkIOSSurfaceCreateInfoMVK*            pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>instance</code> is the instance with which to associate the surface.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to an instance of the
<a href="#VkIOSSurfaceCreateInfoMVK">VkIOSSurfaceCreateInfoMVK</a> structure containing parameters
affecting the creation of the surface object.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
surface object when there is no more specific allocator available (see
<a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
<li>
<p><code>pSurface</code> points to a <a href="#VkSurfaceKHR">VkSurfaceKHR</a> handle in which the
created surface object is returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateIOSSurfaceMVK-instance-parameter"></a> <code>instance</code> <strong class="purple">must</strong> be a valid <code>VkInstance</code> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateIOSSurfaceMVK-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkIOSSurfaceCreateInfoMVK</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateIOSSurfaceMVK-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateIOSSurfaceMVK-pSurface-parameter"></a> <code>pSurface</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkSurfaceKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_NATIVE_WINDOW_IN_USE_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <a href="#VkIOSSurfaceCreateInfoMVK">VkIOSSurfaceCreateInfoMVK</a> structure is defined as:</p>
</div>
<div id="VkIOSSurfaceCreateInfoMVK" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkIOSSurfaceCreateInfoMVK {
    VkStructureType               sType;
    <span class="directive">const</span> <span class="directive">void</span>*                   pNext;
    VkIOSSurfaceCreateFlagsMVK    flags;
    <span class="directive">const</span> <span class="directive">void</span>*                   pView;
} VkIOSSurfaceCreateInfoMVK;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
<li>
<p><code>pView</code> is a reference to a <code>UIView</code> object which will display
this surface.
This <code>UIView</code> <strong class="purple">must</strong> be backed by a <code>CALayer</code> instance of type
<code>CAMetalLayer</code>.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkIOSSurfaceCreateInfoMVK-pView-01316"></a>
<code>pView</code> <strong class="purple">must</strong> be a valid <code>UIView</code> and <strong class="purple">must</strong> be backed by a
<code>CALayer</code> instance of type <code>CAMetalLayer</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkIOSSurfaceCreateInfoMVK-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK</code></p>
</li>
<li>
<p><a id="VUID-VkIOSSurfaceCreateInfoMVK-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkIOSSurfaceCreateInfoMVK-flags-zerobitmask"></a> <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="platformCreateSurface_macos">32.2.8. macOS Platform</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create a <code>VkSurfaceKHR</code> object for a macOS <code>NSView</code>, call:</p>
</div>
<div id="vkCreateMacOSSurfaceMVK" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateMacOSSurfaceMVK(
    VkInstance                                  instance,
    <span class="directive">const</span> VkMacOSSurfaceCreateInfoMVK*          pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>instance</code> is the instance with which to associate the surface.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to an instance of the
<a href="#VkMacOSSurfaceCreateInfoMVK">VkMacOSSurfaceCreateInfoMVK</a> structure containing parameters
affecting the creation of the surface object.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
surface object when there is no more specific allocator available (see
<a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
<li>
<p><code>pSurface</code> points to a <a href="#VkSurfaceKHR">VkSurfaceKHR</a> handle in which the
created surface object is returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateMacOSSurfaceMVK-instance-parameter"></a> <code>instance</code> <strong class="purple">must</strong> be a valid <code>VkInstance</code> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateMacOSSurfaceMVK-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkMacOSSurfaceCreateInfoMVK</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateMacOSSurfaceMVK-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateMacOSSurfaceMVK-pSurface-parameter"></a> <code>pSurface</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkSurfaceKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_NATIVE_WINDOW_IN_USE_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <a href="#VkMacOSSurfaceCreateInfoMVK">VkMacOSSurfaceCreateInfoMVK</a> structure is defined as:</p>
</div>
<div id="VkMacOSSurfaceCreateInfoMVK" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkMacOSSurfaceCreateInfoMVK {
    VkStructureType                 sType;
    <span class="directive">const</span> <span class="directive">void</span>*                     pNext;
    VkMacOSSurfaceCreateFlagsMVK    flags;
    <span class="directive">const</span> <span class="directive">void</span>*                     pView;
} VkMacOSSurfaceCreateInfoMVK;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
<li>
<p><code>pView</code> is a reference to a <code>NSView</code> object which will display
this surface.
This <code>NSView</code> <strong class="purple">must</strong> be backed by a <code>CALayer</code> instance of type
<code>CAMetalLayer</code>.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkMacOSSurfaceCreateInfoMVK-pView-01317"></a>
<code>pView</code> <strong class="purple">must</strong> be a valid <code>NSView</code> and <strong class="purple">must</strong> be backed by a
<code>CALayer</code> instance of type <code>CAMetalLayer</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkMacOSSurfaceCreateInfoMVK-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK</code></p>
</li>
<li>
<p><a id="VUID-VkMacOSSurfaceCreateInfoMVK-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkMacOSSurfaceCreateInfoMVK-flags-zerobitmask"></a> <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="platformCreateSurface_vi">32.2.9. VI Platform</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create a <code>VkSurfaceKHR</code> object for an <code>nn</code>::<code>vi</code>::<code>Layer</code>,
query the layer’s native handle using
<code>nn</code>::<code>vi</code>::<code>GetNativeWindow</code>, and then call:</p>
</div>
<div id="vkCreateViSurfaceNN" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateViSurfaceNN(
    VkInstance                                  instance,
    <span class="directive">const</span> VkViSurfaceCreateInfoNN*              pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>instance</code> is the instance with which to associate the surface.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to an instance of the
<code>VkViSurfaceCreateInfoNN</code> structure containing parameters affecting
the creation of the surface object.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
surface object when there is no more specific allocator available (see
<a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
<li>
<p><code>pSurface</code> points to a <a href="#VkSurfaceKHR">VkSurfaceKHR</a> handle in which the
created surface object is returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>During the lifetime of a surface created using a particular
<code>nn</code>::<code>vi</code>::<code>NativeWindowHandle</code> any attempts to create another
surface for the same <code>nn</code>::<code>vi</code>::<code>Layer</code> and any attempts to
connect to the same <code>nn</code>::<code>vi</code>::<code>Layer</code> through other platform
mechanisms will have undefined results.</p>
</div>
<div class="paragraph">
<p>If the native window is created with a specified size, <code>currentExtent</code>
will reflect that size.
In this case, applications should use the same size for the swapchain’s
<code>imageExtent</code>.
Otherwise, the <code>currentExtent</code> will have the special value
[eq]#(0xFFFFFFFF, 0xFFFFFFFF), indicating that applications are expected to
choose an appropriate size for the swapchain’s <code>imageExtent</code> (e.g., by
matching the result of a call to
<code>nn</code>::<code>vi</code>::<code>GetDisplayResolution</code>).</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateViSurfaceNN-instance-parameter"></a> <code>instance</code> <strong class="purple">must</strong> be a valid <code>VkInstance</code> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateViSurfaceNN-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkViSurfaceCreateInfoNN</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateViSurfaceNN-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateViSurfaceNN-pSurface-parameter"></a> <code>pSurface</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkSurfaceKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_NATIVE_WINDOW_IN_USE_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkViSurfaceCreateInfoNN</code> structure is defined as:</p>
</div>
<div id="VkViSurfaceCreateInfoNN" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkViSurfaceCreateInfoNN {
    VkStructureType             sType;
    <span class="directive">const</span> <span class="directive">void</span>*                 pNext;
    VkViSurfaceCreateFlagsNN    flags;
    <span class="directive">void</span>*                       window;
} VkViSurfaceCreateInfoNN;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
<li>
<p><code>window</code> is the <code>nn</code>::<code>vi</code>::<code>NativeWindowHandle</code> for the
<code>nn</code>::<code>vi</code>::<code>Layer</code> with which to associate the surface.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkViSurfaceCreateInfoNN-window-01318"></a>
<code>window</code> <strong class="purple">must</strong> be a valid <code>nn</code>::<code>vi</code>::<code>NativeWindowHandle</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkViSurfaceCreateInfoNN-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN</code></p>
</li>
<li>
<p><a id="VUID-VkViSurfaceCreateInfoNN-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkViSurfaceCreateInfoNN-flags-zerobitmask"></a> <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_platform_independent_information">32.2.10. Platform-Independent Information</h4>
<div class="paragraph">
<p>Once created, <code>VkSurfaceKHR</code> objects <strong class="purple">can</strong> be used in this and other
extensions, in particular the <code><a href="chap40.html#VK_KHR_swapchain">VK_KHR_swapchain</a></code> extension.</p>
</div>
<div class="paragraph">
<p>Several WSI functions return <code>VK_ERROR_SURFACE_LOST_KHR</code> if the surface
becomes no longer available.
After such an error, the surface (and any child swapchain, if one exists)
<strong class="purple">should</strong> be destroyed, as there is no way to restore them to a not-lost
state.
Applications <strong class="purple">may</strong> attempt to create a new <code>VkSurfaceKHR</code> using the same
native platform window object, but whether such re-creation will succeed is
platform-dependent and <strong class="purple">may</strong> depend on the reason the surface became
unavailable.
A lost surface does not otherwise cause devices to be
<a href="chap4.html#devsandqueues-lost-device">lost</a>.</p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To destroy a <code>VkSurfaceKHR</code> object, call:</p>
</div>
<div id="vkDestroySurfaceKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> vkDestroySurfaceKHR(
    VkInstance                                  instance,
    VkSurfaceKHR                                surface,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>instance</code> is the instance used to create the surface.</p>
</li>
<li>
<p><code>surface</code> is the surface to destroy.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
surface object when there is no more specific allocator available (see
<a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Destroying a <code>VkSurfaceKHR</code> merely severs the connection between Vulkan
and the native surface, and does not imply destroying the native surface,
closing a window, or similar behavior.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroySurfaceKHR-surface-01266"></a>
All <code>VkSwapchainKHR</code> objects created for <code>surface</code> <strong class="purple">must</strong> have
been destroyed prior to destroying <code>surface</code></p>
</li>
<li>
<p><a id="VUID-vkDestroySurfaceKHR-surface-01267"></a>
If <code>VkAllocationCallbacks</code> were provided when <code>surface</code> was
created, a compatible set of callbacks <strong class="purple">must</strong> be provided here</p>
</li>
<li>
<p><a id="VUID-vkDestroySurfaceKHR-surface-01268"></a>
If no <code>VkAllocationCallbacks</code> were provided when <code>surface</code> was
created, <code>pAllocator</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroySurfaceKHR-instance-parameter"></a> <code>instance</code> <strong class="purple">must</strong> be a valid <code>VkInstance</code> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroySurfaceKHR-surface-parameter"></a> If <code>surface</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>surface</code> <strong class="purple">must</strong> be a valid <code>VkSurfaceKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroySurfaceKHR-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkDestroySurfaceKHR-surface-parent"></a> If <code>surface</code> is a valid handle, it <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>instance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>surface</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="display">32.3. Presenting Directly to Display Devices</h3>
<div class="paragraph">
<p>In some environments applications <strong class="purple">can</strong> also present Vulkan rendering
directly to display devices without using an intermediate windowing system.
This <strong class="purple">can</strong> be useful for embedded applications, or implementing the
rendering/presentation backend of a windowing system using Vulkan.
The <code>VK_KHR_display</code> extension provides the functionality necessary to
enumerate display devices and create <code>VkSurfaceKHR</code> objects that target
displays.</p>
</div>
<div class="sect3">
<h4 id="_display_enumeration">32.3.1. Display Enumeration</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Displays are represented by <code>VkDisplayKHR</code> handles:</p>
</div>
<div id="VkDisplayKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayKHR)</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Various functions are provided for enumerating the available display devices
present on a Vulkan physical device.
To query information about the available displays, call:</p>
</div>
<div id="vkGetPhysicalDeviceDisplayPropertiesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPropertiesKHR*                     pProperties);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is a physical device.</p>
</li>
<li>
<p><code>pPropertyCount</code> is a pointer to an integer related to the number of
display devices available or queried, as described below.</p>
</li>
<li>
<p><code>pProperties</code> is either <code>NULL</code> or a pointer to an array of
<code>VkDisplayPropertiesKHR</code> structures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>pProperties</code> is <code>NULL</code>, then the number of display devices available
for <code>physicalDevice</code> is returned in <code>pPropertyCount</code>.
Otherwise, <code>pPropertyCount</code> <strong class="purple">must</strong> point to a variable set by the user to
the number of elements in the <code>pProperties</code> array, and on return the
variable is overwritten with the number of structures actually written to
<code>pProperties</code>.
If the value of <code>pPropertyCount</code> is less than the number of display
devices for <code>physicalDevice</code>, at most <code>pPropertyCount</code> structures
will be written.
If <code>pPropertyCount</code> is smaller than the number of display devices
available for <code>physicalDevice</code>, <code>VK_INCOMPLETE</code> will be returned
instead of <code>VK_SUCCESS</code> to indicate that not all the available values
were returned.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-pPropertyCount-parameter"></a> <code>pPropertyCount</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-pProperties-parameter"></a> If the value referenced by <code>pPropertyCount</code> is not <code>0</code>, and <code>pProperties</code> is not <code>NULL</code>, <code>pProperties</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pPropertyCount</code> <code>VkDisplayPropertiesKHR</code> structures</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_INCOMPLETE</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDisplayPropertiesKHR</code> structure is defined as:</p>
</div>
<div id="VkDisplayPropertiesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDisplayPropertiesKHR {
    VkDisplayKHR                  display;
    <span class="directive">const</span> <span class="predefined-type">char</span>*                   displayName;
    VkExtent2D                    physicalDimensions;
    VkExtent2D                    physicalResolution;
    VkSurfaceTransformFlagsKHR    supportedTransforms;
    VkBool32                      planeReorderPossible;
    VkBool32                      persistentContent;
} VkDisplayPropertiesKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>display</code> is a handle that is used to refer to the display described
here.
This handle will be valid for the lifetime of the Vulkan instance.</p>
</li>
<li>
<p><code>displayName</code> is a pointer to a NULL-terminated string containing
the name of the display.
Generally, this will be the name provided by the display’s EDID.
It <strong class="purple">can</strong> be <code>NULL</code> if no suitable name is available.
If not <code>NULL</code>, the memory it points to <strong class="purple">must</strong> remain accessible as long
as <code>display</code> is valid.</p>
</li>
<li>
<p><code>physicalDimensions</code> describes the physical width and height of the
visible portion of the display, in millimeters.</p>
</li>
<li>
<p><code>physicalResolution</code> describes the physical, native, or preferred
resolution of the display.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>For devices which have no natural value to return here, implementations
<strong class="purple">should</strong> return the maximum resolution supported.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><code>supportedTransforms</code> is a bitmask of
<a href="#VkSurfaceTransformFlagBitsKHR">VkSurfaceTransformFlagBitsKHR</a> describing which transforms are
supported by this display.</p>
</li>
<li>
<p><code>planeReorderPossible</code> tells whether the planes on this display <strong class="purple">can</strong>
have their z order changed.
If this is <code>VK_TRUE</code>, the application <strong class="purple">can</strong> re-arrange the planes on
this display in any order relative to each other.</p>
</li>
<li>
<p><code>persistentContent</code> tells whether the display supports
self-refresh/internal buffering.
If this is true, the application <strong class="purple">can</strong> submit persistent present
operations on swapchains created against this display.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Persistent presents <strong class="purple">may</strong> have higher latency, and <strong class="purple">may</strong> use less power when
the screen content is updated infrequently, or when only a portion of the
screen needs to be updated in most frames.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query information about the available displays, call:</p>
</div>
<div id="vkGetPhysicalDeviceDisplayProperties2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetPhysicalDeviceDisplayProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayProperties2KHR*                    pProperties);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is a physical device.</p>
</li>
<li>
<p><code>pPropertyCount</code> is a pointer to an integer related to the number of
display devices available or queried, as described below.</p>
</li>
<li>
<p><code>pProperties</code> is either <code>NULL</code> or a pointer to an array of
<code>VkDisplayProperties2KHR</code> structures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>vkGetPhysicalDeviceDisplayProperties2KHR</code> behaves similarly to
<a href="#vkGetPhysicalDeviceDisplayPropertiesKHR">vkGetPhysicalDeviceDisplayPropertiesKHR</a>, with the ability to return
extended information via chained output structures.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceDisplayProperties2KHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceDisplayProperties2KHR-pPropertyCount-parameter"></a> <code>pPropertyCount</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceDisplayProperties2KHR-pProperties-parameter"></a> If the value referenced by <code>pPropertyCount</code> is not <code>0</code>, and <code>pProperties</code> is not <code>NULL</code>, <code>pProperties</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pPropertyCount</code> <code>VkDisplayProperties2KHR</code> structures</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_INCOMPLETE</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDisplayProperties2KHR</code> structure is defined as:</p>
</div>
<div id="VkDisplayProperties2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDisplayProperties2KHR {
    VkStructureType           sType;
    <span class="directive">void</span>*                     pNext;
    VkDisplayPropertiesKHR    displayProperties;
} VkDisplayProperties2KHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>displayProperties</code> is an instance of the
<a href="#VkDisplayPropertiesKHR">VkDisplayPropertiesKHR</a> structure.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDisplayProperties2KHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkDisplayProperties2KHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_acquiring_and_releasing_displays">Acquiring and Releasing Displays</h5>
<div class="paragraph">
<p>On some platforms, access to displays is limited to a single process or
native driver instance.
On such platforms, some or all of the displays may not be available to
Vulkan if they are already in use by a native windowing system or other
application.</p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To acquire permission to directly access a display in Vulkan from an X11
server, call:</p>
</div>
<div id="vkAcquireXlibDisplayEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkAcquireXlibDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    Display*                                    dpy,
    VkDisplayKHR                                display);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> The physical device the display is on.</p>
</li>
<li>
<p><code>dpy</code> A connection to the X11 server that currently owns
<code>display</code>.</p>
</li>
<li>
<p><code>display</code> The display the caller wishes to control in Vulkan.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All permissions necessary to control the display are granted to the Vulkan
instance associated with <code>physicalDevice</code> until the display is released
or the X11 connection specified by <code>dpy</code> is terminated.
Permission to access the display <strong class="purple">may</strong> be temporarily revoked during periods
when the X11 server from which control was acquired itself looses access to
<code>display</code>.
During such periods, operations which require access to the display <strong class="purple">must</strong>
fail with an approriate error code.
If the X11 server associated with <code>dpy</code> does not own <code>display</code>, or
if permission to access it has already been acquired by another entity, the
call <strong class="purple">must</strong> return the error code <code>VK_ERROR_INITIALIZATION_FAILED</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>One example of when an X11 server loses access to a display is when it loses
ownership of its virtual terminal.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkAcquireXlibDisplayEXT-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkAcquireXlibDisplayEXT-dpy-parameter"></a> <code>dpy</code> <strong class="purple">must</strong> be a valid pointer to a <code>Display</code> value</p>
</li>
<li>
<p><a id="VUID-vkAcquireXlibDisplayEXT-display-parameter"></a> <code>display</code> <strong class="purple">must</strong> be a valid <code>VkDisplayKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_INITIALIZATION_FAILED</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>When acquiring displays from an X11 server, an application may also wish to
enumerate and identify them using a native handle rather than a
<code>VkDisplayKHR</code> handle.
To determine the <code>VkDisplayKHR</code> handle corresponding to an X11 RandR
Output, call:</p>
</div>
<div id="vkGetRandROutputDisplayEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetRandROutputDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    Display*                                    dpy,
    RROutput                                    rrOutput,
    VkDisplayKHR*                               pDisplay);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> The physical device to query the display handle on.</p>
</li>
<li>
<p><code>dpy</code> A connection to the X11 server from which <code>rrOutput</code> was
queried.</p>
</li>
<li>
<p><code>rrOutput</code> An X11 RandR output ID.</p>
</li>
<li>
<p><code>pDisplay</code> The corresponding <a href="#VkDisplayKHR">VkDisplayKHR</a> handle will be
returned here.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If there is no <a href="#VkDisplayKHR">VkDisplayKHR</a> corresponding to <code>rrOutput</code> on
<code>physicalDevice</code>, <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> <strong class="purple">must</strong> be returned in
<code>pDisplay</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetRandROutputDisplayEXT-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetRandROutputDisplayEXT-dpy-parameter"></a> <code>dpy</code> <strong class="purple">must</strong> be a valid pointer to a <code>Display</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetRandROutputDisplayEXT-pDisplay-parameter"></a> <code>pDisplay</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkDisplayKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To release a previously acquired display, call:</p>
</div>
<div id="vkReleaseDisplayEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkReleaseDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> The physical device the display is on.</p>
</li>
<li>
<p><code>display</code> The display to release control of.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkReleaseDisplayEXT-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkReleaseDisplayEXT-display-parameter"></a> <code>display</code> <strong class="purple">must</strong> be a valid <code>VkDisplayKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_display_planes">Display Planes</h5>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Images are presented to individual planes on a display.
Devices <strong class="purple">must</strong> support at least one plane on each display.
Planes <strong class="purple">can</strong> be stacked and blended to composite multiple images on one
display.
Devices <strong class="purple">may</strong> support only a fixed stacking order and fixed mapping between
planes and displays, or they <strong class="purple">may</strong> allow arbitrary application specified
stacking orders and mappings between planes and displays.
To query the properties of device display planes, call:</p>
</div>
<div id="vkGetPhysicalDeviceDisplayPlanePropertiesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPlanePropertiesKHR*                pProperties);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is a physical device.</p>
</li>
<li>
<p><code>pPropertyCount</code> is a pointer to an integer related to the number of
display planes available or queried, as described below.</p>
</li>
<li>
<p><code>pProperties</code> is either <code>NULL</code> or a pointer to an array of
<code>VkDisplayPlanePropertiesKHR</code> structures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>pProperties</code> is <code>NULL</code>, then the number of display planes available
for <code>physicalDevice</code> is returned in <code>pPropertyCount</code>.
Otherwise, <code>pPropertyCount</code> <strong class="purple">must</strong> point to a variable set by the user to
the number of elements in the <code>pProperties</code> array, and on return the
variable is overwritten with the number of structures actually written to
<code>pProperties</code>.
If the value of <code>pPropertyCount</code> is less than the number of display
planes for <code>physicalDevice</code>, at most <code>pPropertyCount</code> structures
will be written.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-pPropertyCount-parameter"></a> <code>pPropertyCount</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-pProperties-parameter"></a> If the value referenced by <code>pPropertyCount</code> is not <code>0</code>, and <code>pProperties</code> is not <code>NULL</code>, <code>pProperties</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pPropertyCount</code> <code>VkDisplayPlanePropertiesKHR</code> structures</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_INCOMPLETE</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDisplayPlanePropertiesKHR</code> structure is defined as:</p>
</div>
<div id="VkDisplayPlanePropertiesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDisplayPlanePropertiesKHR {
    VkDisplayKHR    currentDisplay;
    uint32_t        currentStackIndex;
} VkDisplayPlanePropertiesKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>currentDisplay</code> is the handle of the display the plane is currently
associated with.
If the plane is not currently attached to any displays, this will be
<a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>.</p>
</li>
<li>
<p><code>currentStackIndex</code> is the current z-order of the plane.
This will be between 0 and the value returned by
<code>vkGetPhysicalDeviceDisplayPlanePropertiesKHR</code> in
<code>pPropertyCount</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query the properties of a device’s display planes, call:</p>
</div>
<div id="vkGetPhysicalDeviceDisplayPlaneProperties2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPlaneProperties2KHR*               pProperties);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is a physical device.</p>
</li>
<li>
<p><code>pPropertyCount</code> is a pointer to an integer related to the number of
display planes available or queried, as described below.</p>
</li>
<li>
<p><code>pProperties</code> is either <code>NULL</code> or a pointer to an array of
<code>VkDisplayPlaneProperties2KHR</code> structures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>vkGetPhysicalDeviceDisplayPlaneProperties2KHR</code> behaves similarly to
<a href="#vkGetPhysicalDeviceDisplayPlanePropertiesKHR">vkGetPhysicalDeviceDisplayPlanePropertiesKHR</a>, with the ability to
return extended information via chained output structures.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-pPropertyCount-parameter"></a> <code>pPropertyCount</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-pProperties-parameter"></a> If the value referenced by <code>pPropertyCount</code> is not <code>0</code>, and <code>pProperties</code> is not <code>NULL</code>, <code>pProperties</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pPropertyCount</code> <code>VkDisplayPlaneProperties2KHR</code> structures</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_INCOMPLETE</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDisplayPlaneProperties2KHR</code> structure is defined as:</p>
</div>
<div id="VkDisplayPlaneProperties2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDisplayPlaneProperties2KHR {
    VkStructureType                sType;
    <span class="directive">void</span>*                          pNext;
    VkDisplayPlanePropertiesKHR    displayPlaneProperties;
} VkDisplayPlaneProperties2KHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>displayPlaneProperties</code> is an instance of the
<a href="#VkDisplayPlanePropertiesKHR">VkDisplayPlanePropertiesKHR</a> structure.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDisplayPlaneProperties2KHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkDisplayPlaneProperties2KHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To determine which displays a plane is usable with, call</p>
</div>
<div id="vkGetDisplayPlaneSupportedDisplaysKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    planeIndex,
    uint32_t*                                   pDisplayCount,
    VkDisplayKHR*                               pDisplays);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is a physical device.</p>
</li>
<li>
<p><code>planeIndex</code> is the plane which the application wishes to use, and
<strong class="purple">must</strong> be in the range <span class="eq">[0, physical device plane count - 1]</span>.</p>
</li>
<li>
<p><code>pDisplayCount</code> is a pointer to an integer related to the number of
displays available or queried, as described below.</p>
</li>
<li>
<p><code>pDisplays</code> is either <code>NULL</code> or a pointer to an array of
<code>VkDisplayKHR</code> handles.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>pDisplays</code> is <code>NULL</code>, then the number of displays usable with the
specified <code>planeIndex</code> for <code>physicalDevice</code> is returned in
<code>pDisplayCount</code>.
Otherwise, <code>pDisplayCount</code> <strong class="purple">must</strong> point to a variable set by the user to
the number of elements in the <code>pDisplays</code> array, and on return the
variable is overwritten with the number of handles actually written to
<code>pDisplays</code>.
If the value of <code>pDisplayCount</code> is less than the number of display
planes for <code>physicalDevice</code>, at most <code>pDisplayCount</code> handles will be
written.
If <code>pDisplayCount</code> is smaller than the number of displays usable with
the specified <code>planeIndex</code> for <code>physicalDevice</code>, <code>VK_INCOMPLETE</code>
will be returned instead of <code>VK_SUCCESS</code> to indicate that not all the
available values were returned.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetDisplayPlaneSupportedDisplaysKHR-planeIndex-01249"></a>
<code>planeIndex</code> <strong class="purple">must</strong> be less than the number of display planes
supported by the device as determined by calling
<code>vkGetPhysicalDeviceDisplayPlanePropertiesKHR</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetDisplayPlaneSupportedDisplaysKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetDisplayPlaneSupportedDisplaysKHR-pDisplayCount-parameter"></a> <code>pDisplayCount</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetDisplayPlaneSupportedDisplaysKHR-pDisplays-parameter"></a> If the value referenced by <code>pDisplayCount</code> is not <code>0</code>, and <code>pDisplays</code> is not <code>NULL</code>, <code>pDisplays</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pDisplayCount</code> <code>VkDisplayKHR</code> handles</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_INCOMPLETE</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Additional properties of displays are queried using specialized query
functions.</p>
</div>
</div>
<div class="sect4">
<h5 id="_display_modes">Display Modes</h5>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Display modes are represented by <code>VkDisplayModeKHR</code> handles:</p>
</div>
<div id="VkDisplayModeKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayModeKHR)</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Each display has one or more supported modes associated with it by default.
These built-in modes are queried by calling:</p>
</div>
<div id="vkGetDisplayModePropertiesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    uint32_t*                                   pPropertyCount,
    VkDisplayModePropertiesKHR*                 pProperties);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device associated with
<code>display</code>.</p>
</li>
<li>
<p><code>display</code> is the display to query.</p>
</li>
<li>
<p><code>pPropertyCount</code> is a pointer to an integer related to the number of
display modes available or queried, as described below.</p>
</li>
<li>
<p><code>pProperties</code> is either <code>NULL</code> or a pointer to an array of
<code>VkDisplayModePropertiesKHR</code> structures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>pProperties</code> is <code>NULL</code>, then the number of display modes available
on the specified <code>display</code> for <code>physicalDevice</code> is returned in
<code>pPropertyCount</code>.
Otherwise, <code>pPropertyCount</code> <strong class="purple">must</strong> point to a variable set by the user to
the number of elements in the <code>pProperties</code> array, and on return the
variable is overwritten with the number of structures actually written to
<code>pProperties</code>.
If the value of <code>pPropertyCount</code> is less than the number of display
modes for <code>physicalDevice</code>, at most <code>pPropertyCount</code> structures will
be written.
If <code>pPropertyCount</code> is smaller than the number of display modes
available on the specified <code>display</code> for <code>physicalDevice</code>,
<code>VK_INCOMPLETE</code> will be returned instead of <code>VK_SUCCESS</code> to indicate
that not all the available values were returned.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetDisplayModePropertiesKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetDisplayModePropertiesKHR-display-parameter"></a> <code>display</code> <strong class="purple">must</strong> be a valid <code>VkDisplayKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetDisplayModePropertiesKHR-pPropertyCount-parameter"></a> <code>pPropertyCount</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetDisplayModePropertiesKHR-pProperties-parameter"></a> If the value referenced by <code>pPropertyCount</code> is not <code>0</code>, and <code>pProperties</code> is not <code>NULL</code>, <code>pProperties</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pPropertyCount</code> <code>VkDisplayModePropertiesKHR</code> structures</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_INCOMPLETE</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDisplayModePropertiesKHR</code> structure is defined as:</p>
</div>
<div id="VkDisplayModePropertiesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDisplayModePropertiesKHR {
    VkDisplayModeKHR              displayMode;
    VkDisplayModeParametersKHR    parameters;
} VkDisplayModePropertiesKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>displayMode</code> is a handle to the display mode described in this
structure.
This handle will be valid for the lifetime of the Vulkan instance.</p>
</li>
<li>
<p><code>parameters</code> is a <a href="#VkDisplayModeParametersKHR">VkDisplayModeParametersKHR</a> structure
describing the display parameters associated with <code>displayMode</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query the properties of a device’s built-in display modes, call:</p>
</div>
<div id="vkGetDisplayModeProperties2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetDisplayModeProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    uint32_t*                                   pPropertyCount,
    VkDisplayModeProperties2KHR*                pProperties);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device associated with
<code>display</code>.</p>
</li>
<li>
<p><code>display</code> is the display to query.</p>
</li>
<li>
<p><code>pPropertyCount</code> is a pointer to an integer related to the number of
display modes available or queried, as described below.</p>
</li>
<li>
<p><code>pProperties</code> is either <code>NULL</code> or a pointer to an array of
<code>VkDisplayModeProperties2KHR</code> structures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>vkGetDisplayModeProperties2KHR</code> behaves similarly to
<a href="#vkGetDisplayModePropertiesKHR">vkGetDisplayModePropertiesKHR</a>, with the ability to return extended
information via chained output structures.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetDisplayModeProperties2KHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetDisplayModeProperties2KHR-display-parameter"></a> <code>display</code> <strong class="purple">must</strong> be a valid <code>VkDisplayKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetDisplayModeProperties2KHR-pPropertyCount-parameter"></a> <code>pPropertyCount</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetDisplayModeProperties2KHR-pProperties-parameter"></a> If the value referenced by <code>pPropertyCount</code> is not <code>0</code>, and <code>pProperties</code> is not <code>NULL</code>, <code>pProperties</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pPropertyCount</code> <code>VkDisplayModeProperties2KHR</code> structures</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_INCOMPLETE</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDisplayModeProperties2KHR</code> structure is defined as:</p>
</div>
<div id="VkDisplayModeProperties2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDisplayModeProperties2KHR {
    VkStructureType               sType;
    <span class="directive">void</span>*                         pNext;
    VkDisplayModePropertiesKHR    displayModeProperties;
} VkDisplayModeProperties2KHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>displayModeProperties</code> is an instance of the
<a href="#VkDisplayModePropertiesKHR">VkDisplayModePropertiesKHR</a> structure.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDisplayModeProperties2KHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkDisplayModeProperties2KHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDisplayModeParametersKHR</code> structure is defined as:</p>
</div>
<div id="VkDisplayModeParametersKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDisplayModeParametersKHR {
    VkExtent2D    visibleRegion;
    uint32_t      refreshRate;
} VkDisplayModeParametersKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>visibleRegion</code> is the 2D extents of the visible region.</p>
</li>
<li>
<p><code>refreshRate</code> is a <code>uint32_t</code> that is the number of times the
display is refreshed each second multiplied by 1000.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>For example, a 60Hz display mode would report a <code>refreshRate</code> of 60,000.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDisplayModeParametersKHR-width-01990"></a>
The <code>width</code> member of <code>visibleRegion</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkDisplayModeParametersKHR-height-01991"></a>
The <code>height</code> member of <code>visibleRegion</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkDisplayModeParametersKHR-refreshRate-01992"></a>
<code>refreshRate</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Additional modes <strong class="purple">may</strong> also be created by calling:</p>
</div>
<div id="vkCreateDisplayModeKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateDisplayModeKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    <span class="directive">const</span> VkDisplayModeCreateInfoKHR*           pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkDisplayModeKHR*                           pMode);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device associated with
<code>display</code>.</p>
</li>
<li>
<p><code>display</code> is the display to create an additional mode for.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a <a href="#VkDisplayModeCreateInfoKHR">VkDisplayModeCreateInfoKHR</a> structure
describing the new mode to create.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
display mode object when there is no more specific allocator available
(see <a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
<li>
<p><code>pMode</code> returns the handle of the mode created.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateDisplayModeKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateDisplayModeKHR-display-parameter"></a> <code>display</code> <strong class="purple">must</strong> be a valid <code>VkDisplayKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateDisplayModeKHR-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkDisplayModeCreateInfoKHR</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDisplayModeKHR-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDisplayModeKHR-pMode-parameter"></a> <code>pMode</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkDisplayModeKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>display</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_INITIALIZATION_FAILED</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDisplayModeCreateInfoKHR</code> structure is defined as:</p>
</div>
<div id="VkDisplayModeCreateInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDisplayModeCreateInfoKHR {
    VkStructureType                sType;
    <span class="directive">const</span> <span class="directive">void</span>*                    pNext;
    VkDisplayModeCreateFlagsKHR    flags;
    VkDisplayModeParametersKHR     parameters;
} VkDisplayModeCreateInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use, and <strong class="purple">must</strong> be zero.</p>
</li>
<li>
<p><code>parameters</code> is a <a href="#VkDisplayModeParametersKHR">VkDisplayModeParametersKHR</a> structure
describing the display parameters to use in creating the new mode.
If the parameters are not compatible with the specified display, the
implementation <strong class="purple">must</strong> return <code>VK_ERROR_INITIALIZATION_FAILED</code>.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDisplayModeCreateInfoKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkDisplayModeCreateInfoKHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkDisplayModeCreateInfoKHR-flags-zerobitmask"></a> <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkDisplayModeCreateInfoKHR-parameters-parameter"></a> <code>parameters</code> <strong class="purple">must</strong> be a valid <code>VkDisplayModeParametersKHR</code> structure</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Applications that wish to present directly to a display <strong class="purple">must</strong> select which
layer, or “plane” of the display they wish to target, and a mode to use
with the display.
Each display supports at least one plane.
The capabilities of a given mode and plane combination are determined by
calling:</p>
</div>
<div id="vkGetDisplayPlaneCapabilitiesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayModeKHR                            mode,
    uint32_t                                    planeIndex,
    VkDisplayPlaneCapabilitiesKHR*              pCapabilities);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device associated with
<code>display</code></p>
</li>
<li>
<p><code>mode</code> is the display mode the application intends to program when
using the specified plane.
Note this parameter also implicitly specifies a display.</p>
</li>
<li>
<p><code>planeIndex</code> is the plane which the application intends to use with
the display, and is less than the number of display planes supported by
the device.</p>
</li>
<li>
<p><code>pCapabilities</code> is a pointer to a
<a href="#VkDisplayPlaneCapabilitiesKHR">VkDisplayPlaneCapabilitiesKHR</a> structure in which the capabilities
are returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetDisplayPlaneCapabilitiesKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetDisplayPlaneCapabilitiesKHR-mode-parameter"></a> <code>mode</code> <strong class="purple">must</strong> be a valid <code>VkDisplayModeKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetDisplayPlaneCapabilitiesKHR-pCapabilities-parameter"></a> <code>pCapabilities</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkDisplayPlaneCapabilitiesKHR</code> structure</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>mode</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDisplayPlaneCapabilitiesKHR</code> structure is defined as:</p>
</div>
<div id="VkDisplayPlaneCapabilitiesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDisplayPlaneCapabilitiesKHR {
    VkDisplayPlaneAlphaFlagsKHR    supportedAlpha;
    VkOffset2D                     minSrcPosition;
    VkOffset2D                     maxSrcPosition;
    VkExtent2D                     minSrcExtent;
    VkExtent2D                     maxSrcExtent;
    VkOffset2D                     minDstPosition;
    VkOffset2D                     maxDstPosition;
    VkExtent2D                     minDstExtent;
    VkExtent2D                     maxDstExtent;
} VkDisplayPlaneCapabilitiesKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>supportedAlpha</code> is a bitmask of
<a href="#VkDisplayPlaneAlphaFlagBitsKHR">VkDisplayPlaneAlphaFlagBitsKHR</a> describing the supported alpha
blending modes.</p>
</li>
<li>
<p><code>minSrcPosition</code> is the minimum source rectangle offset supported by
this plane using the specified mode.</p>
</li>
<li>
<p><code>maxSrcPosition</code> is the maximum source rectangle offset supported by
this plane using the specified mode.
The <code>x</code> and <code>y</code> components of <code>maxSrcPosition</code> <strong class="purple">must</strong> each be
greater than or equal to the <code>x</code> and <code>y</code> components of
<code>minSrcPosition</code>, respectively.</p>
</li>
<li>
<p><code>minSrcExtent</code> is the minimum source rectangle size supported by
this plane using the specified mode.</p>
</li>
<li>
<p><code>maxSrcExtent</code> is the maximum source rectangle size supported by
this plane using the specified mode.</p>
</li>
<li>
<p><code>minDstPosition</code>, <code>maxDstPosition</code>, <code>minDstExtent</code>,
<code>maxDstExtent</code> all have similar semantics to their corresponding
<code>*Src*</code> equivalents, but apply to the output region within the mode
rather than the input region within the source image.
Unlike the <code>*Src*</code> offsets, <code>minDstPosition</code> and
<code>maxDstPosition</code> <strong class="purple">may</strong> contain negative values.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The minimum and maximum position and extent fields describe the
implementation limits, if any, as they apply to the specified display mode
and plane.
Vendors <strong class="purple">may</strong> support displaying a subset of a swapchain’s presentable images
on the specified display plane.
This is expressed by returning <code>minSrcPosition</code>, <code>maxSrcPosition</code>,
<code>minSrcExtent</code>, and <code>maxSrcExtent</code> values that indicate a range of
possible positions and sizes <strong class="purple">may</strong> be used to specify the region within the
presentable images that source pixels will be read from when creating a
swapchain on the specified display mode and plane.</p>
</div>
<div class="paragraph">
<p>Vendors <strong class="purple">may</strong> also support mapping the presentable images’ content to a
subset or superset of the visible region in the specified display mode.
This is expressed by returning <code>minDstPosition</code>, <code>maxDstPosition</code>,
<code>minDstExtent</code> and <code>maxDstExtent</code> values that indicate a range of
possible positions and sizes <strong class="purple">may</strong> be used to describe the region within the
display mode that the source pixels will be mapped to.</p>
</div>
<div class="paragraph">
<p>Other vendors <strong class="purple">may</strong> support only a 1-1 mapping between pixels in the
presentable images and the display mode.
This <strong class="purple">may</strong> be indicated by returning <span class="eq">(0,0)</span> for <code>minSrcPosition</code>,
<code>maxSrcPosition</code>, <code>minDstPosition</code>, and <code>maxDstPosition</code>, and
(display mode width, display mode height) for <code>minSrcExtent</code>,
<code>maxSrcExtent</code>, <code>minDstExtent</code>, and <code>maxDstExtent</code>.</p>
</div>
<div class="paragraph">
<p>These values indicate the limits of the implementation’s individual fields.
Not all combinations of values within the offset and extent ranges returned
in <code>VkDisplayPlaneCapabilitiesKHR</code> are guaranteed to be supported.
Vendors <strong class="purple">may</strong> still fail presentation requests that specify unsupported
combinations.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query the capabilities of a given mode and plane combination, call:</p>
</div>
<div id="vkGetDisplayPlaneCapabilities2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetDisplayPlaneCapabilities2KHR(
    VkPhysicalDevice                            physicalDevice,
    <span class="directive">const</span> VkDisplayPlaneInfo2KHR*               pDisplayPlaneInfo,
    VkDisplayPlaneCapabilities2KHR*             pCapabilities);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device associated with
<code>pDisplayPlaneInfo</code>.</p>
</li>
<li>
<p><code>pDisplayPlaneInfo</code> is a pointer to an instance of the
<a href="#VkDisplayPlaneInfo2KHR">VkDisplayPlaneInfo2KHR</a> structure describing the plane and mode.</p>
</li>
<li>
<p><code>pCapabilities</code> is a pointer to a
<a href="#VkDisplayPlaneCapabilities2KHR">VkDisplayPlaneCapabilities2KHR</a> structure in which the capabilities
are returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>vkGetDisplayPlaneCapabilities2KHR</code> behaves similarly to
<a href="#vkGetDisplayPlaneCapabilitiesKHR">vkGetDisplayPlaneCapabilitiesKHR</a>, with the ability to specify extended
inputs via chained input structures, and to return extended information via
chained output structures.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetDisplayPlaneCapabilities2KHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetDisplayPlaneCapabilities2KHR-pDisplayPlaneInfo-parameter"></a> <code>pDisplayPlaneInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkDisplayPlaneInfo2KHR</code> structure</p>
</li>
<li>
<p><a id="VUID-vkGetDisplayPlaneCapabilities2KHR-pCapabilities-parameter"></a> <code>pCapabilities</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkDisplayPlaneCapabilities2KHR</code> structure</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDisplayPlaneInfo2KHR</code> structure is defined as:</p>
</div>
<div id="VkDisplayPlaneInfo2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDisplayPlaneInfo2KHR {
    VkStructureType     sType;
    <span class="directive">const</span> <span class="directive">void</span>*         pNext;
    VkDisplayModeKHR    mode;
    uint32_t            planeIndex;
} VkDisplayPlaneInfo2KHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>mode</code> is the display mode the application intends to program when
using the specified plane.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>This parameter also implicitly specifies a display.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><code>planeIndex</code> is the plane which the application intends to use with
the display.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The members of <code>VkDisplayPlaneInfo2KHR</code> correspond to the arguments to
<a href="#vkGetDisplayPlaneCapabilitiesKHR">vkGetDisplayPlaneCapabilitiesKHR</a>, with <code>sType</code> and <code>pNext</code>
added for extensibility.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDisplayPlaneInfo2KHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkDisplayPlaneInfo2KHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkDisplayPlaneInfo2KHR-mode-parameter"></a> <code>mode</code> <strong class="purple">must</strong> be a valid <code>VkDisplayModeKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>mode</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDisplayPlaneCapabilities2KHR</code> structure is defined as:</p>
</div>
<div id="VkDisplayPlaneCapabilities2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDisplayPlaneCapabilities2KHR {
    VkStructureType                  sType;
    <span class="directive">void</span>*                            pNext;
    VkDisplayPlaneCapabilitiesKHR    capabilities;
} VkDisplayPlaneCapabilities2KHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>capabilities</code> is an instance of the
<a href="#VkDisplayPlaneCapabilitiesKHR">VkDisplayPlaneCapabilitiesKHR</a> structure.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDisplayPlaneCapabilities2KHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkDisplayPlaneCapabilities2KHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_display_control">32.3.2. Display Control</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To set the power state of a display, call:</p>
</div>
<div id="vkDisplayPowerControlEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkDisplayPowerControlEXT(
    VkDevice                                    device,
    VkDisplayKHR                                display,
    <span class="directive">const</span> VkDisplayPowerInfoEXT*                pDisplayPowerInfo);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is a logical device associated with <code>display</code>.</p>
</li>
<li>
<p><code>display</code> is the display whose power state is modified.</p>
</li>
<li>
<p><code>pDisplayPowerInfo</code> is an instance of <a href="#VkDisplayPowerInfoEXT">VkDisplayPowerInfoEXT</a>
specifying the new power state of <code>display</code>.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDisplayPowerControlEXT-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <code>VkDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkDisplayPowerControlEXT-display-parameter"></a> <code>display</code> <strong class="purple">must</strong> be a valid <code>VkDisplayKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkDisplayPowerControlEXT-pDisplayPowerInfo-parameter"></a> <code>pDisplayPowerInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkDisplayPowerInfoEXT</code> structure</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDisplayPowerInfoEXT</code> structure is defined as:</p>
</div>
<div id="VkDisplayPowerInfoEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDisplayPowerInfoEXT {
    VkStructureType           sType;
    <span class="directive">const</span> <span class="directive">void</span>*               pNext;
    VkDisplayPowerStateEXT    powerState;
} VkDisplayPowerInfoEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>powerState</code> is a <a href="#VkDisplayPowerStateEXT">VkDisplayPowerStateEXT</a> value specifying the
new power state of the display.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDisplayPowerInfoEXT-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT</code></p>
</li>
<li>
<p><a id="VUID-VkDisplayPowerInfoEXT-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkDisplayPowerInfoEXT-powerState-parameter"></a> <code>powerState</code> <strong class="purple">must</strong> be a valid <a href="#VkDisplayPowerStateEXT">VkDisplayPowerStateEXT</a> value</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Possible values of <a href="#VkDisplayPowerInfoEXT">VkDisplayPowerInfoEXT</a>::<code>powerState</code>, specifying
the new power state of a display, are:</p>
</div>
<div id="VkDisplayPowerStateEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">enum</span> VkDisplayPowerStateEXT {
    VK_DISPLAY_POWER_STATE_OFF_EXT = <span class="integer">0</span>,
    VK_DISPLAY_POWER_STATE_SUSPEND_EXT = <span class="integer">1</span>,
    VK_DISPLAY_POWER_STATE_ON_EXT = <span class="integer">2</span>,
} VkDisplayPowerStateEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_DISPLAY_POWER_STATE_OFF_EXT</code> specifies that the display is
powered down.</p>
</li>
<li>
<p><code>VK_DISPLAY_POWER_STATE_SUSPEND_EXT</code> specifies that the display is
put into a low power mode, from which it <strong class="purple">may</strong> be able to transition back
to <code>VK_DISPLAY_POWER_STATE_ON_EXT</code> more quickly than if it were in
<code>VK_DISPLAY_POWER_STATE_OFF_EXT</code>.
This state <strong class="purple">may</strong> be the same as <code>VK_DISPLAY_POWER_STATE_OFF_EXT</code>.</p>
</li>
<li>
<p><code>VK_DISPLAY_POWER_STATE_ON_EXT</code> specifies that the display is
powered on.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="wsi-display-surfaces">32.3.3. Display Surfaces</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>A complete display configuration includes a mode, one or more display planes
and any parameters describing their behavior, and parameters describing some
aspects of the images associated with those planes.
Display surfaces describe the configuration of a single plane within a
complete display configuration.
To create a <code>VkSurfaceKHR</code> structure for a display surface, call:</p>
</div>
<div id="vkCreateDisplayPlaneSurfaceKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateDisplayPlaneSurfaceKHR(
    VkInstance                                  instance,
    <span class="directive">const</span> VkDisplaySurfaceCreateInfoKHR*        pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>instance</code> is the instance corresponding to the physical device the
targeted display is on.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to an instance of the
<a href="#VkDisplaySurfaceCreateInfoKHR">VkDisplaySurfaceCreateInfoKHR</a> structure specifying which mode,
plane, and other parameters to use, as described below.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
surface object when there is no more specific allocator available (see
<a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
<li>
<p><code>pSurface</code> points to a <a href="#VkSurfaceKHR">VkSurfaceKHR</a> handle in which the
created surface is returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateDisplayPlaneSurfaceKHR-instance-parameter"></a> <code>instance</code> <strong class="purple">must</strong> be a valid <code>VkInstance</code> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateDisplayPlaneSurfaceKHR-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkDisplaySurfaceCreateInfoKHR</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDisplayPlaneSurfaceKHR-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDisplayPlaneSurfaceKHR-pSurface-parameter"></a> <code>pSurface</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkSurfaceKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDisplaySurfaceCreateInfoKHR</code> structure is defined as:</p>
</div>
<div id="VkDisplaySurfaceCreateInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDisplaySurfaceCreateInfoKHR {
    VkStructureType                   sType;
    <span class="directive">const</span> <span class="directive">void</span>*                       pNext;
    VkDisplaySurfaceCreateFlagsKHR    flags;
    VkDisplayModeKHR                  displayMode;
    uint32_t                          planeIndex;
    uint32_t                          planeStackIndex;
    VkSurfaceTransformFlagBitsKHR     transform;
    <span class="predefined-type">float</span>                             globalAlpha;
    VkDisplayPlaneAlphaFlagBitsKHR    alphaMode;
    VkExtent2D                        imageExtent;
} VkDisplaySurfaceCreateInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use, and <strong class="purple">must</strong> be zero.</p>
</li>
<li>
<p><code>displayMode</code> is a <a href="#VkDisplayModeKHR">VkDisplayModeKHR</a> handle specifying the mode
to use when displaying this surface.</p>
</li>
<li>
<p><code>planeIndex</code> is the plane on which this surface appears.</p>
</li>
<li>
<p><code>planeStackIndex</code> is the z-order of the plane.</p>
</li>
<li>
<p><code>transform</code> is a <a href="#VkSurfaceTransformFlagBitsKHR">VkSurfaceTransformFlagBitsKHR</a> value
specifying the transformation to apply to images as part of the scanout
operation.</p>
</li>
<li>
<p><code>globalAlpha</code> is the global alpha value.
This value is ignored if <code>alphaMode</code> is not
<code>VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR</code>.</p>
</li>
<li>
<p><code>alphaMode</code> is a <a href="#VkDisplayPlaneAlphaFlagBitsKHR">VkDisplayPlaneAlphaFlagBitsKHR</a> value
specifying the type of alpha blending to use.</p>
</li>
<li>
<p><code>imageExtent</code> The size of the presentable images to use with the
surface.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Creating a display surface <strong class="purple">must</strong> not modify the state of the displays,
planes, or other resources it names.
For example, it <strong class="purple">must</strong> not apply the specified mode to be set on the
associated display.
Application of display configuration occurs as a side effect of presenting
to a display surface.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDisplaySurfaceCreateInfoKHR-planeIndex-01252"></a>
<code>planeIndex</code> <strong class="purple">must</strong> be less than the number of display planes
supported by the device as determined by calling
<code>vkGetPhysicalDeviceDisplayPlanePropertiesKHR</code></p>
</li>
<li>
<p><a id="VUID-VkDisplaySurfaceCreateInfoKHR-planeReorderPossible-01253"></a>
If the <code>planeReorderPossible</code> member of the
<code>VkDisplayPropertiesKHR</code> structure returned by
<code>vkGetPhysicalDeviceDisplayPropertiesKHR</code> for the display
corresponding to <code>displayMode</code> is <code>VK_TRUE</code> then
<code>planeStackIndex</code> <strong class="purple">must</strong> be less than the number of display planes
supported by the device as determined by calling
<code>vkGetPhysicalDeviceDisplayPlanePropertiesKHR</code>; otherwise
<code>planeStackIndex</code> <strong class="purple">must</strong> equal the <code>currentStackIndex</code> member of
<code>VkDisplayPlanePropertiesKHR</code> returned by
<code>vkGetPhysicalDeviceDisplayPlanePropertiesKHR</code> for the display plane
corresponding to <code>displayMode</code></p>
</li>
<li>
<p><a id="VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-01254"></a>
If <code>alphaMode</code> is <code>VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR</code> then
<code>globalAlpha</code> <strong class="purple">must</strong> be between <code>0</code> and <code>1</code>, inclusive</p>
</li>
<li>
<p><a id="VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-01255"></a>
<code>alphaMode</code> <strong class="purple">must</strong> be <code>0</code> or one of the bits present in the
<code>supportedAlpha</code> member of <code>VkDisplayPlaneCapabilitiesKHR</code>
returned by <code>vkGetDisplayPlaneCapabilitiesKHR</code> for the display plane
corresponding to <code>displayMode</code></p>
</li>
<li>
<p><a id="VUID-VkDisplaySurfaceCreateInfoKHR-width-01256"></a>
The <code>width</code> and <code>height</code> members of <code>imageExtent</code> <strong class="purple">must</strong> be
less than the <code>maxImageDimensions2D</code> member of
<code>VkPhysicalDeviceLimits</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDisplaySurfaceCreateInfoKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkDisplaySurfaceCreateInfoKHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkDisplaySurfaceCreateInfoKHR-flags-zerobitmask"></a> <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkDisplaySurfaceCreateInfoKHR-displayMode-parameter"></a> <code>displayMode</code> <strong class="purple">must</strong> be a valid <code>VkDisplayModeKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-VkDisplaySurfaceCreateInfoKHR-transform-parameter"></a> <code>transform</code> <strong class="purple">must</strong> be a valid <a href="#VkSurfaceTransformFlagBitsKHR">VkSurfaceTransformFlagBitsKHR</a> value</p>
</li>
<li>
<p><a id="VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-parameter"></a> <code>alphaMode</code> <strong class="purple">must</strong> be a valid <a href="#VkDisplayPlaneAlphaFlagBitsKHR">VkDisplayPlaneAlphaFlagBitsKHR</a> value</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Possible values of <a href="#VkDisplaySurfaceCreateInfoKHR">VkDisplaySurfaceCreateInfoKHR</a>::<code>alphaMode</code>,
specifying the type of alpha blending to use on a display, are:</p>
</div>
<div id="VkDisplayPlaneAlphaFlagBitsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">enum</span> VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = <span class="hex">0x00000001</span>,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = <span class="hex">0x00000002</span>,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = <span class="hex">0x00000004</span>,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = <span class="hex">0x00000008</span>,
} VkDisplayPlaneAlphaFlagBitsKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR</code> specifies that the source
image will be treated as opaque.</p>
</li>
<li>
<p><code>VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR</code> specifies that a global
alpha value <strong class="purple">must</strong> be specified that will be applied to all pixels in the
source image.</p>
</li>
<li>
<p><code>VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR</code> specifies that the alpha
value will be determined by the alpha channel of the source image’s
pixels.
If the source format contains no alpha values, no blending will be
applied.
The source alpha values are not premultiplied into the source image’s
other color channels.</p>
</li>
<li>
<p><code>VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR</code> is
equivalent to <code>VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR</code>, except the
source alpha values are assumed to be premultiplied into the source
image’s other color channels.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkDisplayPlaneAlphaFlagsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkFlags VkDisplayPlaneAlphaFlagsKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkDisplayPlaneAlphaFlagsKHR</code> is a bitmask type for setting a mask of
zero or more <a href="#VkDisplayPlaneAlphaFlagBitsKHR">VkDisplayPlaneAlphaFlagBitsKHR</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_querying_for_wsi_support">32.4. Querying for WSI Support</h3>
<div class="paragraph">
<p>Not all physical devices will include WSI support.
Within a physical device, not all queue families will support presentation.
WSI support and compatibility <strong class="purple">can</strong> be determined in a platform-neutral
manner (which determines support for presentation to a particular surface
object) and additionally <strong class="purple">may</strong> be determined in platform-specific manners
(which determine support for presentation on the specified physical device
but do not guarantee support for presentation to a particular surface
object).</p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To determine whether a queue family of a physical device supports
presentation to a given surface, call:</p>
</div>
<div id="vkGetPhysicalDeviceSurfaceSupportKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    VkSurfaceKHR                                surface,
    VkBool32*                                   pSupported);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device.</p>
</li>
<li>
<p><code>queueFamilyIndex</code> is the queue family.</p>
</li>
<li>
<p><code>surface</code> is the surface.</p>
</li>
<li>
<p><code>pSupported</code> is a pointer to a <code>VkBool32</code>, which is set to
<code>VK_TRUE</code> to indicate support, and <code>VK_FALSE</code> otherwise.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceSupportKHR-queueFamilyIndex-01269"></a>
<code>queueFamilyIndex</code> <strong class="purple">must</strong> be less than
<code>pQueueFamilyPropertyCount</code> returned by
<code>vkGetPhysicalDeviceQueueFamilyProperties</code> for the given
<code>physicalDevice</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceSupportKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceSupportKHR-surface-parameter"></a> <code>surface</code> <strong class="purple">must</strong> be a valid <code>VkSurfaceKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceSupportKHR-pSupported-parameter"></a> <code>pSupported</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkBool32</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceSupportKHR-commonparent"></a> Both of <code>physicalDevice</code>, and <code>surface</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="platformQuerySupport_android">32.4.1. Android Platform</h4>
<div class="paragraph">
<p>On Android, all physical devices and queue families <strong class="purple">must</strong> be capable of
presentation with any native window.
As a result there is no Android-specific query for these capabilities.</p>
</div>
</div>
<div class="sect3">
<h4 id="platformQuerySupport_walyand">32.4.2. Wayland Platform</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To determine whether a queue family of a physical device supports
presentation to a Wayland compositor, call:</p>
</div>
<div id="vkGetPhysicalDeviceWaylandPresentationSupportKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    <span class="keyword">struct</span> wl_display*                          display);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device.</p>
</li>
<li>
<p><code>queueFamilyIndex</code> is the queue family index.</p>
</li>
<li>
<p><code>display</code> is a pointer to the <code>wl_display</code> associated with a
Wayland compositor.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This platform-specific function <strong class="purple">can</strong> be called prior to creating a surface.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-queueFamilyIndex-01306"></a>
<code>queueFamilyIndex</code> <strong class="purple">must</strong> be less than
<code>pQueueFamilyPropertyCount</code> returned by
<code>vkGetPhysicalDeviceQueueFamilyProperties</code> for the given
<code>physicalDevice</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-display-parameter"></a> <code>display</code> <strong class="purple">must</strong> be a valid pointer to a <code>wl_display</code> value</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="platformQuerySupport_win32">32.4.3. Win32 Platform</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To determine whether a queue family of a physical device supports
presentation to the Microsoft Windows desktop, call:</p>
</div>
<div id="vkGetPhysicalDeviceWin32PresentationSupportKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device.</p>
</li>
<li>
<p><code>queueFamilyIndex</code> is the queue family index.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This platform-specific function <strong class="purple">can</strong> be called prior to creating a surface.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceWin32PresentationSupportKHR-queueFamilyIndex-01309"></a>
<code>queueFamilyIndex</code> <strong class="purple">must</strong> be less than
<code>pQueueFamilyPropertyCount</code> returned by
<code>vkGetPhysicalDeviceQueueFamilyProperties</code> for the given
<code>physicalDevice</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceWin32PresentationSupportKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="platformQuerySupport_xcb">32.4.4. XCB Platform</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To determine whether a queue family of a physical device supports
presentation to an X11 server, using the XCB client-side library, call:</p>
</div>
<div id="vkGetPhysicalDeviceXcbPresentationSupportKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    xcb_connection_t*                           connection,
    xcb_visualid_t                              visual_id);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device.</p>
</li>
<li>
<p><code>queueFamilyIndex</code> is the queue family index.</p>
</li>
<li>
<p><code>connection</code> is a pointer to an <code>xcb_connection_t</code> to the X
server.
<code>visual_id</code> is an X11 visual (<code>xcb_visualid_t</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This platform-specific function <strong class="purple">can</strong> be called prior to creating a surface.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-queueFamilyIndex-01312"></a>
<code>queueFamilyIndex</code> <strong class="purple">must</strong> be less than
<code>pQueueFamilyPropertyCount</code> returned by
<code>vkGetPhysicalDeviceQueueFamilyProperties</code> for the given
<code>physicalDevice</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-connection-parameter"></a> <code>connection</code> <strong class="purple">must</strong> be a valid pointer to a <code>xcb_connection_t</code> value</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="platformQuerySupport_xlib">32.4.5. Xlib Platform</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To determine whether a queue family of a physical device supports
presentation to an X11 server, using the Xlib client-side library, call:</p>
</div>
<div id="vkGetPhysicalDeviceXlibPresentationSupportKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    Display*                                    dpy,
    VisualID                                    visualID);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device.</p>
</li>
<li>
<p><code>queueFamilyIndex</code> is the queue family index.</p>
</li>
<li>
<p><code>dpy</code> is a pointer to an Xlib <code>Display</code> connection to the server.</p>
</li>
<li>
<p><code>visualId</code> is an X11 visual (<code>VisualID</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This platform-specific function <strong class="purple">can</strong> be called prior to creating a surface.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-queueFamilyIndex-01315"></a>
<code>queueFamilyIndex</code> <strong class="purple">must</strong> be less than
<code>pQueueFamilyPropertyCount</code> returned by
<code>vkGetPhysicalDeviceQueueFamilyProperties</code> for the given
<code>physicalDevice</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-dpy-parameter"></a> <code>dpy</code> <strong class="purple">must</strong> be a valid pointer to a <code>Display</code> value</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="platformQuerySupport_fuchsia">32.4.6. Fuchsia Platform</h4>
<div class="paragraph">
<p>On Fuchsia, all physical devices and queue families <strong class="purple">must</strong> be capable of
presentation with any ImagePipe.
As a result there is no Fuchsia-specific query for these capabilities.</p>
</div>
</div>
<div class="sect3">
<h4 id="platformQuerySupport_ios">32.4.7. iOS Platform</h4>
<div class="paragraph">
<p>On iOS, all physical devices and queue families <strong class="purple">must</strong> be capable of
presentation with any layer.
As a result there is no iOS-specific query for these capabilities.</p>
</div>
</div>
<div class="sect3">
<h4 id="platformQuerySupport_macos">32.4.8. macOS Platform</h4>
<div class="paragraph">
<p>On macOS, all physical devices and queue families <strong class="purple">must</strong> be capable of
presentation with any layer.
As a result there is no macOS-specific query for these capabilities.</p>
</div>
</div>
<div class="sect3">
<h4 id="platformQuerySupport_vi">32.4.9. VI Platform</h4>
<div class="paragraph">
<p>On VI, all physical devices and queue families <strong class="purple">must</strong> be capable of
presentation with any layer.
As a result there is no VI-specific query for these capabilities.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_surface_queries">32.5. Surface Queries</h3>
<div class="paragraph">
<p>The capabilities of a swapchain targeting a surface are the intersection of
the capabilities of the WSI platform, the native window or display, and the
physical device.
The resulting capabilities can be obtained with the queries listed below in
this section.
Capabilities that correspond to image creation parameters are not
independent of each other: combinations of parameters that are not supported
as reported by <a href="chap35.html#vkGetPhysicalDeviceImageFormatProperties">vkGetPhysicalDeviceImageFormatProperties</a> are not
supported by the surface on that physical device, even if the capabilities
taken individually are supported as part of some other parameter
combinations.</p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query the basic capabilities of a surface, needed in order to create a
swapchain, call:</p>
</div>
<div id="vkGetPhysicalDeviceSurfaceCapabilitiesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    VkSurfaceCapabilitiesKHR*                   pSurfaceCapabilities);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device that will be associated with
the swapchain to be created, as described for
<a href="#vkCreateSwapchainKHR">vkCreateSwapchainKHR</a>.</p>
</li>
<li>
<p><code>surface</code> is the surface that will be associated with the swapchain.</p>
</li>
<li>
<p><code>pSurfaceCapabilities</code> is a pointer to an instance of the
<a href="#VkSurfaceCapabilitiesKHR">VkSurfaceCapabilitiesKHR</a> structure in which the capabilities are
returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-surface-parameter"></a> <code>surface</code> <strong class="purple">must</strong> be a valid <code>VkSurfaceKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-pSurfaceCapabilities-parameter"></a> <code>pSurfaceCapabilities</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkSurfaceCapabilitiesKHR</code> structure</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-commonparent"></a> Both of <code>physicalDevice</code>, and <code>surface</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkSurfaceCapabilitiesKHR</code> structure is defined as:</p>
</div>
<div id="VkSurfaceCapabilitiesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkSurfaceCapabilitiesKHR {
    uint32_t                         minImageCount;
    uint32_t                         maxImageCount;
    VkExtent2D                       currentExtent;
    VkExtent2D                       minImageExtent;
    VkExtent2D                       maxImageExtent;
    uint32_t                         maxImageArrayLayers;
    VkSurfaceTransformFlagsKHR       supportedTransforms;
    VkSurfaceTransformFlagBitsKHR    currentTransform;
    VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
    VkImageUsageFlags                supportedUsageFlags;
} VkSurfaceCapabilitiesKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>minImageCount</code> is the minimum number of images the specified device
supports for a swapchain created for the surface, and will be at least
one.</p>
</li>
<li>
<p><code>maxImageCount</code> is the maximum number of images the specified device
supports for a swapchain created for the surface, and will be either 0,
or greater than or equal to <code>minImageCount</code>.
A value of 0 means that there is no limit on the number of images,
though there <strong class="purple">may</strong> be limits related to the total amount of memory used
by presentable images.</p>
</li>
<li>
<p><code>currentExtent</code> is the current width and height of the surface, or
the special value <span class="eq">(0xFFFFFFFF, 0xFFFFFFFF)</span> indicating that the
surface size will be determined by the extent of a swapchain targeting
the surface.</p>
</li>
<li>
<p><code>minImageExtent</code> contains the smallest valid swapchain extent for
the surface on the specified device.
The <code>width</code> and <code>height</code> of the extent will each be less than or
equal to the corresponding <code>width</code> and <code>height</code> of
<code>currentExtent</code>, unless <code>currentExtent</code> has the special value
described above.</p>
</li>
<li>
<p><code>maxImageExtent</code> contains the largest valid swapchain extent for the
surface on the specified device.
The <code>width</code> and <code>height</code> of the extent will each be greater than
or equal to the corresponding <code>width</code> and <code>height</code> of
<code>minImageExtent</code>.
The <code>width</code> and <code>height</code> of the extent will each be greater than
or equal to the corresponding <code>width</code> and <code>height</code> of
<code>currentExtent</code>, unless <code>currentExtent</code> has the special value
described above.</p>
</li>
<li>
<p><code>maxImageArrayLayers</code> is the maximum number of layers presentable
images <strong class="purple">can</strong> have for a swapchain created for this device and surface,
and will be at least one.</p>
</li>
<li>
<p><code>supportedTransforms</code> is a bitmask of
<a href="#VkSurfaceTransformFlagBitsKHR">VkSurfaceTransformFlagBitsKHR</a> indicating the presentation
transforms supported for the surface on the specified device.
At least one bit will be set.</p>
</li>
<li>
<p><code>currentTransform</code> is <a href="#VkSurfaceTransformFlagBitsKHR">VkSurfaceTransformFlagBitsKHR</a> value
indicating the surface’s current transform relative to the presentation
engine’s natural orientation.</p>
</li>
<li>
<p><code>supportedCompositeAlpha</code> is a bitmask of
<a href="#VkCompositeAlphaFlagBitsKHR">VkCompositeAlphaFlagBitsKHR</a>, representing the alpha compositing
modes supported by the presentation engine for the surface on the
specified device, and at least one bit will be set.
Opaque composition <strong class="purple">can</strong> be achieved in any alpha compositing mode by
either using an image format that has no alpha component, or by ensuring
that all pixels in the presentable images have an alpha value of 1.0.</p>
</li>
<li>
<p><code>supportedUsageFlags</code> is a bitmask of <a href="chap11.html#VkImageUsageFlagBits">VkImageUsageFlagBits</a>
representing the ways the application <strong class="purple">can</strong> use the presentable images of
a swapchain created
with <a href="#VkPresentModeKHR">VkPresentModeKHR</a> set to <code>VK_PRESENT_MODE_IMMEDIATE_KHR</code>,
<code>VK_PRESENT_MODE_MAILBOX_KHR</code>, <code>VK_PRESENT_MODE_FIFO_KHR</code> or
<code>VK_PRESENT_MODE_FIFO_RELAXED_KHR</code>
for the surface on the specified device.
<code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code> <strong class="purple">must</strong> be included in the set
but implementations <strong class="purple">may</strong> support additional usages.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Supported usage flags of a presentable image when using
<code>VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR</code> or
<code>VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR</code> presentation mode are
provided by
<a href="#VkSharedPresentSurfaceCapabilitiesKHR">VkSharedPresentSurfaceCapabilitiesKHR</a>::<code>sharedPresentSupportedUsageFlags</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Formulas such as <span class="eq">min(N, <code>maxImageCount</code>)</span> are not correct, since
<code>maxImageCount</code> <strong class="purple">may</strong> be zero.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query the basic capabilities of a surface defined by the core or
extensions, call:</p>
</div>
<div id="vkGetPhysicalDeviceSurfaceCapabilities2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkPhysicalDevice                            physicalDevice,
    <span class="directive">const</span> VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
    VkSurfaceCapabilities2KHR*                  pSurfaceCapabilities);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device that will be associated with
the swapchain to be created, as described for
<a href="#vkCreateSwapchainKHR">vkCreateSwapchainKHR</a>.</p>
</li>
<li>
<p><code>pSurfaceInfo</code> points to an instance of the
<a href="#VkPhysicalDeviceSurfaceInfo2KHR">VkPhysicalDeviceSurfaceInfo2KHR</a> structure, describing the surface
and other fixed parameters that would be consumed by
<a href="#vkCreateSwapchainKHR">vkCreateSwapchainKHR</a>.</p>
</li>
<li>
<p><code>pSurfaceCapabilities</code> points to an instance of the
<a href="#VkSurfaceCapabilities2KHR">VkSurfaceCapabilities2KHR</a> structure in which the capabilities are
returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>vkGetPhysicalDeviceSurfaceCapabilities2KHR</code> behaves similarly to
<a href="#vkGetPhysicalDeviceSurfaceCapabilitiesKHR">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</a>, with the ability to specify
extended inputs via chained input structures, and to return extended
information via chained output structures.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceInfo-parameter"></a> <code>pSurfaceInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkPhysicalDeviceSurfaceInfo2KHR</code> structure</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceCapabilities-parameter"></a> <code>pSurfaceCapabilities</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkSurfaceCapabilities2KHR</code> structure</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkPhysicalDeviceSurfaceInfo2KHR</code> structure is defined as:</p>
</div>
<div id="VkPhysicalDeviceSurfaceInfo2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkPhysicalDeviceSurfaceInfo2KHR {
    VkStructureType    sType;
    <span class="directive">const</span> <span class="directive">void</span>*        pNext;
    VkSurfaceKHR       surface;
} VkPhysicalDeviceSurfaceInfo2KHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>surface</code> is the surface that will be associated with the swapchain.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The members of <code>VkPhysicalDeviceSurfaceInfo2KHR</code> correspond to the
arguments to <a href="#vkGetPhysicalDeviceSurfaceCapabilitiesKHR">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</a>, with
<code>sType</code> and <code>pNext</code> added for extensibility.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkPhysicalDeviceSurfaceInfo2KHR-surface-parameter"></a> <code>surface</code> <strong class="purple">must</strong> be a valid <code>VkSurfaceKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkSurfaceCapabilities2KHR</code> structure is defined as:</p>
</div>
<div id="VkSurfaceCapabilities2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkSurfaceCapabilities2KHR {
    VkStructureType             sType;
    <span class="directive">void</span>*                       pNext;
    VkSurfaceCapabilitiesKHR    surfaceCapabilities;
} VkSurfaceCapabilities2KHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>surfaceCapabilities</code> is a structure of type
<a href="#VkSurfaceCapabilitiesKHR">VkSurfaceCapabilitiesKHR</a> describing the capabilities of the
specified surface.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkSurfaceCapabilities2KHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkSurfaceCapabilities2KHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code> or a pointer to a valid instance of <a href="#VkSharedPresentSurfaceCapabilitiesKHR">VkSharedPresentSurfaceCapabilitiesKHR</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkSharedPresentSurfaceCapabilitiesKHR</code> structure is defined as:</p>
</div>
<div id="VkSharedPresentSurfaceCapabilitiesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkSharedPresentSurfaceCapabilitiesKHR {
    VkStructureType      sType;
    <span class="directive">void</span>*                pNext;
    VkImageUsageFlags    sharedPresentSupportedUsageFlags;
} VkSharedPresentSurfaceCapabilitiesKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>sharedPresentSupportedUsageFlags</code> is a bitmask of
<a href="chap11.html#VkImageUsageFlagBits">VkImageUsageFlagBits</a> representing the ways the application <strong class="purple">can</strong>
use the shared presentable image from a swapchain created with
<a href="#VkPresentModeKHR">VkPresentModeKHR</a> set to
<code>VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR</code> or
<code>VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR</code> for the surface on
the specified device.
<code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code> <strong class="purple">must</strong> be included in the set
but implementations <strong class="purple">may</strong> support additional usages.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkSharedPresentSurfaceCapabilitiesKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query the basic capabilities of a surface, needed in order to create a
swapchain, call:</p>
</div>
<div id="vkGetPhysicalDeviceSurfaceCapabilities2EXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    VkSurfaceCapabilities2EXT*                  pSurfaceCapabilities);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device that will be associated with
the swapchain to be created, as described for
<a href="#vkCreateSwapchainKHR">vkCreateSwapchainKHR</a>.</p>
</li>
<li>
<p><code>surface</code> is the surface that will be associated with the swapchain.</p>
</li>
<li>
<p><code>pSurfaceCapabilities</code> is a pointer to an instance of the
<a href="#VkSurfaceCapabilities2EXT">VkSurfaceCapabilities2EXT</a> structure in which the capabilities are
returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>vkGetPhysicalDeviceSurfaceCapabilities2EXT</code> behaves similarly to
<a href="#vkGetPhysicalDeviceSurfaceCapabilitiesKHR">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</a>, with the ability to return
extended information by adding extension structures to the <code>pNext</code> chain
of its <code>pSurfaceCapabilities</code> parameter.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-surface-parameter"></a> <code>surface</code> <strong class="purple">must</strong> be a valid <code>VkSurfaceKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-pSurfaceCapabilities-parameter"></a> <code>pSurfaceCapabilities</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkSurfaceCapabilities2EXT</code> structure</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-commonparent"></a> Both of <code>physicalDevice</code>, and <code>surface</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkSurfaceCapabilities2EXT</code> structure is defined as:</p>
</div>
<div id="VkSurfaceCapabilities2EXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkSurfaceCapabilities2EXT {
    VkStructureType                  sType;
    <span class="directive">void</span>*                            pNext;
    uint32_t                         minImageCount;
    uint32_t                         maxImageCount;
    VkExtent2D                       currentExtent;
    VkExtent2D                       minImageExtent;
    VkExtent2D                       maxImageExtent;
    uint32_t                         maxImageArrayLayers;
    VkSurfaceTransformFlagsKHR       supportedTransforms;
    VkSurfaceTransformFlagBitsKHR    currentTransform;
    VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
    VkImageUsageFlags                supportedUsageFlags;
    VkSurfaceCounterFlagsEXT         supportedSurfaceCounters;
} VkSurfaceCapabilities2EXT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>All members of <code>VkSurfaceCapabilities2EXT</code> are identical to the
corresponding members of <a href="#VkSurfaceCapabilitiesKHR">VkSurfaceCapabilitiesKHR</a> where one exists.
The remaining members are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>supportedSurfaceCounters</code> is a bitmask of
<a href="#VkSurfaceCounterFlagBitsEXT">VkSurfaceCounterFlagBitsEXT</a> indicating the supported surface
counter types.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkSurfaceCapabilities2EXT-supportedSurfaceCounters-01246"></a>
<code>supportedSurfaceCounters</code> <strong class="purple">must</strong> not include
<code>VK_SURFACE_COUNTER_VBLANK_EXT</code> unless the surface queried is a
<a href="#wsi-display-surfaces">display surface</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkSurfaceCapabilities2EXT-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT</code></p>
</li>
<li>
<p><a id="VUID-VkSurfaceCapabilities2EXT-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Bits which <strong class="purple">can</strong> be set in
<a href="#VkSurfaceCapabilities2EXT">VkSurfaceCapabilities2EXT</a>::<code>supportedSurfaceCounters</code>, indicating
supported surface counter types, are:</p>
</div>
<div id="VkSurfaceCounterFlagBitsEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">enum</span> VkSurfaceCounterFlagBitsEXT {
    VK_SURFACE_COUNTER_VBLANK_EXT = <span class="hex">0x00000001</span>,
} VkSurfaceCounterFlagBitsEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_SURFACE_COUNTER_VBLANK_EXT</code> specifies a counter incrementing
once every time a vertical blanking period occurs on the display
associated with the surface.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkSurfaceCounterFlagsEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkFlags VkSurfaceCounterFlagsEXT;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkSurfaceCounterFlagsEXT</code> is a bitmask type for setting a mask of zero
or more <a href="#VkSurfaceCounterFlagBitsEXT">VkSurfaceCounterFlagBitsEXT</a>.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Bits which <strong class="purple">may</strong> be set in
<a href="#VkSurfaceCapabilitiesKHR">VkSurfaceCapabilitiesKHR</a>::<code>supportedTransforms</code> indicating the
presentation transforms supported for the surface on the specified device,
and possible values of
<a href="#VkSurfaceCapabilitiesKHR">VkSurfaceCapabilitiesKHR</a>::<code>currentTransform</code> is indicating the
surface’s current transform relative to the presentation engine’s natural
orientation, are:</p>
</div>
<div id="VkSurfaceTransformFlagBitsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">enum</span> VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = <span class="hex">0x00000001</span>,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = <span class="hex">0x00000002</span>,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = <span class="hex">0x00000004</span>,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = <span class="hex">0x00000008</span>,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = <span class="hex">0x00000010</span>,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = <span class="hex">0x00000020</span>,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = <span class="hex">0x00000040</span>,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = <span class="hex">0x00000080</span>,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = <span class="hex">0x00000100</span>,
} VkSurfaceTransformFlagBitsKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR</code> specifies that image content
is presented without being transformed.</p>
</li>
<li>
<p><code>VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR</code> specifies that image
content is rotated 90 degrees clockwise.</p>
</li>
<li>
<p><code>VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR</code> specifies that image
content is rotated 180 degrees clockwise.</p>
</li>
<li>
<p><code>VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR</code> specifies that image
content is rotated 270 degrees clockwise.</p>
</li>
<li>
<p><code>VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR</code> specifies that
image content is mirrored horizontally.</p>
</li>
<li>
<p><code>VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR</code> specifies
that image content is mirrored horizontally, then rotated 90 degrees
clockwise.</p>
</li>
<li>
<p><code>VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR</code>
specifies that image content is mirrored horizontally, then rotated 180
degrees clockwise.</p>
</li>
<li>
<p><code>VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR</code>
specifies that image content is mirrored horizontally, then rotated 270
degrees clockwise.</p>
</li>
<li>
<p><code>VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR</code> specifies that the
presentation transform is not specified, and is instead determined by
platform-specific considerations and mechanisms outside Vulkan.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkSurfaceTransformFlagsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkFlags VkSurfaceTransformFlagsKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkSurfaceTransformFlagsKHR</code> is a bitmask type for setting a mask of
zero or more <a href="#VkSurfaceTransformFlagBitsKHR">VkSurfaceTransformFlagBitsKHR</a>.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>supportedCompositeAlpha</code> member is of type
<a href="#VkCompositeAlphaFlagBitsKHR">VkCompositeAlphaFlagBitsKHR</a>, which contains the following values:</p>
</div>
<div id="VkCompositeAlphaFlagBitsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">enum</span> VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = <span class="hex">0x00000001</span>,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = <span class="hex">0x00000002</span>,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = <span class="hex">0x00000004</span>,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = <span class="hex">0x00000008</span>,
} VkCompositeAlphaFlagBitsKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p>These values are described as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR</code>: The alpha channel, if it
exists, of the images is ignored in the compositing process.
Instead, the image is treated as if it has a constant alpha of 1.0.</p>
</li>
<li>
<p><code>VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR</code>: The alpha channel, if
it exists, of the images is respected in the compositing process.
The non-alpha channels of the image are expected to already be
multiplied by the alpha channel by the application.</p>
</li>
<li>
<p><code>VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR</code>: The alpha channel, if
it exists, of the images is respected in the compositing process.
The non-alpha channels of the image are not expected to already be
multiplied by the alpha channel by the application; instead, the
compositor will multiply the non-alpha channels of the image by the
alpha channel during compositing.</p>
</li>
<li>
<p><code>VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR</code>: The way in which the
presentation engine treats the alpha channel in the images is unknown to
the Vulkan API.
Instead, the application is responsible for setting the composite alpha
blending mode using native window system commands.
If the application does not set the blending mode using native window
system commands, then a platform-specific default will be used.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkCompositeAlphaFlagsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkFlags VkCompositeAlphaFlagsKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkCompositeAlphaFlagsKHR</code> is a bitmask type for setting a mask of zero
or more <a href="#VkCompositeAlphaFlagBitsKHR">VkCompositeAlphaFlagBitsKHR</a>.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query the supported swapchain format-color space pairs for a surface,
call:</p>
</div>
<div id="vkGetPhysicalDeviceSurfaceFormatsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pSurfaceFormatCount,
    VkSurfaceFormatKHR*                         pSurfaceFormats);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device that will be associated with
the swapchain to be created, as described for
<a href="#vkCreateSwapchainKHR">vkCreateSwapchainKHR</a>.</p>
</li>
<li>
<p><code>surface</code> is the surface that will be associated with the swapchain.</p>
</li>
<li>
<p><code>pSurfaceFormatCount</code> is a pointer to an integer related to the
number of format pairs available or queried, as described below.</p>
</li>
<li>
<p><code>pSurfaceFormats</code> is either <code>NULL</code> or a pointer to an array of
<code>VkSurfaceFormatKHR</code> structures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>pSurfaceFormats</code> is <code>NULL</code>, then the number of format pairs
supported for the given <code>surface</code> is returned in
<code>pSurfaceFormatCount</code>.
The number of format pairs supported will be greater than or equal to 1.
Otherwise, <code>pSurfaceFormatCount</code> <strong class="purple">must</strong> point to a variable set by the
user to the number of elements in the <code>pSurfaceFormats</code> array, and on
return the variable is overwritten with the number of structures actually
written to <code>pSurfaceFormats</code>.
If the value of <code>pSurfaceFormatCount</code> is less than the number of format
pairs supported, at most <code>pSurfaceFormatCount</code> structures will be
written.
If <code>pSurfaceFormatCount</code> is smaller than the number of format pairs
supported for the given <code>surface</code>, <code>VK_INCOMPLETE</code> will be returned
instead of <code>VK_SUCCESS</code> to indicate that not all the available values
were returned.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-surface-parameter"></a> <code>surface</code> <strong class="purple">must</strong> be a valid <code>VkSurfaceKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-pSurfaceFormatCount-parameter"></a> <code>pSurfaceFormatCount</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-pSurfaceFormats-parameter"></a> If the value referenced by <code>pSurfaceFormatCount</code> is not <code>0</code>, and <code>pSurfaceFormats</code> is not <code>NULL</code>, <code>pSurfaceFormats</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pSurfaceFormatCount</code> <code>VkSurfaceFormatKHR</code> structures</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-commonparent"></a> Both of <code>physicalDevice</code>, and <code>surface</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_INCOMPLETE</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkSurfaceFormatKHR</code> structure is defined as:</p>
</div>
<div id="VkSurfaceFormatKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkSurfaceFormatKHR {
    VkFormat           format;
    VkColorSpaceKHR    colorSpace;
} VkSurfaceFormatKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>format</code> is a <a href="chap35.html#VkFormat">VkFormat</a> that is compatible with the specified
surface.</p>
</li>
<li>
<p><code>colorSpace</code> is a presentation <a href="#VkColorSpaceKHR">VkColorSpaceKHR</a> that is
compatible with the surface.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query the supported swapchain format tuples for a surface, call:</p>
</div>
<div id="vkGetPhysicalDeviceSurfaceFormats2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetPhysicalDeviceSurfaceFormats2KHR(
    VkPhysicalDevice                            physicalDevice,
    <span class="directive">const</span> VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
    uint32_t*                                   pSurfaceFormatCount,
    VkSurfaceFormat2KHR*                        pSurfaceFormats);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device that will be associated with
the swapchain to be created, as described for
<a href="#vkCreateSwapchainKHR">vkCreateSwapchainKHR</a>.</p>
</li>
<li>
<p><code>pSurfaceInfo</code> points to an instance of the
<a href="#VkPhysicalDeviceSurfaceInfo2KHR">VkPhysicalDeviceSurfaceInfo2KHR</a> structure, describing the surface
and other fixed parameters that would be consumed by
<a href="#vkCreateSwapchainKHR">vkCreateSwapchainKHR</a>.</p>
</li>
<li>
<p><code>pSurfaceFormatCount</code> is a pointer to an integer related to the
number of format tuples available or queried, as described below.</p>
</li>
<li>
<p><code>pSurfaceFormats</code> is either <code>NULL</code> or a pointer to an array of
<a href="#VkSurfaceFormat2KHR">VkSurfaceFormat2KHR</a> structures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>pSurfaceFormats</code> is <code>NULL</code>, then the number of format tuples
supported for the given <code>surface</code> is returned in
<code>pSurfaceFormatCount</code>.
The number of format tuples supported will be greater than or equal to 1.
Otherwise, <code>pSurfaceFormatCount</code> <strong class="purple">must</strong> point to a variable set by the
user to the number of elements in the <code>pSurfaceFormats</code> array, and on
return the variable is overwritten with the number of structures actually
written to <code>pSurfaceFormats</code>.
If the value of <code>pSurfaceFormatCount</code> is less than the number of format
tuples supported, at most <code>pSurfaceFormatCount</code> structures will be
written.
If <code>pSurfaceFormatCount</code> is smaller than the number of format tuples
supported for the surface parameters described in <code>pSurfaceInfo</code>,
<code>VK_INCOMPLETE</code> will be returned instead of <code>VK_SUCCESS</code> to indicate
that not all the available values were returned.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceInfo-parameter"></a> <code>pSurfaceInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkPhysicalDeviceSurfaceInfo2KHR</code> structure</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceFormatCount-parameter"></a> <code>pSurfaceFormatCount</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceFormats-parameter"></a> If the value referenced by <code>pSurfaceFormatCount</code> is not <code>0</code>, and <code>pSurfaceFormats</code> is not <code>NULL</code>, <code>pSurfaceFormats</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pSurfaceFormatCount</code> <code>VkSurfaceFormat2KHR</code> structures</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_INCOMPLETE</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkSurfaceFormat2KHR</code> structure is defined as:</p>
</div>
<div id="VkSurfaceFormat2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkSurfaceFormat2KHR {
    VkStructureType       sType;
    <span class="directive">void</span>*                 pNext;
    VkSurfaceFormatKHR    surfaceFormat;
} VkSurfaceFormat2KHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>surfaceFormat</code> is an instance of <a href="#VkSurfaceFormatKHR">VkSurfaceFormatKHR</a>
describing a format-color space pair that is compatible with the
specified surface.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkSurfaceFormat2KHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkSurfaceFormat2KHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>While the <code>format</code> of a presentable image refers to the encoding of each
pixel, the <code>colorSpace</code> determines how the presentation engine
interprets the pixel values.
A color space in this document refers to a specific color space (defined by
the chromaticities of its primaries and a white point in CIE Lab), and a
transfer function that is applied before storing or transmitting color data
in the given color space.</p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Possible values of <a href="#VkSurfaceFormatKHR">VkSurfaceFormatKHR</a>::<code>colorSpace</code>, specifying
supported color spaces of a presentation engine, are:</p>
</div>
<div id="VkColorSpaceKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">enum</span> VkColorSpaceKHR {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = <span class="integer">0</span>,
    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = <span class="integer">1000104001</span>,
    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = <span class="integer">1000104002</span>,
    VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = <span class="integer">1000104003</span>,
    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = <span class="integer">1000104004</span>,
    VK_COLOR_SPACE_BT709_LINEAR_EXT = <span class="integer">1000104005</span>,
    VK_COLOR_SPACE_BT709_NONLINEAR_EXT = <span class="integer">1000104006</span>,
    VK_COLOR_SPACE_BT2020_LINEAR_EXT = <span class="integer">1000104007</span>,
    VK_COLOR_SPACE_HDR10_ST2084_EXT = <span class="integer">1000104008</span>,
    VK_COLOR_SPACE_DOLBYVISION_EXT = <span class="integer">1000104009</span>,
    VK_COLOR_SPACE_HDR10_HLG_EXT = <span class="integer">1000104010</span>,
    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = <span class="integer">1000104011</span>,
    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = <span class="integer">1000104012</span>,
    VK_COLOR_SPACE_PASS_THROUGH_EXT = <span class="integer">1000104013</span>,
    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = <span class="integer">1000104014</span>,
    VK_COLORSPACE_SRGB_NONLINEAR_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
} VkColorSpaceKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</code> specifies support for the sRGB
color space.</p>
</li>
<li>
<p><code>VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT</code> specifies support for the
Display-P3 color space and applies an sRGB-like transfer function
(defined below).</p>
</li>
<li>
<p><code>VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT</code> specifies support for the
extended sRGB color space and applies a linear transfer function.</p>
</li>
<li>
<p><code>VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT</code> specifies support for
the extended sRGB color space and applies an sRGB transfer function.</p>
</li>
<li>
<p><code>VK_COLOR_SPACE_DCI_P3_LINEAR_EXT</code> specifies support for the DCI-P3
color space and applies a linear OETF.</p>
</li>
<li>
<p><code>VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT</code> specifies support for the
DCI-P3 color space and applies the Gamma 2.6 OETF.</p>
</li>
<li>
<p><code>VK_COLOR_SPACE_BT709_LINEAR_EXT</code> specifies support for the BT709
color space and applies a linear OETF.</p>
</li>
<li>
<p><code>VK_COLOR_SPACE_BT709_NONLINEAR_EXT</code> specifies support for the BT709
color space and applies the SMPTE 170M OETF.</p>
</li>
<li>
<p><code>VK_COLOR_SPACE_BT2020_LINEAR_EXT</code> specifies support for the BT2020
color space and applies a linear OETF.</p>
</li>
<li>
<p><code>VK_COLOR_SPACE_HDR10_ST2084_EXT</code> specifies support for the HDR10
(BT2020 color) space and applies the SMPTE ST2084 Perceptual Quantizer
(PQ) OETF.</p>
</li>
<li>
<p><code>VK_COLOR_SPACE_DOLBYVISION_EXT</code> specifies support for the Dolby
Vision (BT2020 color space), proprietary encoding, and applies the SMPTE
ST2084 OETF.</p>
</li>
<li>
<p><code>VK_COLOR_SPACE_HDR10_HLG_EXT</code> specifies support for the HDR10
(BT2020 color space) and applies the Hybrid Log Gamma (HLG) OETF.</p>
</li>
<li>
<p><code>VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT</code> specifies support for the
AdobeRGB color space and applies a linear OETF.</p>
</li>
<li>
<p><code>VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT</code> specifies support for the
AdobeRGB color space and applies the Gamma 2.2 OETF.</p>
</li>
<li>
<p><code>VK_COLOR_SPACE_PASS_THROUGH_EXT</code> specifies that color components
are used “as is”.
This is intended to allow applications to supply data for color spaces
not described here.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The color components of Non-linear color space swap chain images have had
the appropriate transfer function applied.
Vulkan requires that all implementations support the sRGB transfer function
when using an SRGB pixel format.
Other transfer functions, such as SMPTE 170M or SMPTE2084, <strong class="purple">must</strong> not be
performed by the implementation, but <strong class="purple">can</strong> be performed by the application
shader.
This extension defines enums for <a href="#VkColorSpaceKHR">VkColorSpaceKHR</a> that correspond to
the following color spaces:</p>
</div>
<table id="VK_EXT_swapchain_colorspace-table" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 45. Color Spaces and Attributes</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Red Primary</th>
<th class="tableblock halign-left valign-top">Green Primary</th>
<th class="tableblock halign-left valign-top">Blue Primary</th>
<th class="tableblock halign-left valign-top">White-point</th>
<th class="tableblock halign-left valign-top">Transfer function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DCI-P3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.680, 0.320</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.265, 0.690</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.150, 0.060</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.3127, 0.3290 (D65)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gamma 2.6</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Display-P3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.680, 0.320</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.265, 0.690</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.150, 0.060</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.3127, 0.3290 (D65)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Display-P3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BT709</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.640, 0.330</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.300, 0.600</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.150, 0.060</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.3127, 0.3290 (D65)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMPTE 170M</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sRGB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.640, 0.330</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.300, 0.600</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.150, 0.060</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.3127, 0.3290 (D65)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sRGB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">extended sRGB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.640, 0.330</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.300, 0.600</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.150, 0.060</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.3127, 0.3290 (D65)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">extended sRGB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HDR10_ST2084</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.708, 0.292</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.170, 0.797</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.131, 0.046</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.3127, 0.3290 (D65)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ST2084</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOLBYVISION</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.708, 0.292</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.170, 0.797</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.131, 0.046</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.3127, 0.3290 (D65)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ST2084</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HDR10_HLG</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.708, 0.292</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.170, 0.797</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.131, 0.046</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.3127, 0.3290 (D65)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HLG</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AdobeRGB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.640, 0.330</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.210, 0.710</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.150, 0.060</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.3127, 0.3290 (D65)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AdobeRGB</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For Opto-Electrical Transfer Function (OETF), unless otherwise specified,
the values of <span class="eq">L</span> and <span class="eq">E</span> are defined as:</p>
</div>
<div class="paragraph">
<p><span class="eq">L</span> - linear luminance of image \(0 \leq L \leq 1\) for
conventional colorimetry</p>
</div>
<div class="paragraph">
<p><span class="eq">E</span> - corresponding electrical signal (value stored in memory)</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_srgb_transfer_function">32.5.1. sRGB transfer function</h4>
<div class="stemblock">
<div class="content">
\[\begin{aligned}
E &amp; =
  \begin{cases}
    1.055 \times L^{1 \over 2.4} - 0.055 &amp; \text{for}\  0.0031308 \leq L \leq 1 \\
    12.92 \times L                       &amp; \text{for}\  0 \leq L &lt; 0.0031308
  \end{cases}
\end{aligned}\]
</div>
</div>
</div>
<div class="sect3">
<h4 id="_display_p3_eotf">32.5.2. Display-P3 EOTF</h4>
<div class="stemblock">
<div class="content">
\[\begin{aligned}
E &amp; =
  \begin{cases}
    (a \times L + b)^{2.4} &amp; \text{for}\  0.039 \leq L \leq 1 \\
    b \times L                    &amp; \text{for}\  0 \leq L &lt; 0.039
  \end{cases}
\end{aligned}\]
</div>
</div>
<div class="paragraph">
<p>\(a = 0.948\)<br>
\(b = 0.052\)<br>
\(c = 0.077\)<br></p>
</div>
</div>
<div class="sect3">
<h4 id="_display_p3_oetf">32.5.3. Display-P3 OETF</h4>
<div class="stemblock">
<div class="content">
\[\begin{aligned}
E &amp; =
  \begin{cases}
    1.055 \times L^{1 \over 2.4} - 0.055 &amp; \text{for}\  0.0030186 \leq L \leq 1 \\
    12.92 \times L                       &amp; \text{for}\  0 \leq L &lt; 0.0030186
  \end{cases}
\end{aligned}\]
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>For most uses, the sRGB OETF is equivalent.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_extended_srgb_oetf">32.5.4. Extended sRGB OETF</h4>
<div class="stemblock">
<div class="content">
\[\begin{aligned}
E &amp; =
  \begin{cases}
    1.055 \times L^{1 \over 2.4} - 0.055 &amp; \text{for}\  0.0031308 \leq L \leq 7.5913 \\
    12.92 \times L                       &amp; \text{for}\  0 \leq L &lt; 0.0031308 \\
    -f(-L)                               &amp; \text{for}\  L &lt; 0
  \end{cases}
\end{aligned}\]
</div>
</div>
<div class="paragraph">
<p><span class="eq">L</span> - luminance of image is within <span class="eq">[-0.6038, 7.5913]</span>.</p>
</div>
<div class="paragraph">
<p><span class="eq">E</span> can be negative and/or &gt; 1.
That is how extended sRGB specifies colors outside the standard sRGB gamut.
This means extended sRGB needs a floating point pixel format to cover the
intended color range.</p>
</div>
</div>
<div class="sect3">
<h4 id="_smpte_170m_oetf">32.5.5. SMPTE 170M OETF</h4>
<div class="stemblock">
<div class="content">
\[\begin{aligned}
E &amp; =
  \begin{cases}
    \alpha \times L^{0.45} - (1 - \alpha) &amp; \text{for}\  \beta \leq L \leq 1 \\
    4.5 \times L                            &amp; \text{for}\  0 \leq L &lt; \beta
  \end{cases}
\end{aligned}\]
</div>
</div>
<div class="paragraph">
<p>\(\alpha = 1.099 \text{ and } \beta = 0.018 \text{ for 10-bits and
less per sample system (the values given in Rec.
709)}\)<br>
\(\alpha = 1.0993 \text{ and } \beta = 0.0181 \text{ for 12-bits
per sample system}\)</p>
</div>
</div>
<div class="sect3">
<h4 id="_smpte_st2084_oetf_inverse_eotf">32.5.6. SMPTE ST2084 OETF (Inverse-EOTF)</h4>
<div class="stemblock">
<div class="content">
\[
E = (\frac{c_1 + c_2 \times L^{m_1}}{1 + c_3 \times L^{m_1}})^{m_2}
\]
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="paragraph">
<p>\(m_1 = 2610 / 4096 \times \frac{1}{4} = 0.1593017578125\)<br>
\(m_2 = 2523 / 4096 \times 128 = 78.84375\)<br>
\(c_1 = 3424 / 4096 = 0.8359375 = c3 - c2 + 1\)<br>
\(c_2 = 2413 / 4096 \times 32 = 18.8515625\)<br>
\(c_3 = 2392 / 4096 \times 32 = 18.6875\)<br></p>
</div>
</div>
<div class="sect3">
<h4 id="_hybrid_log_gamma_hlg">32.5.7. Hybrid Log Gamma (HLG)</h4>
<div class="stemblock">
<div class="content">
\[\begin{aligned}
E &amp; =
  \begin{cases}
    r \sqrt{L}                &amp; \text{for}\  0 \leq L \leq 1 \\
    a \times \ln(L - b) + c    &amp; \text{for}\  1 &lt; L
  \end{cases}
\end{aligned}\]
</div>
</div>
<div class="paragraph">
<p><span class="eq"><em>L</em></span> — is the signal normalized by the reference white level<br>
<span class="eq"><em>r</em></span> — is the reference white level and has a signal value of 0.5<br>
<span class="eq"><em>a</em> = 0.17883277</span> and <span class="eq"><em>b</em> = 0.28466892</span> and <span class="eq"><em>c</em> = 0.55991073</span></p>
</div>
</div>
<div class="sect3">
<h4 id="_adobe_rgb_1998_oetf">32.5.8. Adobe RGB (1998) OETF</h4>
<div class="paragraph">
<p>\(E = L^\frac{1}{2.19921875}\)</p>
</div>
</div>
<div class="sect3">
<h4 id="_gamma_2_6_oetf">32.5.9. Gamma 2.6 OETF</h4>
<div class="paragraph">
<p>\(E = L^\frac{1}{2.6}\)</p>
</div>
<div class="paragraph">
<p>An implementation supporting this extension indicates support for these
color spaces via <a href="#VkSurfaceFormatKHR">VkSurfaceFormatKHR</a> structures returned from
<a href="#vkGetPhysicalDeviceSurfaceFormatsKHR">vkGetPhysicalDeviceSurfaceFormatsKHR</a>.</p>
</div>
<div class="paragraph">
<p>Specifying the supported surface color space when calling
<a href="#vkCreateSwapchainKHR">vkCreateSwapchainKHR</a> will create a swapchain using that color space.</p>
</div>
<div class="paragraph">
<p>Vulkan requires that all implementations support the sRGB Opto-Electrical
Transfer Function (OETF) and Electro-optical transfer function (EOTF) when
using an SRGB pixel format.
Other transfer functions, such as SMPTE 170M, <strong class="purple">must</strong> not be performed by the
implementation, but <strong class="purple">can</strong> be performed by the application shader.</p>
</div>
<div class="paragraph">
<p>If <code>pSurfaceFormats</code> includes an entry whose value for <code>colorSpace</code>
is <code>VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</code> and whose value for <code>format</code>
is a UNORM (or SRGB) format and the corresponding SRGB (or UNORM) format is
a color renderable format for <code>VK_IMAGE_TILING_OPTIMAL</code>, then
<code>pSurfaceFormats</code> <strong class="purple">must</strong> also contain an entry with the same value for
<code>colorSpace</code> and <code>format</code> equal to the corresponding SRGB (or UNORM)
format.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>If <code>pSurfaceFormats</code> includes just one entry, whose value for
<code>format</code> is <code>VK_FORMAT_UNDEFINED</code>, <code>surface</code> has no preferred
format.
In this case, the application <strong class="purple">can</strong> use any valid <a href="chap35.html#VkFormat">VkFormat</a> value.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>In the initial release of the <code>VK_KHR_surface</code> and <code><a href="chap40.html#VK_KHR_swapchain">VK_KHR_swapchain</a></code>
extensions, the token <code>VK_COLORSPACE_SRGB_NONLINEAR_KHR</code> was used.
Starting in the 2016-05-13 updates to the extension branches, matching
release 1.0.13 of the core API specification,
<code>VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</code> is used instead for consistency with
Vulkan naming rules.
The older enum is still available for backwards compatibility.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query the supported presentation modes for a surface, call:</p>
</div>
<div id="vkGetPhysicalDeviceSurfacePresentModesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pPresentModeCount,
    VkPresentModeKHR*                           pPresentModes);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device that will be associated with
the swapchain to be created, as described for
<a href="#vkCreateSwapchainKHR">vkCreateSwapchainKHR</a>.</p>
</li>
<li>
<p><code>surface</code> is the surface that will be associated with the swapchain.</p>
</li>
<li>
<p><code>pPresentModeCount</code> is a pointer to an integer related to the number
of presentation modes available or queried, as described below.</p>
</li>
<li>
<p><code>pPresentModes</code> is either <code>NULL</code> or a pointer to an array of
<a href="#VkPresentModeKHR">VkPresentModeKHR</a> values, indicating the supported presentation
modes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>pPresentModes</code> is <code>NULL</code>, then the number of presentation modes
supported for the given <code>surface</code> is returned in
<code>pPresentModeCount</code>.
Otherwise, <code>pPresentModeCount</code> <strong class="purple">must</strong> point to a variable set by the user
to the number of elements in the <code>pPresentModes</code> array, and on return
the variable is overwritten with the number of values actually written to
<code>pPresentModes</code>.
If the value of <code>pPresentModeCount</code> is less than the number of
presentation modes supported, at most <code>pPresentModeCount</code> values will be
written.
If <code>pPresentModeCount</code> is smaller than the number of presentation modes
supported for the given <code>surface</code>, <code>VK_INCOMPLETE</code> will be returned
instead of <code>VK_SUCCESS</code> to indicate that not all the available values
were returned.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-surface-parameter"></a> <code>surface</code> <strong class="purple">must</strong> be a valid <code>VkSurfaceKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-pPresentModeCount-parameter"></a> <code>pPresentModeCount</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-pPresentModes-parameter"></a> If the value referenced by <code>pPresentModeCount</code> is not <code>0</code>, and <code>pPresentModes</code> is not <code>NULL</code>, <code>pPresentModes</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pPresentModeCount</code> <a href="#VkPresentModeKHR">VkPresentModeKHR</a> values</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-commonparent"></a> Both of <code>physicalDevice</code>, and <code>surface</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_INCOMPLETE</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Possible values of elements of the
<a href="#vkGetPhysicalDeviceSurfacePresentModesKHR">vkGetPhysicalDeviceSurfacePresentModesKHR</a>::<code>pPresentModes</code> array,
indicating the supported presentation modes for a surface, are:</p>
</div>
<div id="VkPresentModeKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">enum</span> VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR = <span class="integer">0</span>,
    VK_PRESENT_MODE_MAILBOX_KHR = <span class="integer">1</span>,
    VK_PRESENT_MODE_FIFO_KHR = <span class="integer">2</span>,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = <span class="integer">3</span>,
    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = <span class="integer">1000111000</span>,
    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = <span class="integer">1000111001</span>,
} VkPresentModeKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_PRESENT_MODE_IMMEDIATE_KHR</code> specifies that the presentation
engine does not wait for a vertical blanking period to update the
current image, meaning this mode <strong class="purple">may</strong> result in visible tearing.
No internal queuing of presentation requests is needed, as the requests
are applied immediately.</p>
</li>
<li>
<p><code>VK_PRESENT_MODE_MAILBOX_KHR</code> specifies that the presentation engine
waits for the next vertical blanking period to update the current image.
Tearing <strong class="purple">cannot</strong> be observed.
An internal single-entry queue is used to hold pending presentation
requests.
If the queue is full when a new presentation request is received, the
new request replaces the existing entry, and any images associated with
the prior entry become available for re-use by the application.
One request is removed from the queue and processed during each vertical
blanking period in which the queue is non-empty.</p>
</li>
<li>
<p><code>VK_PRESENT_MODE_FIFO_KHR</code> specifies that the presentation engine
waits for the next vertical blanking period to update the current image.
Tearing <strong class="purple">cannot</strong> be observed.
An internal queue is used to hold pending presentation requests.
New requests are appended to the end of the queue, and one request is
removed from the beginning of the queue and processed during each
vertical blanking period in which the queue is non-empty.
This is the only value of <code>presentMode</code> that is <strong class="purple">required</strong> to be
supported.</p>
</li>
<li>
<p><code>VK_PRESENT_MODE_FIFO_RELAXED_KHR</code> specifies that the presentation
engine generally waits for the next vertical blanking period to update
the current image.
If a vertical blanking period has already passed since the last update
of the current image then the presentation engine does not wait for
another vertical blanking period for the update, meaning this mode <strong class="purple">may</strong>
result in visible tearing in this case.
This mode is useful for reducing visual stutter with an application that
will mostly present a new image before the next vertical blanking
period, but may occasionally be late, and present a new image just after
the next vertical blanking period.
An internal queue is used to hold pending presentation requests.
New requests are appended to the end of the queue, and one request is
removed from the beginning of the queue and processed during or after
each vertical blanking period in which the queue is non-empty.</p>
</li>
<li>
<p><code>VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR</code> specifies that the
presentation engine and application have concurrent access to a single
image, which is referred to as a <em>shared presentable image</em>.
The presentation engine is only required to update the current image
after a new presentation request is received.
Therefore the application <strong class="purple">must</strong> make a presentation request whenever an
update is required.
However, the presentation engine <strong class="purple">may</strong> update the current image at any
point, meaning this mode <strong class="purple">may</strong> result in visible tearing.</p>
</li>
<li>
<p><code>VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR</code> specifies that the
presentation engine and application have concurrent access to a single
image, which is referred to as a <em>shared presentable image</em>.
The presentation engine periodically updates the current image on its
regular refresh cycle.
The application is only required to make one initial presentation
request, after which the presentation engine <strong class="purple">must</strong> update the current
image without any need for further presentation requests.
The application <strong class="purple">can</strong> indicate the image contents have been updated by
making a presentation request, but this does not guarantee the timing of
when it will be updated.
This mode <strong class="purple">may</strong> result in visible tearing if rendering to the image is
not timed correctly.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The supported <a href="chap11.html#VkImageUsageFlagBits">VkImageUsageFlagBits</a> of the presentable images of a
swapchain created for a surface <strong class="purple">may</strong> differ depending on the presentation
mode, and can be determined as per the table below:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 46. Presentable image usage queries</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Presentation mode</th>
<th class="tableblock halign-left valign-top">Image usage flags</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PRESENT_MODE_IMMEDIATE_KHR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkSurfaceCapabilitiesKHR">VkSurfaceCapabilitiesKHR</a>::<code>supportedUsageFlags</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PRESENT_MODE_MAILBOX_KHR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkSurfaceCapabilitiesKHR">VkSurfaceCapabilitiesKHR</a>::<code>supportedUsageFlags</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PRESENT_MODE_FIFO_KHR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkSurfaceCapabilitiesKHR">VkSurfaceCapabilitiesKHR</a>::<code>supportedUsageFlags</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PRESENT_MODE_FIFO_RELAXED_KHR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkSurfaceCapabilitiesKHR">VkSurfaceCapabilitiesKHR</a>::<code>supportedUsageFlags</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkSharedPresentSurfaceCapabilitiesKHR">VkSharedPresentSurfaceCapabilitiesKHR</a>::<code>sharedPresentSupportedUsageFlags</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkSharedPresentSurfaceCapabilitiesKHR">VkSharedPresentSurfaceCapabilitiesKHR</a>::<code>sharedPresentSupportedUsageFlags</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>For reference, the mode indicated by <code>VK_PRESENT_MODE_FIFO_KHR</code> is
equivalent to the behavior of {wgl|glX|egl}SwapBuffers with a swap interval
of 1, while the mode indicated by <code>VK_PRESENT_MODE_FIFO_RELAXED_KHR</code> is
equivalent to the behavior of {wgl|glX}SwapBuffers with a swap interval of
-1 (from the {WGL|GLX}_EXT_swap_control_tear extensions).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_device_group_queries">32.6. Device Group Queries</h3>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>A logical device that represents multiple physical devices <strong class="purple">may</strong> support
presenting from images on more than one physical device, or combining images
from multiple physical devices.</p>
</div>
<div class="paragraph">
<p>To query these capabilities, call:</p>
</div>
<div id="vkGetDeviceGroupPresentCapabilitiesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetDeviceGroupPresentCapabilitiesKHR(
    VkDevice                                    device,
    VkDeviceGroupPresentCapabilitiesKHR*        pDeviceGroupPresentCapabilities);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device.</p>
</li>
<li>
<p><code>pDeviceGroupPresentCapabilities</code> is a pointer to a structure of
type <a href="#VkDeviceGroupPresentCapabilitiesKHR">VkDeviceGroupPresentCapabilitiesKHR</a> that is filled with the
logical device’s capabilities.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetDeviceGroupPresentCapabilitiesKHR-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <code>VkDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetDeviceGroupPresentCapabilitiesKHR-pDeviceGroupPresentCapabilities-parameter"></a> <code>pDeviceGroupPresentCapabilities</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkDeviceGroupPresentCapabilitiesKHR</code> structure</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDeviceGroupPresentCapabilitiesKHR</code> structure is defined as:</p>
</div>
<div id="VkDeviceGroupPresentCapabilitiesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDeviceGroupPresentCapabilitiesKHR {
    VkStructureType                     sType;
    <span class="directive">const</span> <span class="directive">void</span>*                         pNext;
    uint32_t                            presentMask[VK_MAX_DEVICE_GROUP_SIZE];
    VkDeviceGroupPresentModeFlagsKHR    modes;
} VkDeviceGroupPresentCapabilitiesKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>presentMask</code> is an array of masks, where the mask at element
<span class="eq">i</span> is non-zero if physical device <span class="eq">i</span> has a presentation
engine, and where bit <span class="eq">j</span> is set in element <span class="eq">i</span> if physical
device <span class="eq">i</span> <strong class="purple">can</strong> present swapchain images from physical device
<span class="eq">j</span>.
If element <span class="eq">i</span> is non-zero, then bit <span class="eq">i</span> <strong class="purple">must</strong> be set.</p>
</li>
<li>
<p><code>modes</code> is a bitmask of <a href="#VkDeviceGroupPresentModeFlagBitsKHR">VkDeviceGroupPresentModeFlagBitsKHR</a>
indicating which device group presentation modes are supported.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>modes</code> always has <code>VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR</code> set.</p>
</div>
<div class="paragraph">
<p>The present mode flags are also used when presenting an image, in
<a href="#VkDeviceGroupPresentInfoKHR">VkDeviceGroupPresentInfoKHR</a>::<code>mode</code>.</p>
</div>
<div class="paragraph">
<p>If a device group only includes a single physical device, then <code>modes</code>
<strong class="purple">must</strong> equal <code>VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDeviceGroupPresentCapabilitiesKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkDeviceGroupPresentCapabilitiesKHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Bits which <strong class="purple">may</strong> be set in
<a href="#VkDeviceGroupPresentCapabilitiesKHR">VkDeviceGroupPresentCapabilitiesKHR</a>::<code>modes</code> to indicate which
device group presentation modes are supported are:</p>
</div>
<div id="VkDeviceGroupPresentModeFlagBitsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">enum</span> VkDeviceGroupPresentModeFlagBitsKHR {
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = <span class="hex">0x00000001</span>,
    VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = <span class="hex">0x00000002</span>,
    VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = <span class="hex">0x00000004</span>,
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = <span class="hex">0x00000008</span>,
} VkDeviceGroupPresentModeFlagBitsKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR</code> specifies that any
physical device with a presentation engine <strong class="purple">can</strong> present its own
swapchain images.</p>
</li>
<li>
<p><code>VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR</code> specifies that any
physical device with a presentation engine <strong class="purple">can</strong> present swapchain images
from any physical device in its <code>presentMask</code>.</p>
</li>
<li>
<p><code>VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR</code> specifies that any
physical device with a presentation engine <strong class="purple">can</strong> present the sum of
swapchain images from any physical devices in its <code>presentMask</code>.</p>
</li>
<li>
<p><code>VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR</code> specifies
that multiple physical devices with a presentation engine <strong class="purple">can</strong> each
present their own swapchain images.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkDeviceGroupPresentModeFlagsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkFlags VkDeviceGroupPresentModeFlagsKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkDeviceGroupPresentModeFlagsKHR</code> is a bitmask type for setting a mask
of zero or more <a href="#VkDeviceGroupPresentModeFlagBitsKHR">VkDeviceGroupPresentModeFlagBitsKHR</a>.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Some surfaces <strong class="purple">may</strong> not be capable of using all the device group present
modes.</p>
</div>
<div class="paragraph">
<p>To query the supported device group present modes for a particular surface,
call:</p>
</div>
<div id="vkGetDeviceGroupSurfacePresentModesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetDeviceGroupSurfacePresentModesKHR(
    VkDevice                                    device,
    VkSurfaceKHR                                surface,
    VkDeviceGroupPresentModeFlagsKHR*           pModes);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device.</p>
</li>
<li>
<p><code>surface</code> is the surface.</p>
</li>
<li>
<p><code>pModes</code> is a pointer to a value of type
<a href="#VkDeviceGroupPresentModeFlagsKHR">VkDeviceGroupPresentModeFlagsKHR</a> that is filled with the supported
device group present modes for the surface.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The modes returned by this command are not invariant, and <strong class="purple">may</strong> change in
response to the surface being moved, resized, or occluded.
These modes <strong class="purple">must</strong> be a subset of the modes returned by
<a href="#vkGetDeviceGroupPresentCapabilitiesKHR">vkGetDeviceGroupPresentCapabilitiesKHR</a>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetDeviceGroupSurfacePresentModesKHR-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <code>VkDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetDeviceGroupSurfacePresentModesKHR-surface-parameter"></a> <code>surface</code> <strong class="purple">must</strong> be a valid <code>VkSurfaceKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetDeviceGroupSurfacePresentModesKHR-pModes-parameter"></a> <code>pModes</code> <strong class="purple">must</strong> be a valid pointer to a <a href="#VkDeviceGroupPresentModeFlagsKHR">VkDeviceGroupPresentModeFlagsKHR</a> value</p>
</li>
<li>
<p><a id="VUID-vkGetDeviceGroupSurfacePresentModesKHR-commonparent"></a> Both of <code>device</code>, and <code>surface</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>surface</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>When using <code>VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR</code>,
the application <strong class="purple">may</strong> need to know which regions of the surface are used when
presenting locally on each physical device.
Presentation of swapchain images to this surface need only have valid
contents in the regions returned by this command.</p>
</div>
<div class="paragraph">
<p>To query a set of rectangles used in presentation on the physical device,
call:</p>
</div>
<div id="vkGetPhysicalDevicePresentRectanglesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetPhysicalDevicePresentRectanglesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pRectCount,
    VkRect2D*                                   pRects);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>physicalDevice</code> is the physical device.</p>
</li>
<li>
<p><code>surface</code> is the surface.</p>
</li>
<li>
<p><code>pRectCount</code> is a pointer to an integer related to the number of
rectangles available or queried, as described below.</p>
</li>
<li>
<p><code>pRects</code> is either <code>NULL</code> or a pointer to an array of <a href="chap2.html#VkRect2D">VkRect2D</a>
structures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>pRects</code> is <code>NULL</code>, then the number of rectangles used when
presenting the given <code>surface</code> is returned in <code>pRectCount</code>.
Otherwise, <code>pRectCount</code> <strong class="purple">must</strong> point to a variable set by the user to the
number of elements in the <code>pRects</code> array, and on return the variable is
overwritten with the number of structures actually written to <code>pRects</code>.
If the value of <code>pRectCount</code> is less than the number of rectangles, at
most <code>pRectCount</code> structures will be written.
If <code>pRectCount</code> is smaller than the number of rectangles used for the
given <code>surface</code>, <code>VK_INCOMPLETE</code> will be returned instead of
<code>VK_SUCCESS</code> to indicate that not all the available values were
returned.</p>
</div>
<div class="paragraph">
<p>The values returned by this command are not invariant, and <strong class="purple">may</strong> change in
response to the surface being moved, resized, or occluded.</p>
</div>
<div class="paragraph">
<p>The rectangles returned by this command <strong class="purple">must</strong> not overlap.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPhysicalDevicePresentRectanglesKHR-physicalDevice-parameter"></a> <code>physicalDevice</code> <strong class="purple">must</strong> be a valid <code>VkPhysicalDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDevicePresentRectanglesKHR-surface-parameter"></a> <code>surface</code> <strong class="purple">must</strong> be a valid <code>VkSurfaceKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDevicePresentRectanglesKHR-pRectCount-parameter"></a> <code>pRectCount</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDevicePresentRectanglesKHR-pRects-parameter"></a> If the value referenced by <code>pRectCount</code> is not <code>0</code>, and <code>pRects</code> is not <code>NULL</code>, <code>pRects</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pRectCount</code> <code>VkRect2D</code> structures</p>
</li>
<li>
<p><a id="VUID-vkGetPhysicalDevicePresentRectanglesKHR-commonparent"></a> Both of <code>physicalDevice</code>, and <code>surface</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>surface</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_INCOMPLETE</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_display_timing_queries">32.7. Display Timing Queries</h3>
<div class="paragraph">
<p>Traditional game and real-time-animation applications frequently use
<code>VK_PRESENT_MODE_FIFO_KHR</code> so that presentable images are updated during
the vertical blanking period of a given refresh cycle (RC) of the
presentation engine’s display.
This avoids the visual anomaly known as tearing.</p>
</div>
<div class="paragraph">
<p>However, synchronizing the presentation of images with the RC does not
prevent all forms of visual anomalies.
Stuttering occurs when the geometry for each presentable image isn’t
accurately positioned for when that image will be displayed.
The geometry may appear to move too little some RCs, and too much for
others.
Sometimes the animation appears to freeze, when the same image is used for
more than one RC.</p>
</div>
<div class="paragraph">
<p>In order to minimize stuttering, an application needs to correctly position
their geometry for when the presentable image will be displayed to the user.
To accomplish this, applications need various timing information about the
presentation engine’s display.
They need to know when presentable images were actually presented, and when
they could have been presented.
Applications also need to tell the presentation engine to display an image
no sooner than a given time.
This can allow the application’s animation to look smooth to the user, with
no stuttering.
The <code>VK_GOOGLE_display_timing</code> extension allows an application to satisfy
these needs.</p>
</div>
<div class="paragraph">
<p>The presentation engine’s display typically refreshes the pixels that are
displayed to the user on a periodic basis.
The period may be fixed or variable.
In many cases, the presentation engine is associated with fixed refresh rate
(FRR) display technology, with a fixed refresh rate (RR, e.g. 60Hz).
In some cases, the presentation engine is associated with variable refresh
rate (VRR) display technology, where each refresh cycle (RC) can vary in
length.
This extension treats VRR displays as if they are FRR.</p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query the duration of a refresh cycle (RC) for the presentation engine’s
display, call:</p>
</div>
<div id="vkGetRefreshCycleDurationGOOGLE" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetRefreshCycleDurationGOOGLE(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkRefreshCycleDurationGOOGLE*               pDisplayTimingProperties);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the device associated with <code>swapchain</code>.</p>
</li>
<li>
<p><code>swapchain</code> is the swapchain to obtain the refresh duration for.</p>
</li>
<li>
<p><code>pDisplayTimingProperties</code> is a pointer to an instance of the
<code>VkRefreshCycleDurationGOOGLE</code> structure.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetRefreshCycleDurationGOOGLE-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <code>VkDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetRefreshCycleDurationGOOGLE-swapchain-parameter"></a> <code>swapchain</code> <strong class="purple">must</strong> be a valid <code>VkSwapchainKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetRefreshCycleDurationGOOGLE-pDisplayTimingProperties-parameter"></a> <code>pDisplayTimingProperties</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkRefreshCycleDurationGOOGLE</code> structure</p>
</li>
<li>
<p><a id="VUID-vkGetRefreshCycleDurationGOOGLE-commonparent"></a> Both of <code>device</code>, and <code>swapchain</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>swapchain</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_DEVICE_LOST</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkRefreshCycleDurationGOOGLE</code> structure is defined as:</p>
</div>
<div id="VkRefreshCycleDurationGOOGLE" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkRefreshCycleDurationGOOGLE {
    uint64_t    refreshDuration;
} VkRefreshCycleDurationGOOGLE;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>refreshDuration</code> is the number of nanoseconds from the start of one
refresh cycle to the next.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>The rate at which an application renders and presents new images is known as
the image present rate (IPR, aka frame rate).
The inverse of IPR, or the duration between each image present, is the image
present duration (IPD).
In order to provide a smooth, stutter-free animation, an application will
want its IPD to be a multiple of <code>refreshDuration</code>.
For example, if a display has a 60Hz refresh rate, <code>refreshDuration</code>
will be a value in nanoseconds that is approximately equal to 16.67ms.
In such a case, an application will want an IPD of 16.67ms (1X multiplier of
<code>refreshDuration</code>), or 33.33ms (2X multiplier of <code>refreshDuration</code>),
or 50.0ms (3X multiplier of <code>refreshDuration</code>), etc.</p>
</div>
<div class="paragraph">
<p>In order to determine a target IPD for a display (i.e. a multiple of
<code>refreshDuration</code>), an application needs to determine when its images
are actually displayed.
Let’s say that an application has an initial target IPD of 16.67ms (1X
multiplier of <code>refreshDuration</code>).
It will therefore position the geometry of a new image 16.67ms later than
the previous image.
Let’s say that this application is running on slower hardware, so that it
actually takes 20ms to render each new image.
This will create visual anomalies, because the images won’t be displayed to
the user every 16.67ms, nor every 20ms.
In this case, it is better for the application to adjust its target IPD to
33.33ms (i.e. a 2X multiplier of <code>refreshDuration</code>), and tell the
presentation engine to not present images any sooner than every 33.33ms.
This will allow the geometry to be correctly positioned for each presentable
image.</p>
</div>
<div class="paragraph">
<p>Adjustments to an application’s IPD may be needed because different views of
an application’s geometry can take different amounts of time to render.
For example, looking at the sky may take less time to render than looking at
multiple, complex items in a room.
In general, it is good to not frequently change IPD, as that can cause
visual anomalies.
Adjustments to a larger IPD because of late images should happen quickly,
but adjustments to a smaller IPD should only happen if the
<code>actualPresentTime</code> and <code>earliestPresentTime</code> members of the
<a href="#VkPastPresentationTimingGOOGLE">VkPastPresentationTimingGOOGLE</a> structure are consistently different,
and if <code>presentMargin</code> is consistently large, over multiple images.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The implementation will maintain a limited amount of history of timing
information about previous presents.
Because of the asynchronous nature of the presentation engine, the timing
information for a given <a href="#vkQueuePresentKHR">vkQueuePresentKHR</a> command will become
available some time later.
These time values can be asynchronously queried, and will be returned if
available.
All time values are in nanoseconds, relative to a monotonically-increasing
clock (e.g. <code>CLOCK_MONOTONIC</code> (see clock_gettime(2)) on Android and Linux).</p>
</div>
<div class="paragraph">
<p>To asynchronously query the presentation engine, for newly-available timing
information about one or more previous presents to a given swapchain, call:</p>
</div>
<div id="vkGetPastPresentationTimingGOOGLE" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetPastPresentationTimingGOOGLE(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint32_t*                                   pPresentationTimingCount,
    VkPastPresentationTimingGOOGLE*             pPresentationTimings);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the device associated with <code>swapchain</code>.</p>
</li>
<li>
<p><code>swapchain</code> is the swapchain to obtain presentation timing
information duration for.</p>
</li>
<li>
<p><code>pPresentationTimingCount</code> is a pointer to an integer related to the
number of <code>VkPastPresentationTimingGOOGLE</code> structures to query, as
described below.</p>
</li>
<li>
<p><code>pPresentationTimings</code> is either <code>NULL</code> or a pointer to an array of
<code>VkPastPresentationTimingGOOGLE</code> structures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>pPresentationTimings</code> is <code>NULL</code>, then the number of newly-available
timing records for the given <code>swapchain</code> is returned in
<code>pPresentationTimingCount</code>.
Otherwise, <code>pPresentationTimingCount</code> <strong class="purple">must</strong> point to a variable set by
the user to the number of elements in the <code>pPresentationTimings</code> array,
and on return the variable is overwritten with the number of structures
actually written to <code>pPresentationTimings</code>.
If the value of <code>pPresentationTimingCount</code> is less than the number of
newly-available timing records, at most <code>pPresentationTimingCount</code>
structures will be written.
If <code>pPresentationTimingCount</code> is smaller than the number of
newly-available timing records for the given <code>swapchain</code>,
<code>VK_INCOMPLETE</code> will be returned instead of <code>VK_SUCCESS</code> to indicate
that not all the available values were returned.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetPastPresentationTimingGOOGLE-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <code>VkDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPastPresentationTimingGOOGLE-swapchain-parameter"></a> <code>swapchain</code> <strong class="purple">must</strong> be a valid <code>VkSwapchainKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetPastPresentationTimingGOOGLE-pPresentationTimingCount-parameter"></a> <code>pPresentationTimingCount</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetPastPresentationTimingGOOGLE-pPresentationTimings-parameter"></a> If the value referenced by <code>pPresentationTimingCount</code> is not <code>0</code>, and <code>pPresentationTimings</code> is not <code>NULL</code>, <code>pPresentationTimings</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pPresentationTimingCount</code> <code>VkPastPresentationTimingGOOGLE</code> structures</p>
</li>
<li>
<p><a id="VUID-vkGetPastPresentationTimingGOOGLE-commonparent"></a> Both of <code>device</code>, and <code>swapchain</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>swapchain</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_INCOMPLETE</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_DEVICE_LOST</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DATE_KHR</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkPastPresentationTimingGOOGLE</code> structure is defined as:</p>
</div>
<div id="VkPastPresentationTimingGOOGLE" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkPastPresentationTimingGOOGLE {
    uint32_t    presentID;
    uint64_t    desiredPresentTime;
    uint64_t    actualPresentTime;
    uint64_t    earliestPresentTime;
    uint64_t    presentMargin;
} VkPastPresentationTimingGOOGLE;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>presentID</code> is an application-provided value that was given to a
previous <code>vkQueuePresentKHR</code> command via
<a href="#VkPresentTimeGOOGLE">VkPresentTimeGOOGLE</a>::<code>presentID</code> (see below).
It <strong class="purple">can</strong> be used to uniquely identify a previous present with the
<a href="#vkQueuePresentKHR">vkQueuePresentKHR</a> command.</p>
</li>
<li>
<p><code>desiredPresentTime</code> is an application-provided value that was given
to a previous <a href="#vkQueuePresentKHR">vkQueuePresentKHR</a> command via
<a href="#VkPresentTimeGOOGLE">VkPresentTimeGOOGLE</a>::<code>desiredPresentTime</code>.
If non-zero, it was used by the application to indicate that an image
not be presented any sooner than <code>desiredPresentTime</code>.</p>
</li>
<li>
<p><code>actualPresentTime</code> is the time when the image of the
<code>swapchain</code> was actually displayed.</p>
</li>
<li>
<p><code>earliestPresentTime</code> is the time when the image of the
<code>swapchain</code> could have been displayed.
This <strong class="purple">may</strong> differ from <code>actualPresentTime</code> if the application
requested that the image be presented no sooner than
<a href="#VkPresentTimeGOOGLE">VkPresentTimeGOOGLE</a>::<code>desiredPresentTime</code>.</p>
</li>
<li>
<p><code>presentMargin</code> is an indication of how early the
<code>vkQueuePresentKHR</code> command was processed compared to how soon it
needed to be processed, and still be presented at
<code>earliestPresentTime</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The results for a given <code>swapchain</code> and <code>presentID</code> are only
returned once from <code>vkGetPastPresentationTimingGOOGLE</code>.</p>
</div>
<div class="paragraph">
<p>The application <strong class="purple">can</strong> use the <code>VkPastPresentationTimingGOOGLE</code> values to
occasionally adjust its timing.
For example, if <code>actualPresentTime</code> is later than expected (e.g. one
<code>refreshDuration</code> late), the application may increase its target IPD to
a higher multiple of <code>refreshDuration</code> (e.g. decrease its frame rate
from 60Hz to 30Hz).
If <code>actualPresentTime</code> and <code>earliestPresentTime</code> are consistently
different, and if <code>presentMargin</code> is consistently large enough, the
application may decrease its target IPD to a smaller multiple of
<code>refreshDuration</code> (e.g. increase its frame rate from 30Hz to 60Hz).
If <code>actualPresentTime</code> and <code>earliestPresentTime</code> are same, and if
<code>presentMargin</code> is consistently high, the application may delay the
start of its input-render-present loop in order to decrease the latency
between user input and the corresponding present (always leaving some margin
in case a new image takes longer to render than the previous image).
An application that desires its target IPD to always be the same as
<code>refreshDuration</code>, can also adjust features until
<code>actualPresentTime</code> is never late and <code>presentMargin</code> is
satisfactory.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The full <code>VK_GOOGLE_display_timing</code> extension semantics are described for
swapchains created with <code>VK_PRESENT_MODE_FIFO_KHR</code>.
For example, non-zero values of
<code>VkPresentTimeGOOGLE</code>::<code>desiredPresentTime</code> <strong class="purple">must</strong> be honored, and
<code>vkGetPastPresentationTimingGOOGLE</code> <strong class="purple">should</strong> return a
<code>VkPastPresentationTimingGOOGLE</code> structure with valid values for all
images presented with <code>vkQueuePresentKHR</code>.
The semantics for other present modes are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_PRESENT_MODE_IMMEDIATE_KHR</code>.
The presentation engine <strong class="purple">may</strong> ignore non-zero values of
<code>VkPresentTimeGOOGLE</code>::<code>desiredPresentTime</code> in favor of
presenting immediately.
The value of
<code>VkPastPresentationTimingGOOGLE</code>::<code>earliestPresentTime</code> <strong class="purple">must</strong> be
the same as
<code>VkPastPresentationTimingGOOGLE</code>::<code>actualPresentTime</code>, which
<strong class="purple">should</strong> be when the presentation engine displayed the image.</p>
</li>
<li>
<p><code>VK_PRESENT_MODE_MAILBOX_KHR</code>.
The intention of using this present mode with this extension is to
handle cases where an image is presented late, and the next image is
presented soon enough to replace it at the next vertical blanking
period.
For images that are displayed to the user, the value of
<code>VkPastPresentationTimingGOOGLE</code>::<code>actualPresentTime</code> <strong class="purple">must</strong> be
when the image was displayed.
For images that are not displayed to the user,
<code>vkGetPastPresentationTimingGOOGLE</code> <strong class="purple">may</strong> not return a
<code>VkPastPresentationTimingGOOGLE</code> structure, or it <strong class="purple">may</strong> return a
<code>VkPastPresentationTimingGOOGLE</code> structure with the value of zero
for both <code>VkPastPresentationTimingGOOGLE</code>::<code>actualPresentTime</code>
and <code>VkPastPresentationTimingGOOGLE</code>::<code>earliestPresentTime</code>.
It is possible that an application <strong class="purple">can</strong> submit images with
<code>VkPresentTimeGOOGLE</code>::<code>desiredPresentTime</code> values such that new
images <strong class="purple">may</strong> not be displayed.
For example, if <code>VkPresentTimeGOOGLE</code>::<code>desiredPresentTime</code> is
far enough in the future that an image is not presented before
<code>vkQueuePresentKHR</code> is called to present another image, the first
image will not be displayed to the user.
If the application continues to do that, the presentation <strong class="purple">may</strong> not
display new images.</p>
</li>
<li>
<p><code>VK_PRESENT_MODE_FIFO_RELAXED_KHR</code>.
For images that are presented in time to be displayed at the next
vertical blanking period, the semantics are identical as for
<code>VK_PRESENT_MODE_FIFO_RELAXED_KHR</code>.
For images that are presented late, and are displayed after the start of
the vertical blanking period (i.e. with tearing), the values of
<code>VkPastPresentationTimingGOOGLE</code> <strong class="purple">may</strong> be treated as if the image was
displayed at the start of the vertical blanking period, or <strong class="purple">may</strong> be
treated the same as for <code>VK_PRESENT_MODE_IMMEDIATE_KHR</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_wsi_swapchain">32.8. WSI Swapchain</h3>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>A swapchain object (a.k.a.
swapchain) provides the ability to present rendering results to a surface.
Swapchain objects are represented by <code>VkSwapchainKHR</code> handles:</p>
</div>
<div id="VkSwapchainKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSwapchainKHR)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A swapchain is an abstraction for an array of presentable images that are
associated with a surface.
The presentable images are represented by <code>VkImage</code> objects created by
the platform.
One image (which <strong class="purple">can</strong> be an array image for multiview/stereoscopic-3D
surfaces) is displayed at a time, but multiple images <strong class="purple">can</strong> be queued for
presentation.
An application renders to the image, and then queues the image for
presentation to the surface.</p>
</div>
<div class="paragraph">
<p>A native window <strong class="purple">cannot</strong> be associated with more than one non-retired
swapchain at a time.
Further, swapchains <strong class="purple">cannot</strong> be created for native windows that have a
non-Vulkan graphics API surface associated with them.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>The presentation engine is an abstraction for the platform’s compositor or
display engine.</p>
</div>
<div class="paragraph">
<p>The presentation engine <strong class="purple">may</strong> be synchronous or asynchronous with respect to
the application and/or logical device.</p>
</div>
<div class="paragraph">
<p>Some implementations <strong class="purple">may</strong> use the device’s graphics queue or dedicated
presentation hardware to perform presentation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The presentable images of a swapchain are owned by the presentation engine.
An application <strong class="purple">can</strong> acquire use of a presentable image from the presentation
engine.
Use of a presentable image <strong class="purple">must</strong> occur only after the image is returned by
<code>vkAcquireNextImageKHR</code>, and before it is presented by
<code>vkQueuePresentKHR</code>.
This includes transitioning the image layout and rendering commands.</p>
</div>
<div class="paragraph">
<p>An application <strong class="purple">can</strong> acquire use of a presentable image with
<code>vkAcquireNextImageKHR</code>.
After acquiring a presentable image and before modifying it, the application
<strong class="purple">must</strong> use a synchronization primitive to ensure that the presentation engine
has finished reading from the image.
The application <strong class="purple">can</strong> then transition the image’s layout, queue rendering
commands to it, etc.
Finally, the application presents the image with <code>vkQueuePresentKHR</code>,
which releases the acquisition of the image.</p>
</div>
<div class="paragraph">
<p>The presentation engine controls the order in which presentable images are
acquired for use by the application.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>This allows the platform to handle situations which require out-of-order
return of images after presentation.
At the same time, it allows the application to generate command buffers
referencing all of the images in the swapchain at initialization time,
rather than in its main loop.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>How this all works is described below.</p>
</div>
<div class="paragraph">
<p>If a swapchain is created with <code>presentMode</code> set to either
<code>VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR</code> or
<code>VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR</code>, a single presentable
image <strong class="purple">can</strong> be acquired, referred to as a shared presentable image.
A shared presentable image <strong class="purple">may</strong> be concurrently accessed by the application
and the presentation engine, without transitioning the image’s layout after
it is initially presented.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>With <code>VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR</code>, the presentation
engine is only required to update to the latest contents of a shared
presentable image after a present.
The application <strong class="purple">must</strong> call <code>vkQueuePresentKHR</code> to guarantee an
update.
However, the presentation engine <strong class="purple">may</strong> update from it at any time.</p>
</li>
<li>
<p>With <code>VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR</code>, the
presentation engine will automatically present the latest contents of a
shared presentable image during every refresh cycle.
The application is only required to make one initial call to
<code>vkQueuePresentKHR</code>, after which the presentation engine will update
from it without any need for further present calls.
The application <strong class="purple">can</strong> indicate the image contents have been updated by
calling <code>vkQueuePresentKHR</code>, but this does not guarantee the timing
of when updates will occur.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The presentation engine <strong class="purple">may</strong> access a shared presentable image at any time
after it is first presented.
To avoid tearing, an application <strong class="purple">should</strong> coordinate access with the
presentation engine.
This requires presentation engine timing information through
platform-specific mechanisms and ensuring that color attachment writes are
made available during the portion of the presentation engine’s refresh cycle
they are intended for.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>The <code>VK_KHR_shared_presentable_image</code> extension does not provide
functionality for determining the timing of the presentation engine’s
refresh cycles.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>In order to query a swapchain’s status when rendering to a shared
presentable image, call:</p>
</div>
<div id="vkGetSwapchainStatusKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetSwapchainStatusKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the device associated with <code>swapchain</code>.</p>
</li>
<li>
<p><code>swapchain</code> is the swapchain to query.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetSwapchainStatusKHR-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <code>VkDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetSwapchainStatusKHR-swapchain-parameter"></a> <code>swapchain</code> <strong class="purple">must</strong> be a valid <code>VkSwapchainKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetSwapchainStatusKHR-commonparent"></a> Both of <code>device</code>, and <code>swapchain</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>swapchain</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_SUBOPTIMAL_KHR</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_DEVICE_LOST</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DATE_KHR</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The possible return values for <code>vkGetSwapchainStatusKHR</code> <strong class="purple">should</strong> be
interpreted as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code> specifies the presentation engine is presenting the
contents of the shared presentable image, as per the swapchain’s
<a href="#VkPresentModeKHR">VkPresentModeKHR</a>.</p>
</li>
<li>
<p><code>VK_SUBOPTIMAL_KHR</code> the swapchain no longer matches the surface
properties exactly, but the presentation engine is presenting the
contents of the shared presentable image, as per the swapchain’s
<a href="#VkPresentModeKHR">VkPresentModeKHR</a>.</p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DATE_KHR</code> the surface has changed in such a way
that it is no longer compatible with the swapchain.</p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code> the surface is no longer available.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>The swapchain state <strong class="purple">may</strong> be cached by implementations, so applications
<strong class="purple">should</strong> regularly call <code>vkGetSwapchainStatusKHR</code> when using a swapchain
with <a href="#VkPresentModeKHR">VkPresentModeKHR</a> set to
<code>VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create a swapchain, call:</p>
</div>
<div id="vkCreateSwapchainKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateSwapchainKHR(
    VkDevice                                    device,
    <span class="directive">const</span> VkSwapchainCreateInfoKHR*             pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchain);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the device to create the swapchain for.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to an instance of the
<a href="#VkSwapchainCreateInfoKHR">VkSwapchainCreateInfoKHR</a> structure specifying the parameters of
the created swapchain.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
swapchain object when there is no more specific allocator available (see
<a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
<li>
<p><code>pSwapchain</code> is a pointer to a <a href="#VkSwapchainKHR">VkSwapchainKHR</a> handle in which
the created swapchain object will be returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateSwapchainKHR-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <code>VkDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateSwapchainKHR-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkSwapchainCreateInfoKHR</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateSwapchainKHR-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateSwapchainKHR-pSwapchain-parameter"></a> <code>pSwapchain</code> <strong class="purple">must</strong> be a valid pointer to a <code>VkSwapchainKHR</code> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>pCreateInfo.surface</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to <code>pCreateInfo.oldSwapchain</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_DEVICE_LOST</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
<li>
<p><code>VK_ERROR_NATIVE_WINDOW_IN_USE_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkSwapchainCreateInfoKHR</code> structure is defined as:</p>
</div>
<div id="VkSwapchainCreateInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkSwapchainCreateInfoKHR {
    VkStructureType                  sType;
    <span class="directive">const</span> <span class="directive">void</span>*                      pNext;
    VkSwapchainCreateFlagsKHR        flags;
    VkSurfaceKHR                     surface;
    uint32_t                         minImageCount;
    VkFormat                         imageFormat;
    VkColorSpaceKHR                  imageColorSpace;
    VkExtent2D                       imageExtent;
    uint32_t                         imageArrayLayers;
    VkImageUsageFlags                imageUsage;
    VkSharingMode                    imageSharingMode;
    uint32_t                         queueFamilyIndexCount;
    <span class="directive">const</span> uint32_t*                  pQueueFamilyIndices;
    VkSurfaceTransformFlagBitsKHR    preTransform;
    VkCompositeAlphaFlagBitsKHR      compositeAlpha;
    VkPresentModeKHR                 presentMode;
    VkBool32                         clipped;
    VkSwapchainKHR                   oldSwapchain;
} VkSwapchainCreateInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is a bitmask of <a href="#VkSwapchainCreateFlagBitsKHR">VkSwapchainCreateFlagBitsKHR</a>
indicating parameters of the swapchain creation.</p>
</li>
<li>
<p><code>surface</code> is the surface onto which the swapchain will present
images.
If the creation succeeds, the swapchain becomes associated with
<code>surface</code>.</p>
</li>
<li>
<p><code>minImageCount</code> is the minimum number of presentable images that the
application needs.
The implementation will either create the swapchain with at least that
many images, or it will fail to create the swapchain.</p>
</li>
<li>
<p><code>imageFormat</code> is a <a href="chap35.html#VkFormat">VkFormat</a> value specifying the format the
swapchain image(s) will be created with.</p>
</li>
<li>
<p><code>imageColorSpace</code> is a <a href="#VkColorSpaceKHR">VkColorSpaceKHR</a> value specifying the
way the swapchain interprets image data.</p>
</li>
<li>
<p><code>imageExtent</code> is the size (in pixels) of the swapchain image(s).
The behavior is platform-dependent if the image extent does not match
the surface’s <code>currentExtent</code> as returned by
<code>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>On some platforms, it is normal that <code>maxImageExtent</code> <strong class="purple">may</strong> become <code>(0,
0)</code>, for example when the window is minimized.
In such a case, it is not possible to create a swapchain due to the Valid
Usage requirements.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><code>imageArrayLayers</code> is the number of views in a multiview/stereo
surface.
For non-stereoscopic-3D applications, this value is 1.</p>
</li>
<li>
<p><code>imageUsage</code> is a bitmask of <a href="chap11.html#VkImageUsageFlagBits">VkImageUsageFlagBits</a> describing
the intended usage of the (acquired) swapchain images.</p>
</li>
<li>
<p><code>imageSharingMode</code> is the sharing mode used for the image(s) of the
swapchain.</p>
</li>
<li>
<p><code>queueFamilyIndexCount</code> is the number of queue families having
access to the image(s) of the swapchain when <code>imageSharingMode</code> is
<code>VK_SHARING_MODE_CONCURRENT</code>.</p>
</li>
<li>
<p><code>pQueueFamilyIndices</code> is an array of queue family indices having
access to the images(s) of the swapchain when <code>imageSharingMode</code> is
<code>VK_SHARING_MODE_CONCURRENT</code>.</p>
</li>
<li>
<p><code>preTransform</code> is a <a href="#VkSurfaceTransformFlagBitsKHR">VkSurfaceTransformFlagBitsKHR</a> value
describing the transform, relative to the presentation engine’s natural
orientation, applied to the image content prior to presentation.
If it does not match the <code>currentTransform</code> value returned by
<code>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</code>, the presentation engine
will transform the image content as part of the presentation operation.</p>
</li>
<li>
<p><code>compositeAlpha</code> is a <a href="#VkCompositeAlphaFlagBitsKHR">VkCompositeAlphaFlagBitsKHR</a> value
indicating the alpha compositing mode to use when this surface is
composited together with other surfaces on certain window systems.</p>
</li>
<li>
<p><code>presentMode</code> is the presentation mode the swapchain will use.
A swapchain’s present mode determines how incoming present requests will
be processed and queued internally.</p>
</li>
<li>
<p><code>clipped</code> specifies whether the Vulkan implementation is allowed to
discard rendering operations that affect regions of the surface that are
not visible.</p>
<div class="ulist">
<ul>
<li>
<p>If set to <code>VK_TRUE</code>, the presentable images associated with the
swapchain <strong class="purple">may</strong> not own all of their pixels.
Pixels in the presentable images that correspond to regions of the
target surface obscured by another window on the desktop, or subject to
some other clipping mechanism will have undefined content when read
back.
Pixel shaders <strong class="purple">may</strong> not execute for these pixels, and thus any side
effects they would have had will not occur.
<code>VK_TRUE</code> value does not guarantee any clipping will occur, but
allows more optimal presentation methods to be used on some platforms.</p>
</li>
<li>
<p>If set to <code>VK_FALSE</code>, presentable images associated with the
swapchain will own all of the pixels they contain.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Applications <strong class="purple">should</strong> set this value to <code>VK_TRUE</code> if they do not expect
to read back the content of presentable images before presenting them or
after reacquiring them, and if their pixel shaders do not have any side
effects that require them to run for all pixels in the presentable image.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><code>oldSwapchain</code> is <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, or the existing non-retired
swapchain currently associated with <code>surface</code>.
Providing a valid <code>oldSwapchain</code> <strong class="purple">may</strong> aid in the resource reuse, and
also allows the application to still present any images that are already
acquired from it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Upon calling <code>vkCreateSwapchainKHR</code> with an <code>oldSwapchain</code> that is
not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>oldSwapchain</code> is retired — even if creation
of the new swapchain fails.
The new swapchain is created in the non-retired state whether or not
<code>oldSwapchain</code> is <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>.</p>
</div>
<div class="paragraph">
<p>Upon calling <code>vkCreateSwapchainKHR</code> with an <code>oldSwapchain</code> that is
not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, any images from <code>oldSwapchain</code> that are not
acquired by the application <strong class="purple">may</strong> be freed by the implementation, which <strong class="purple">may</strong>
occur even if creation of the new swapchain fails.
The application <strong class="purple">can</strong> destroy <code>oldSwapchain</code> to free all memory
associated with <code>oldSwapchain</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Multiple retired swapchains <strong class="purple">can</strong> be associated with the same
<code>VkSurfaceKHR</code> through multiple uses of <code>oldSwapchain</code> that
outnumber calls to <a href="#vkDestroySwapchainKHR">vkDestroySwapchainKHR</a>.</p>
</div>
<div class="paragraph">
<p>After <code>oldSwapchain</code> is retired, the application <strong class="purple">can</strong> pass to
<a href="#vkQueuePresentKHR">vkQueuePresentKHR</a> any images it had already acquired from
<code>oldSwapchain</code>.
E.g., an application may present an image from the old swapchain before an
image from the new swapchain is ready to be presented.
As usual, <a href="#vkQueuePresentKHR">vkQueuePresentKHR</a> <strong class="purple">may</strong> fail if <code>oldSwapchain</code> has
entered a state that causes <code>VK_ERROR_OUT_OF_DATE_KHR</code> to be returned.</p>
</div>
<div class="paragraph">
<p>The application <strong class="purple">can</strong> continue to use a shared presentable image obtained
from <code>oldSwapchain</code> until a presentable image is acquired from the new
swapchain, as long as it has not entered a state that causes it to return
<code>VK_ERROR_OUT_OF_DATE_KHR</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-surface-01270"></a>
<code>surface</code> <strong class="purple">must</strong> be a surface that is supported by the device as
determined using <code>vkGetPhysicalDeviceSurfaceSupportKHR</code></p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-minImageCount-01271"></a>
<code>minImageCount</code> <strong class="purple">must</strong> be greater than or equal to the value returned
in the <code>minImageCount</code> member of the <code>VkSurfaceCapabilitiesKHR</code>
structure returned by <code>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</code>
for the surface</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-minImageCount-01272"></a>
<code>minImageCount</code> <strong class="purple">must</strong> be less than or equal to the value returned in
the <code>maxImageCount</code> member of the <code>VkSurfaceCapabilitiesKHR</code>
structure returned by <code>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</code>
for the surface if the returned <code>maxImageCount</code> is not zero</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-minImageCount-01383"></a>
<code>minImageCount</code> <strong class="purple">must</strong> be <code>1</code> if <code>presentMode</code> is either
<code>VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR</code> or
<code>VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-imageFormat-01273"></a>
<code>imageFormat</code> and <code>imageColorSpace</code> <strong class="purple">must</strong> match the <code>format</code>
and <code>colorSpace</code> members, respectively, of one of the
<code>VkSurfaceFormatKHR</code> structures returned by
<code>vkGetPhysicalDeviceSurfaceFormatsKHR</code> for the surface</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-imageExtent-01274"></a>
<code>imageExtent</code> <strong class="purple">must</strong> be between <code>minImageExtent</code> and
<code>maxImageExtent</code>, inclusive, where <code>minImageExtent</code> and
<code>maxImageExtent</code> are members of the <code>VkSurfaceCapabilitiesKHR</code>
structure returned by <code>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</code>
for the surface</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-imageExtent-01689"></a>
<code>imageExtent</code> members <code>width</code> and <code>height</code> <strong class="purple">must</strong> both be
non-zero</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-imageArrayLayers-01275"></a>
<code>imageArrayLayers</code> <strong class="purple">must</strong> be greater than <code>0</code> and less than or equal
to the <code>maxImageArrayLayers</code> member of the
<code>VkSurfaceCapabilitiesKHR</code> structure returned by
<code>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</code> for the surface</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-presentMode-01427"></a>
If <code>presentMode</code> is <code>VK_PRESENT_MODE_IMMEDIATE_KHR</code>,
<code>VK_PRESENT_MODE_MAILBOX_KHR</code>, <code>VK_PRESENT_MODE_FIFO_KHR</code> or
<code>VK_PRESENT_MODE_FIFO_RELAXED_KHR</code>, <code>imageUsage</code> <strong class="purple">must</strong> be a
subset of the supported usage flags present in the
<code>supportedUsageFlags</code> member of the <a href="#VkSurfaceCapabilitiesKHR">VkSurfaceCapabilitiesKHR</a>
structure returned by <a href="#vkGetPhysicalDeviceSurfaceCapabilitiesKHR">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</a>
for <code>surface</code></p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-imageUsage-01384"></a>
If <code>presentMode</code> is <code>VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR</code>
or <code>VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR</code>, <code>imageUsage</code>
<strong class="purple">must</strong> be a subset of the supported usage flags present in the
<code>sharedPresentSupportedUsageFlags</code> member of the
<a href="#VkSharedPresentSurfaceCapabilitiesKHR">VkSharedPresentSurfaceCapabilitiesKHR</a> structure returned by
<a href="#vkGetPhysicalDeviceSurfaceCapabilities2KHR">vkGetPhysicalDeviceSurfaceCapabilities2KHR</a> for <code>surface</code></p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01277"></a>
If <code>imageSharingMode</code> is <code>VK_SHARING_MODE_CONCURRENT</code>,
<code>pQueueFamilyIndices</code> <strong class="purple">must</strong> be a valid pointer to an array of
<code>queueFamilyIndexCount</code> <code>uint32_t</code> values</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01278"></a>
If <code>imageSharingMode</code> is <code>VK_SHARING_MODE_CONCURRENT</code>,
<code>queueFamilyIndexCount</code> <strong class="purple">must</strong> be greater than <code>1</code></p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01428"></a>
If <code>imageSharingMode</code> is <code>VK_SHARING_MODE_CONCURRENT</code>, each
element of <code>pQueueFamilyIndices</code> <strong class="purple">must</strong> be unique and <strong class="purple">must</strong> be less
than <code>pQueueFamilyPropertyCount</code> returned by either
<a href="chap4.html#vkGetPhysicalDeviceQueueFamilyProperties">vkGetPhysicalDeviceQueueFamilyProperties</a> or
<a href="#vkGetPhysicalDeviceQueueFamilyProperties2">vkGetPhysicalDeviceQueueFamilyProperties2</a> for the
<code>physicalDevice</code> that was used to create <code>device</code></p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-preTransform-01279"></a>
<code>preTransform</code> <strong class="purple">must</strong> be one of the bits present in the
<code>supportedTransforms</code> member of the <code>VkSurfaceCapabilitiesKHR</code>
structure returned by <code>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</code>
for the surface</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-compositeAlpha-01280"></a>
<code>compositeAlpha</code> <strong class="purple">must</strong> be one of the bits present in the
<code>supportedCompositeAlpha</code> member of the
<code>VkSurfaceCapabilitiesKHR</code> structure returned by
<code>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</code> for the surface</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-presentMode-01281"></a>
<code>presentMode</code> <strong class="purple">must</strong> be one of the <a href="#VkPresentModeKHR">VkPresentModeKHR</a> values
returned by <code>vkGetPhysicalDeviceSurfacePresentModesKHR</code> for the
surface</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-physicalDeviceCount-01429"></a>
If the logical device was created with
<a href="chap4.html#VkDeviceGroupDeviceCreateInfo">VkDeviceGroupDeviceCreateInfo</a>::<code>physicalDeviceCount</code> equal to
1, <code>flags</code> <strong class="purple">must</strong> not contain
<code>VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-oldSwapchain-01933"></a>
If <code>oldSwapchain</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>oldSwapchain</code>
<strong class="purple">must</strong> be a non-retired swapchain associated with native window referred
to by <code>surface</code></p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-imageFormat-01778"></a>
The <a href="#swapchain-wsi-image-create-info">implied image creation
parameters</a> of the swapchain <strong class="purple">must</strong> be supported as reported by
<a href="chap35.html#vkGetPhysicalDeviceImageFormatProperties">vkGetPhysicalDeviceImageFormatProperties</a></p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-flags-03168"></a>
If <code>flags</code> contains <code>VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR</code>
then the <code>pNext</code> chain <strong class="purple">must</strong> contain an instance of
<a href="chap11.html#VkImageFormatListCreateInfoKHR">VkImageFormatListCreateInfoKHR</a> with a <code>viewFormatCount</code>
greater than zero and <code>pViewFormats</code> <strong class="purple">must</strong> have an element equal to
<code>imageFormat</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-pNext-pNext"></a> Each <code>pNext</code> member of any structure (including this one) in the <code>pNext</code> chain <strong class="purple">must</strong> be either <code>NULL</code> or a pointer to a valid instance of <a href="#VkDeviceGroupSwapchainCreateInfoKHR">VkDeviceGroupSwapchainCreateInfoKHR</a>, <a href="chap11.html#VkImageFormatListCreateInfoKHR">VkImageFormatListCreateInfoKHR</a>, or <a href="#VkSwapchainCounterCreateInfoEXT">VkSwapchainCounterCreateInfoEXT</a></p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-sType-unique"></a> Each <code>sType</code> member in the <code>pNext</code> chain <strong class="purple">must</strong> be unique</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-flags-parameter"></a> <code>flags</code> <strong class="purple">must</strong> be a valid combination of <a href="#VkSwapchainCreateFlagBitsKHR">VkSwapchainCreateFlagBitsKHR</a> values</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-surface-parameter"></a> <code>surface</code> <strong class="purple">must</strong> be a valid <code>VkSurfaceKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-imageFormat-parameter"></a> <code>imageFormat</code> <strong class="purple">must</strong> be a valid <a href="chap35.html#VkFormat">VkFormat</a> value</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-imageColorSpace-parameter"></a> <code>imageColorSpace</code> <strong class="purple">must</strong> be a valid <a href="#VkColorSpaceKHR">VkColorSpaceKHR</a> value</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-imageUsage-parameter"></a> <code>imageUsage</code> <strong class="purple">must</strong> be a valid combination of <a href="chap11.html#VkImageUsageFlagBits">VkImageUsageFlagBits</a> values</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-imageUsage-requiredbitmask"></a> <code>imageUsage</code> <strong class="purple">must</strong> not be <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-imageSharingMode-parameter"></a> <code>imageSharingMode</code> <strong class="purple">must</strong> be a valid <a href="chap11.html#VkSharingMode">VkSharingMode</a> value</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-preTransform-parameter"></a> <code>preTransform</code> <strong class="purple">must</strong> be a valid <a href="#VkSurfaceTransformFlagBitsKHR">VkSurfaceTransformFlagBitsKHR</a> value</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter"></a> <code>compositeAlpha</code> <strong class="purple">must</strong> be a valid <a href="#VkCompositeAlphaFlagBitsKHR">VkCompositeAlphaFlagBitsKHR</a> value</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-presentMode-parameter"></a> <code>presentMode</code> <strong class="purple">must</strong> be a valid <a href="#VkPresentModeKHR">VkPresentModeKHR</a> value</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-oldSwapchain-parameter"></a> If <code>oldSwapchain</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>oldSwapchain</code> <strong class="purple">must</strong> be a valid <code>VkSwapchainKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-oldSwapchain-parent"></a> If <code>oldSwapchain</code> is a valid handle, it <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>surface</code></p>
</li>
<li>
<p><a id="VUID-VkSwapchainCreateInfoKHR-commonparent"></a> Both of <code>oldSwapchain</code>, and <code>surface</code> that are valid handles <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Bits which <strong class="purple">can</strong> be set in <a href="#VkSwapchainCreateInfoKHR">VkSwapchainCreateInfoKHR</a>::<code>flags</code>,
specifying parameters of swapchain creation, are:</p>
</div>
<div id="VkSwapchainCreateFlagBitsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">enum</span> VkSwapchainCreateFlagBitsKHR {
    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = <span class="hex">0x00000001</span>,
    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = <span class="hex">0x00000002</span>,
    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = <span class="hex">0x00000004</span>,
} VkSwapchainCreateFlagBitsKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR</code> specifies
that images created from the swapchain (i.e. with the <code>swapchain</code>
member of <a href="chap11.html#VkImageSwapchainCreateInfoKHR">VkImageSwapchainCreateInfoKHR</a> set to this swapchain’s
handle) <strong class="purple">must</strong> use <code>VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT</code>.</p>
</li>
<li>
<p><code>VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR</code> specifies that the
images of the swapchain <strong class="purple">can</strong> be used to create a <code>VkImageView</code> with
a different format than what the swapchain was created with.
The list of allowed image view formats are specified by chaining an
instance of the <a href="chap11.html#VkImageFormatListCreateInfoKHR">VkImageFormatListCreateInfoKHR</a> structure to the
<code>pNext</code> chain of <code>VkSwapchainCreateInfoKHR</code>.
In addition, this flag also specifies that the swapchain <strong class="purple">can</strong> be created
with usage flags that are not supported for the format the swapchain is
created with but are supported for at least one of the allowed image
view formats.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkSwapchainCreateFlagsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkFlags VkSwapchainCreateFlagsKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkSwapchainCreateFlagsKHR</code> is a bitmask type for setting a mask of zero
or more <a href="#VkSwapchainCreateFlagBitsKHR">VkSwapchainCreateFlagBitsKHR</a>.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>If the <code>pNext</code> chain of <a href="#VkSwapchainCreateInfoKHR">VkSwapchainCreateInfoKHR</a> includes a
<code>VkDeviceGroupSwapchainCreateInfoKHR</code> structure, then that structure
includes a set of device group present modes that the swapchain <strong class="purple">can</strong> be used
with.</p>
</div>
<div class="paragraph">
<p>The <code>VkDeviceGroupSwapchainCreateInfoKHR</code> structure is defined as:</p>
</div>
<div id="VkDeviceGroupSwapchainCreateInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDeviceGroupSwapchainCreateInfoKHR {
    VkStructureType                     sType;
    <span class="directive">const</span> <span class="directive">void</span>*                         pNext;
    VkDeviceGroupPresentModeFlagsKHR    modes;
} VkDeviceGroupSwapchainCreateInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>modes</code> is a bitfield of modes that the swapchain <strong class="purple">can</strong> be used with.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If this structure is not present, <code>modes</code> is considered to be
<code>VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDeviceGroupSwapchainCreateInfoKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkDeviceGroupSwapchainCreateInfoKHR-modes-parameter"></a> <code>modes</code> <strong class="purple">must</strong> be a valid combination of <a href="#VkDeviceGroupPresentModeFlagBitsKHR">VkDeviceGroupPresentModeFlagBitsKHR</a> values</p>
</li>
<li>
<p><a id="VUID-VkDeviceGroupSwapchainCreateInfoKHR-modes-requiredbitmask"></a> <code>modes</code> <strong class="purple">must</strong> not be <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To enable surface counters when creating a swapchain, add
<code>VkSwapchainCounterCreateInfoEXT</code> to the <code>pNext</code> chain of
<a href="#VkSwapchainCreateInfoKHR">VkSwapchainCreateInfoKHR</a>.
<code>VkSwapchainCounterCreateInfoEXT</code> is defined as:</p>
</div>
<div id="VkSwapchainCounterCreateInfoEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkSwapchainCounterCreateInfoEXT {
    VkStructureType             sType;
    <span class="directive">const</span> <span class="directive">void</span>*                 pNext;
    VkSurfaceCounterFlagsEXT    surfaceCounters;
} VkSwapchainCounterCreateInfoEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>surfaceCounters</code> is a bitmask of <a href="#VkSurfaceCounterFlagBitsEXT">VkSurfaceCounterFlagBitsEXT</a>
specifying surface counters to enable for the swapchain.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkSwapchainCounterCreateInfoEXT-surfaceCounters-01244"></a>
The bits in <code>surfaceCounters</code> <strong class="purple">must</strong> be supported by
<a href="#VkSwapchainCreateInfoKHR">VkSwapchainCreateInfoKHR</a>::<code>surface</code>, as reported by
<a href="#vkGetPhysicalDeviceSurfaceCapabilities2EXT">vkGetPhysicalDeviceSurfaceCapabilities2EXT</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkSwapchainCounterCreateInfoEXT-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT</code></p>
</li>
<li>
<p><a id="VUID-VkSwapchainCounterCreateInfoEXT-surfaceCounters-parameter"></a> <code>surfaceCounters</code> <strong class="purple">must</strong> be a valid combination of <a href="#VkSurfaceCounterFlagBitsEXT">VkSurfaceCounterFlagBitsEXT</a> values</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The requested counters become active when the first presentation command for
the associated swapchain is processed by the presentation engine.
To query the value of an active counter, use:</p>
</div>
<div id="vkGetSwapchainCounterEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetSwapchainCounterEXT(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkSurfaceCounterFlagBitsEXT                 counter,
    uint64_t*                                   pCounterValue);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the <a href="chap4.html#VkDevice">VkDevice</a> associated with <code>swapchain</code>.</p>
</li>
<li>
<p><code>swapchain</code> is the swapchain from which to query the counter value.</p>
</li>
<li>
<p><code>counter</code> is the counter to query.</p>
</li>
<li>
<p><code>pCounterValue</code> will return the current value of the counter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a counter is not available because the swapchain is out of date, the
implementation <strong class="purple">may</strong> return <code>VK_ERROR_OUT_OF_DATE_KHR</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetSwapchainCounterEXT-swapchain-01245"></a>
One or more present commands on <code>swapchain</code> <strong class="purple">must</strong> have been
processed by the presentation engine.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetSwapchainCounterEXT-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <code>VkDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetSwapchainCounterEXT-swapchain-parameter"></a> <code>swapchain</code> <strong class="purple">must</strong> be a valid <code>VkSwapchainKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetSwapchainCounterEXT-counter-parameter"></a> <code>counter</code> <strong class="purple">must</strong> be a valid <a href="#VkSurfaceCounterFlagBitsEXT">VkSurfaceCounterFlagBitsEXT</a> value</p>
</li>
<li>
<p><a id="VUID-vkGetSwapchainCounterEXT-pCounterValue-parameter"></a> <code>pCounterValue</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint64_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetSwapchainCounterEXT-commonparent"></a> Both of <code>device</code>, and <code>swapchain</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_DEVICE_LOST</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DATE_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As mentioned above, if <code>vkCreateSwapchainKHR</code> succeeds, it will return a
handle to a swapchain that contains an array of at least <code>minImageCount</code>
presentable images.</p>
</div>
<div class="paragraph">
<p>While acquired by the application, presentable images <strong class="purple">can</strong> be used in any
way that equivalent non-presentable images <strong class="purple">can</strong> be used.
A presentable image is equivalent to a non-presentable image created with
the following <code>VkImageCreateInfo</code> parameters:</p>
</div>
<table id="swapchain-wsi-image-create-info" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>VkImageCreateInfo</code> Field</th>
<th class="tableblock halign-left valign-top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flags</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT</code> is set if
<code>VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR</code> is set</p>
<p class="tableblock"><code>VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT</code> and
<code>VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR</code> are both set if
<code>VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR</code> is set</p>
<p class="tableblock">all other bits are unset</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>imageType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_IMAGE_TYPE_2D</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>format</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pCreateInfo→imageFormat</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>extent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{pCreateInfo→imageExtent.width, pCreateInfo→imageExtent.height, 1}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mipLevels</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>arrayLayers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pCreateInfo→imageArrayLayers</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>samples</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_SAMPLE_COUNT_1_BIT</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tiling</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_IMAGE_TILING_OPTIMAL</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pCreateInfo→imageUsage</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sharingMode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pCreateInfo→imageSharingMode</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>queueFamilyIndexCount</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pCreateInfo→queueFamilyIndexCount</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pQueueFamilyIndices</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pCreateInfo→pQueueFamilyIndices</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>initialLayout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_IMAGE_LAYOUT_UNDEFINED</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>surface</code> <strong class="purple">must</strong> not be destroyed until after the swapchain is
destroyed.</p>
</div>
<div class="paragraph">
<p>If <code>oldSwapchain</code> is <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, and the native window
referred to by <code>surface</code> is already associated with a Vulkan swapchain,
<code>VK_ERROR_NATIVE_WINDOW_IN_USE_KHR</code> <strong class="purple">must</strong> be returned.</p>
</div>
<div class="paragraph">
<p>If the native window referred to by <code>surface</code> is already associated with
a non-Vulkan graphics API surface, <code>VK_ERROR_NATIVE_WINDOW_IN_USE_KHR</code>
<strong class="purple">must</strong> be returned.</p>
</div>
<div class="paragraph">
<p>The native window referred to by <code>surface</code> <strong class="purple">must</strong> not become associated
with a non-Vulkan graphics API surface before all associated Vulkan
swapchains have been destroyed.</p>
</div>
<div class="paragraph">
<p>Like core functions, several WSI functions, including
<code>vkCreateSwapchainKHR</code> return <code>VK_ERROR_DEVICE_LOST</code> if the logical
device was lost.
See <a href="chap4.html#devsandqueues-lost-device">Lost Device</a>.
As with most core objects, <code>VkSwapchainKHR</code> is a child of the device and
is affected by the lost state; it <strong class="purple">must</strong> be destroyed before destroying the
<code>VkDevice</code>.
However, <code>VkSurfaceKHR</code> is not a child of any <code>VkDevice</code> and is not
otherwise affected by the lost device.
After successfully recreating a <code>VkDevice</code>, the same <code>VkSurfaceKHR</code>
<strong class="purple">can</strong> be used to create a new <code>VkSwapchainKHR</code>, provided the previous one
was destroyed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>As mentioned in <a href="chap4.html#devsandqueues-lost-device">Lost Device</a>, after a lost
device event, the <code>VkPhysicalDevice</code> <strong class="purple">may</strong> also be lost.
If other <code>VkPhysicalDevice</code> are available, they <strong class="purple">can</strong> be used together
with the same <code>VkSurfaceKHR</code> to create the new <code>VkSwapchainKHR</code>,
however the application <strong class="purple">must</strong> query the surface capabilities again, because
they <strong class="purple">may</strong> differ on a per-physical device basis.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To destroy a swapchain object call:</p>
</div>
<div id="vkDestroySwapchainKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> vkDestroySwapchainKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the <a href="chap4.html#VkDevice">VkDevice</a> associated with <code>swapchain</code>.</p>
</li>
<li>
<p><code>swapchain</code> is the swapchain to destroy.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
swapchain object when there is no more specific allocator available (see
<a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The application <strong class="purple">must</strong> not destroy a swapchain until after completion of all
outstanding operations on images that were acquired from the swapchain.
<code>swapchain</code> and all associated <code>VkImage</code> handles are destroyed, and
<strong class="purple">must</strong> not be acquired or used any more by the application.
The memory of each <code>VkImage</code> will only be freed after that image is no
longer used by the presentation engine.
For example, if one image of the swapchain is being displayed in a window,
the memory for that image <strong class="purple">may</strong> not be freed until the window is destroyed,
or another swapchain is created for the window.
Destroying the swapchain does not invalidate the parent <code>VkSurfaceKHR</code>,
and a new swapchain <strong class="purple">can</strong> be created with it.</p>
</div>
<div class="paragraph">
<p>When a swapchain associated with a display surface is destroyed, if the
image most recently presented to the display surface is from the swapchain
being destroyed, then either any display resources modified by presenting
images from any swapchain associated with the display surface <strong class="purple">must</strong> be
reverted by the implementation to their state prior to the first present
performed on one of these swapchains, or such resources <strong class="purple">must</strong> be left in
their current state.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroySwapchainKHR-swapchain-01282"></a>
All uses of presentable images acquired from <code>swapchain</code> <strong class="purple">must</strong> have
completed execution</p>
</li>
<li>
<p><a id="VUID-vkDestroySwapchainKHR-swapchain-01283"></a>
If <code>VkAllocationCallbacks</code> were provided when <code>swapchain</code> was
created, a compatible set of callbacks <strong class="purple">must</strong> be provided here</p>
</li>
<li>
<p><a id="VUID-vkDestroySwapchainKHR-swapchain-01284"></a>
If no <code>VkAllocationCallbacks</code> were provided when <code>swapchain</code> was
created, <code>pAllocator</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroySwapchainKHR-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <code>VkDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroySwapchainKHR-swapchain-parameter"></a> If <code>swapchain</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>swapchain</code> <strong class="purple">must</strong> be a valid <code>VkSwapchainKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroySwapchainKHR-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkDestroySwapchainKHR-commonparent"></a> Both of <code>device</code>, and <code>swapchain</code> that are valid handles <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>swapchain</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="create_shared_swapchains" class="openblock">
<div class="content">
<div class="paragraph">
<p>When the <code>VK_KHR_display_swapchain</code> extension is enabled, multiple
swapchains that share presentable images are created by calling:</p>
</div>
<div id="vkCreateSharedSwapchainsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateSharedSwapchainsKHR(
    VkDevice                                    device,
    uint32_t                                    swapchainCount,
    <span class="directive">const</span> VkSwapchainCreateInfoKHR*             pCreateInfos,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchains);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the device to create the swapchains for.</p>
</li>
<li>
<p><code>swapchainCount</code> is the number of swapchains to create.</p>
</li>
<li>
<p><code>pCreateInfos</code> is a pointer to an array of
<a href="#VkSwapchainCreateInfoKHR">VkSwapchainCreateInfoKHR</a> structures specifying the parameters of
the created swapchains.</p>
</li>
<li>
<p><code>pAllocator</code> is the allocator used for host memory allocated for the
swapchain objects when there is no more specific allocator available
(see <a href="chap10.html#memory-allocation">Memory Allocation</a>).</p>
</li>
<li>
<p><code>pSwapchains</code> is a pointer to an array of <a href="#VkSwapchainKHR">VkSwapchainKHR</a>
handles in which the created swapchain objects will be returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>vkCreateSharedSwapchainsKHR</code> is similar to <a href="#vkCreateSwapchainKHR">vkCreateSwapchainKHR</a>,
except that it takes an array of <a href="#VkSwapchainCreateInfoKHR">VkSwapchainCreateInfoKHR</a> structures,
and returns an array of swapchain objects.</p>
</div>
<div class="paragraph">
<p>The swapchain creation parameters that affect the properties and number of
presentable images <strong class="purple">must</strong> match between all the swapchains.
If the displays used by any of the swapchains do not use the same
presentable image layout or are incompatible in a way that prevents sharing
images, swapchain creation will fail with the result code
<code>VK_ERROR_INCOMPATIBLE_DISPLAY_KHR</code>.
If any error occurs, no swapchains will be created.
Images presented to multiple swapchains <strong class="purple">must</strong> be re-acquired from all of
them before transitioning away from <code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code>.
After destroying one or more of the swapchains, the remaining swapchains and
the presentable images <strong class="purple">can</strong> continue to be used.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateSharedSwapchainsKHR-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <code>VkDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateSharedSwapchainsKHR-pCreateInfos-parameter"></a> <code>pCreateInfos</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>swapchainCount</code> valid <code>VkSwapchainCreateInfoKHR</code> structures</p>
</li>
<li>
<p><a id="VUID-vkCreateSharedSwapchainsKHR-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAllocationCallbacks</code> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateSharedSwapchainsKHR-pSwapchains-parameter"></a> <code>pSwapchains</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>swapchainCount</code> <code>VkSwapchainKHR</code> handles</p>
</li>
<li>
<p><a id="VUID-vkCreateSharedSwapchainsKHR-swapchainCount-arraylength"></a> <code>swapchainCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>pCreateInfos</code>[].surface <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to <code>pCreateInfos</code>[].oldSwapchain <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_INCOMPATIBLE_DISPLAY_KHR</code></p>
</li>
<li>
<p><code>VK_ERROR_DEVICE_LOST</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To obtain the array of presentable images associated with a swapchain, call:</p>
</div>
<div id="vkGetSwapchainImagesKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkGetSwapchainImagesKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint32_t*                                   pSwapchainImageCount,
    VkImage*                                    pSwapchainImages);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the device associated with <code>swapchain</code>.</p>
</li>
<li>
<p><code>swapchain</code> is the swapchain to query.</p>
</li>
<li>
<p><code>pSwapchainImageCount</code> is a pointer to an integer related to the
number of presentable images available or queried, as described below.</p>
</li>
<li>
<p><code>pSwapchainImages</code> is either <code>NULL</code> or a pointer to an array of
<code>VkImage</code> handles.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>pSwapchainImages</code> is <code>NULL</code>, then the number of presentable images
for <code>swapchain</code> is returned in <code>pSwapchainImageCount</code>.
Otherwise, <code>pSwapchainImageCount</code> <strong class="purple">must</strong> point to a variable set by the
user to the number of elements in the <code>pSwapchainImages</code> array, and on
return the variable is overwritten with the number of structures actually
written to <code>pSwapchainImages</code>.
If the value of <code>pSwapchainImageCount</code> is less than the number of
presentable images for <code>swapchain</code>, at most <code>pSwapchainImageCount</code>
structures will be written.
If <code>pSwapchainImageCount</code> is smaller than the number of presentable
images for <code>swapchain</code>, <code>VK_INCOMPLETE</code> will be returned instead of
<code>VK_SUCCESS</code> to indicate that not all the available values were
returned.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetSwapchainImagesKHR-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <code>VkDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetSwapchainImagesKHR-swapchain-parameter"></a> <code>swapchain</code> <strong class="purple">must</strong> be a valid <code>VkSwapchainKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkGetSwapchainImagesKHR-pSwapchainImageCount-parameter"></a> <code>pSwapchainImageCount</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkGetSwapchainImagesKHR-pSwapchainImages-parameter"></a> If the value referenced by <code>pSwapchainImageCount</code> is not <code>0</code>, and <code>pSwapchainImages</code> is not <code>NULL</code>, <code>pSwapchainImages</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pSwapchainImageCount</code> <code>VkImage</code> handles</p>
</li>
<li>
<p><a id="VUID-vkGetSwapchainImagesKHR-commonparent"></a> Both of <code>device</code>, and <code>swapchain</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_INCOMPLETE</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>By knowing all presentable images used in the swapchain, the application
<strong class="purple">can</strong> create command buffers that reference these images prior to entering
its main rendering loop.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The implementation will have already allocated and bound the memory backing
the <code>VkImage</code> objects returned by <code>vkGetSwapchainImagesKHR</code>.
The memory for each image will not alias with the memory for other images or
with any <code>VkDeviceMemory</code> object.
As such, performing any operation affecting the binding of memory to a
presentable image results in undefined behavior.
All presentable images are initially in the <code>VK_IMAGE_LAYOUT_UNDEFINED</code>
layout, thus before using presentable images, the application <strong class="purple">must</strong>
transition them to a valid layout for the intended use.</p>
</div>
<div class="paragraph">
<p>Further, the lifetime of presentable images is controlled by the
implementation so destroying a presentable image with <a href="chap11.html#vkDestroyImage">vkDestroyImage</a>
results in undefined behavior.
See <a href="#vkDestroySwapchainKHR">vkDestroySwapchainKHR</a> for further details on the lifetime of
presentable images.</p>
</div>
<div class="paragraph">
<p>Images <strong class="purple">can</strong> also be created by using <a href="chap11.html#vkCreateImage">vkCreateImage</a> with
<a href="chap11.html#VkImageSwapchainCreateInfoKHR">VkImageSwapchainCreateInfoKHR</a> and bound to swapchain memory using
<a href="chap11.html#vkBindImageMemory2KHR">vkBindImageMemory2KHR</a> with <a href="chap11.html#VkBindImageMemorySwapchainInfoKHR">VkBindImageMemorySwapchainInfoKHR</a>.
These images <strong class="purple">can</strong> be used anywhere swapchain images are used, and are useful
in logical devices with multiple physical devices to create peer memory
bindings of swapchain memory.
These images and bindings have no effect on what memory is presented.
Unlike images retrieved from <code>vkGetSwapchainImagesKHR</code>, these images
<strong class="purple">must</strong> be destroyed with <a href="chap11.html#vkDestroyImage">vkDestroyImage</a>.</p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To acquire an available presentable image to use, and retrieve the index of
that image, call:</p>
</div>
<div id="vkAcquireNextImageKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkAcquireNextImageKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint64_t                                    timeout,
    VkSemaphore                                 semaphore,
    VkFence                                     fence,
    uint32_t*                                   pImageIndex);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the device associated with <code>swapchain</code>.</p>
</li>
<li>
<p><code>swapchain</code> is the non-retired swapchain from which an image is
being acquired.</p>
</li>
<li>
<p><code>timeout</code> specifies how long the function waits, in nanoseconds, if
no image is available.</p>
</li>
<li>
<p><code>semaphore</code> is <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> or a semaphore to signal.</p>
</li>
<li>
<p><code>fence</code> is <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> or a fence to signal.</p>
</li>
<li>
<p><code>pImageIndex</code> is a pointer to a <code>uint32_t</code> that is set to the
index of the next image to use (i.e. an index into the array of images
returned by <code>vkGetSwapchainImagesKHR</code>).</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkAcquireNextImageKHR-swapchain-01285"></a>
<code>swapchain</code> <strong class="purple">must</strong> not be in the retired state</p>
</li>
<li>
<p><a id="VUID-vkAcquireNextImageKHR-semaphore-01286"></a>
If <code>semaphore</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> it <strong class="purple">must</strong> be unsignaled</p>
</li>
<li>
<p><a id="VUID-vkAcquireNextImageKHR-semaphore-01779"></a>
If <code>semaphore</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> it <strong class="purple">must</strong> not have any
uncompleted signal or wait operations pending</p>
</li>
<li>
<p><a id="VUID-vkAcquireNextImageKHR-fence-01287"></a>
If <code>fence</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> it <strong class="purple">must</strong> be unsignaled and
<strong class="purple">must</strong> not be associated with any other queue command that has not yet
completed execution on that queue</p>
</li>
<li>
<p><a id="VUID-vkAcquireNextImageKHR-semaphore-01780"></a>
<code>semaphore</code> and <code>fence</code> <strong class="purple">must</strong> not both be equal to
<a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a></p>
</li>
<li>
<p><a id="VUID-vkAcquireNextImageKHR-swapchain-01802"></a>
If the number of currently acquired images is greater than the
difference between the number of images in <code>swapchain</code> and the value
of <a href="#VkSurfaceCapabilitiesKHR">VkSurfaceCapabilitiesKHR</a>::<code>minImageCount</code> as returned by a
call to <a href="#vkGetPhysicalDeviceSurfaceCapabilities2KHR">vkGetPhysicalDeviceSurfaceCapabilities2KHR</a> with the
<code>surface</code> used to create <code>swapchain</code>, <code>timeout</code> <strong class="purple">must</strong> not be
<code>UINT64_MAX</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkAcquireNextImageKHR-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <code>VkDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkAcquireNextImageKHR-swapchain-parameter"></a> <code>swapchain</code> <strong class="purple">must</strong> be a valid <code>VkSwapchainKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-vkAcquireNextImageKHR-semaphore-parameter"></a> If <code>semaphore</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>semaphore</code> <strong class="purple">must</strong> be a valid <code>VkSemaphore</code> handle</p>
</li>
<li>
<p><a id="VUID-vkAcquireNextImageKHR-fence-parameter"></a> If <code>fence</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>fence</code> <strong class="purple">must</strong> be a valid <code>VkFence</code> handle</p>
</li>
<li>
<p><a id="VUID-vkAcquireNextImageKHR-pImageIndex-parameter"></a> <code>pImageIndex</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
<li>
<p><a id="VUID-vkAcquireNextImageKHR-semaphore-parent"></a> If <code>semaphore</code> is a valid handle, it <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
<li>
<p><a id="VUID-vkAcquireNextImageKHR-fence-parent"></a> If <code>fence</code> is a valid handle, it <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
<li>
<p><a id="VUID-vkAcquireNextImageKHR-commonparent"></a> Both of <code>device</code>, and <code>swapchain</code> that are valid handles <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>swapchain</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to <code>semaphore</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to <code>fence</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_TIMEOUT</code></p>
</li>
<li>
<p><code>VK_NOT_READY</code></p>
</li>
<li>
<p><code>VK_SUBOPTIMAL_KHR</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_DEVICE_LOST</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DATE_KHR</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When successful, <code>vkAcquireNextImageKHR</code> acquires a presentable image
from <code>swapchain</code> that an application <strong class="purple">can</strong> use, and sets
<code>pImageIndex</code> to the index of that image within the swapchain.
The presentation engine <strong class="purple">may</strong> not have finished reading from the image at the
time it is acquired, so the application <strong class="purple">must</strong> use <code>semaphore</code> and/or
<code>fence</code> to ensure that the image layout and contents are not modified
until the presentation engine reads have completed.
The order in which images are acquired is implementation-dependent, and <strong class="purple">may</strong>
be different than the order the images were presented.</p>
</div>
<div class="paragraph">
<p>If <code>timeout</code> is zero, then <code>vkAcquireNextImageKHR</code> does not wait,
and will either successfully acquire an image, or fail and return
<code>VK_NOT_READY</code> if no image is available.</p>
</div>
<div class="paragraph">
<p>If the specified timeout period expires before an image is acquired,
<code>vkAcquireNextImageKHR</code> returns <code>VK_TIMEOUT</code>.
If <code>timeout</code> is <code>UINT64_MAX</code>, the timeout period is treated as
infinite, and <code>vkAcquireNextImageKHR</code> will block until an image is
acquired or an error occurs.</p>
</div>
<div class="paragraph">
<p>An image will eventually be acquired if the number of images that the
application has currently acquired (but not yet presented) is less than or
equal to the difference between the number of images in <code>swapchain</code> and
the value of <a href="#VkSurfaceCapabilitiesKHR">VkSurfaceCapabilitiesKHR</a>::<code>minImageCount</code>.
If the number of currently acquired images is greater than this,
<code>vkAcquireNextImageKHR</code> <strong class="purple">should</strong> not be called; if it is, <code>timeout</code>
<strong class="purple">must</strong> not be <code>UINT64_MAX</code>.</p>
</div>
<div class="paragraph">
<p>If an image is acquired successfully, <code>vkAcquireNextImageKHR</code> <strong class="purple">must</strong>
either return <code>VK_SUCCESS</code>, or <code>VK_SUBOPTIMAL_KHR</code> if the swapchain
no longer matches the surface properties exactly, but <strong class="purple">can</strong> still be used for
presentation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>This <strong class="purple">may</strong> happen, for example, if the platform surface has been resized but
the platform is able to scale the presented images to the new size to
produce valid surface updates.
It is up to the application to decide whether it prefers to continue using
the current swapchain in this state, or to re-create the swapchain to better
match the platform surface properties.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the swapchain images no longer match native surface properties, either
<code>VK_SUBOPTIMAL_KHR</code> or <code>VK_ERROR_OUT_OF_DATE_KHR</code> <strong class="purple">must</strong> be returned.
If <code>VK_ERROR_OUT_OF_DATE_KHR</code> is returned, no image is acquired and
attempts to present previously acquired images to the swapchain will also
fail with <code>VK_ERROR_OUT_OF_DATE_KHR</code>.
Applications need to create a new swapchain for the surface to continue
presenting if <code>VK_ERROR_OUT_OF_DATE_KHR</code> is returned.</p>
</div>
<div class="paragraph">
<p>If device loss occurs (see <a href="chap4.html#devsandqueues-lost-device">Lost Device</a>) before
the timeout has expired, <code>vkAcquireNextImageKHR</code> <strong class="purple">must</strong> return in finite
time with either one of the allowed success codes, or
<code>VK_ERROR_DEVICE_LOST</code>.</p>
</div>
<div class="paragraph">
<p>If <code>semaphore</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, the semaphore <strong class="purple">must</strong> be
unsignaled, with no signal or wait operations pending.
It will become signaled when the application <strong class="purple">can</strong> use the image.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Use of <code>semaphore</code> allows rendering operations to be recorded and
submitted before the presentation engine has completed its use of the image.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code>fence</code> is not equal to <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, the fence <strong class="purple">must</strong> be
unsignaled, with no signal operations pending.
It will become signaled when the application <strong class="purple">can</strong> use the image.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Applications <strong class="purple">should</strong> not rely on <code>vkAcquireNextImageKHR</code> blocking in
order to meter their rendering speed.
The implementation <strong class="purple">may</strong> return from this function immediately regardless of
how many presentation requests are queued, and regardless of when queued
presentation requests will complete relative to the call.
Instead, applications <strong class="purple">can</strong> use <code>fence</code> to meter their frame generation
work to match the presentation rate.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An application <strong class="purple">must</strong> wait until either the <code>semaphore</code> or <code>fence</code> is
signaled before accessing the image’s data.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>When the presentable image will be accessed by some stage <span class="eq">S</span>, the
recommended idiom for ensuring correct synchronization is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="chap5.html#VkSubmitInfo">VkSubmitInfo</a> used to submit the image layout transition for
execution includes <code>vkAcquireNextImageKHR</code>::<code>semaphore</code> in its
<code>pWaitSemaphores</code> member, with the corresponding element of
<code>pWaitDstStageMask</code> including <span class="eq">S</span>.</p>
</li>
<li>
<p>The <a href="chap6.html#synchronization">synchronization command</a> that performs any
necessary image layout transition includes <span class="eq">S</span> in both the
<code>srcStageMask</code> and <code>dstStageMask</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After a successful return, the image indicated by <code>pImageIndex</code> and its
data will be unmodified compared to when it was presented.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Exclusive ownership of presentable images corresponding to a swapchain
created with <code>VK_SHARING_MODE_EXCLUSIVE</code> as defined in
<a href="chap11.html#resources-sharing">Resource Sharing</a> is not altered by a call to
<code>vkAcquireNextImageKHR</code>.
That means upon the first acquisition from such a swapchain presentable
images are not owned by any queue family, while at subsequent acquisitions
the presentable images remain owned by the queue family the image was
previously presented on.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The possible return values for <code>vkAcquireNextImageKHR</code> depend on the
<code>timeout</code> provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code> is returned if an image became available.</p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code> if the surface becomes no longer
available.</p>
</li>
<li>
<p><code>VK_NOT_READY</code> is returned if <code>timeout</code> is zero and no image was
available.</p>
</li>
<li>
<p><code>VK_TIMEOUT</code> is returned if <code>timeout</code> is greater than zero and
less than <code>UINT64_MAX</code>, and no image became available within the time
allowed.</p>
</li>
<li>
<p><code>VK_SUBOPTIMAL_KHR</code> is returned if an image became available, and
the swapchain no longer matches the surface properties exactly, but <strong class="purple">can</strong>
still be used to present to the surface successfully.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>This <strong class="purple">may</strong> happen, for example, if the platform surface has been resized but
the platform is able to scale the presented images to the new size to
produce valid surface updates.
It is up to the application to decide whether it prefers to continue using
the current swapchain indefinitely or temporarily in this state, or to
re-create the swapchain to better match the platform surface properties.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_DATE_KHR</code> is returned if the surface has changed in
such a way that it is no longer compatible with the swapchain, and
further presentation requests using the swapchain will fail.
Applications <strong class="purple">must</strong> query the new surface properties and recreate their
swapchain if they wish to continue presenting to the surface.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the native surface and presented image sizes no longer match,
presentation <strong class="purple">may</strong> fail.
If presentation does succeed, the mapping from the presented image to the
native surface is implementation-defined.
It is the application’s responsibility to detect surface size changes and
react appropriately.
If presentation fails because of a mismatch in the surface and presented
image sizes, a <code>VK_ERROR_OUT_OF_DATE_KHR</code> error will be returned.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>For example, consider a 4x3 window/surface that gets resized to be 3x4
(taller than wider).
On some window systems, the portion of the window/surface that was
previously and still is visible (the 3x3 part) will contain the same
contents as before, while the remaining parts of the window will have
undefined contents.
Other window systems <strong class="purple">may</strong> squash/stretch the image to fill the new window
size without any undefined contents, or apply some other mapping.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To acquire an available presentable image to use, and retrieve the index of
that image, call:</p>
</div>
<div id="vkAcquireNextImage2KHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkAcquireNextImage2KHR(
    VkDevice                                    device,
    <span class="directive">const</span> VkAcquireNextImageInfoKHR*            pAcquireInfo,
    uint32_t*                                   pImageIndex);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the device associated with <code>swapchain</code>.</p>
</li>
<li>
<p><code>pAcquireInfo</code> is a pointer to a structure of type
<a href="#VkAcquireNextImageInfoKHR">VkAcquireNextImageInfoKHR</a> containing parameters of the acquire.</p>
</li>
<li>
<p><code>pImageIndex</code> is a pointer to a <code>uint32_t</code> that is set to the
index of the next image to use.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkAcquireNextImage2KHR-swapchain-01803"></a>
If the number of currently acquired images is greater than the
difference between the number of images in the <code>swapchain</code> member of
<code>pAcquireInfo</code> and the value of
<a href="#VkSurfaceCapabilitiesKHR">VkSurfaceCapabilitiesKHR</a>::<code>minImageCount</code> as returned by a
call to <a href="#vkGetPhysicalDeviceSurfaceCapabilities2KHR">vkGetPhysicalDeviceSurfaceCapabilities2KHR</a> with the
<code>surface</code> used to create <code>swapchain</code>, the <code>timeout</code> member
of <code>pAcquireInfo</code> <strong class="purple">must</strong> not be <code>UINT64_MAX</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkAcquireNextImage2KHR-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <code>VkDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkAcquireNextImage2KHR-pAcquireInfo-parameter"></a> <code>pAcquireInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkAcquireNextImageInfoKHR</code> structure</p>
</li>
<li>
<p><a id="VUID-vkAcquireNextImage2KHR-pImageIndex-parameter"></a> <code>pImageIndex</code> <strong class="purple">must</strong> be a valid pointer to a <code>uint32_t</code> value</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_TIMEOUT</code></p>
</li>
<li>
<p><code>VK_NOT_READY</code></p>
</li>
<li>
<p><code>VK_SUBOPTIMAL_KHR</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_DEVICE_LOST</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DATE_KHR</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkAcquireNextImageInfoKHR</code> structure is defined as:</p>
</div>
<div id="VkAcquireNextImageInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkAcquireNextImageInfoKHR {
    VkStructureType    sType;
    <span class="directive">const</span> <span class="directive">void</span>*        pNext;
    VkSwapchainKHR     swapchain;
    uint64_t           timeout;
    VkSemaphore        semaphore;
    VkFence            fence;
    uint32_t           deviceMask;
} VkAcquireNextImageInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>swapchain</code> is a non-retired swapchain from which an image is
acquired.</p>
</li>
<li>
<p><code>timeout</code> specifies how long the function waits, in nanoseconds, if
no image is available.</p>
</li>
<li>
<p><code>semaphore</code> is <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> or a semaphore to signal.</p>
</li>
<li>
<p><code>fence</code> is <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> or a fence to signal.</p>
</li>
<li>
<p><code>deviceMask</code> is a mask of physical devices for which the swapchain
image will be ready to use when the semaphore or fence is signaled.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <a href="#vkAcquireNextImageKHR">vkAcquireNextImageKHR</a> is used, the device mask is considered to
include all physical devices in the logical device.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p><a href="#vkAcquireNextImage2KHR">vkAcquireNextImage2KHR</a> signals at most one semaphore, even if the
application requests waiting for multiple physical devices to be ready via
the <code>deviceMask</code>.
However, only a single physical device <strong class="purple">can</strong> wait on that semaphore, since
the semaphore becomes unsignaled when the wait succeeds.
For other physical devices to wait for the image to be ready, it is
necessary for the application to submit semaphore signal operation(s) to
that first physical device to signal additional semaphore(s) after the wait
succeeds, which the other physical device(s) <strong class="purple">can</strong> wait upon.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkAcquireNextImageInfoKHR-swapchain-01675"></a>
<code>swapchain</code> <strong class="purple">must</strong> not be in the retired state</p>
</li>
<li>
<p><a id="VUID-VkAcquireNextImageInfoKHR-semaphore-01288"></a>
If <code>semaphore</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> it <strong class="purple">must</strong> be unsignaled</p>
</li>
<li>
<p><a id="VUID-VkAcquireNextImageInfoKHR-semaphore-01781"></a>
If <code>semaphore</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> it <strong class="purple">must</strong> not have any
uncompleted signal or wait operations pending</p>
</li>
<li>
<p><a id="VUID-VkAcquireNextImageInfoKHR-fence-01289"></a>
If <code>fence</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> it <strong class="purple">must</strong> be unsignaled and
<strong class="purple">must</strong> not be associated with any other queue command that has not yet
completed execution on that queue</p>
</li>
<li>
<p><a id="VUID-VkAcquireNextImageInfoKHR-semaphore-01782"></a>
<code>semaphore</code> and <code>fence</code> <strong class="purple">must</strong> not both be equal to
<a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a></p>
</li>
<li>
<p><a id="VUID-VkAcquireNextImageInfoKHR-deviceMask-01290"></a>
<code>deviceMask</code> <strong class="purple">must</strong> be a valid device mask</p>
</li>
<li>
<p><a id="VUID-VkAcquireNextImageInfoKHR-deviceMask-01291"></a>
<code>deviceMask</code> <strong class="purple">must</strong> not be zero</p>
</li>
<li>
<p><a id="VUID-VkAcquireNextImageInfoKHR-semaphore-01804"></a>
<code>semaphore</code> and <code>fence</code> <strong class="purple">must</strong> not both be equal to
<a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkAcquireNextImageInfoKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkAcquireNextImageInfoKHR-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkAcquireNextImageInfoKHR-swapchain-parameter"></a> <code>swapchain</code> <strong class="purple">must</strong> be a valid <code>VkSwapchainKHR</code> handle</p>
</li>
<li>
<p><a id="VUID-VkAcquireNextImageInfoKHR-semaphore-parameter"></a> If <code>semaphore</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>semaphore</code> <strong class="purple">must</strong> be a valid <code>VkSemaphore</code> handle</p>
</li>
<li>
<p><a id="VUID-VkAcquireNextImageInfoKHR-fence-parameter"></a> If <code>fence</code> is not <a href="chap41.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>fence</code> <strong class="purple">must</strong> be a valid <code>VkFence</code> handle</p>
</li>
<li>
<p><a id="VUID-VkAcquireNextImageInfoKHR-commonparent"></a> Each of <code>fence</code>, <code>semaphore</code>, and <code>swapchain</code> that are valid handles <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>swapchain</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to <code>semaphore</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to <code>fence</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>After queueing all rendering commands and transitioning the image to the
correct layout, to queue an image for presentation, call:</p>
</div>
<div id="vkQueuePresentKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkQueuePresentKHR(
    VkQueue                                     queue,
    <span class="directive">const</span> VkPresentInfoKHR*                     pPresentInfo);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>queue</code> is a queue that is capable of presentation to the target
surface’s platform on the same device as the image’s swapchain.</p>
</li>
<li>
<p><code>pPresentInfo</code> is a pointer to an instance of the
<a href="#VkPresentInfoKHR">VkPresentInfoKHR</a> structure specifying the parameters of the
presentation.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>There is no requirement for an application to present images in the same
order that they were acquired - applications can arbitrarily present any
image that is currently acquired.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkQueuePresentKHR-pSwapchains-01292"></a>
Each element of <code>pSwapchains</code> member of <code>pPresentInfo</code> <strong class="purple">must</strong> be
a swapchain that is created for a surface for which presentation is
supported from <code>queue</code> as determined using a call to
<code>vkGetPhysicalDeviceSurfaceSupportKHR</code></p>
</li>
<li>
<p><a id="VUID-vkQueuePresentKHR-pSwapchains-01293"></a>
If more than one member of <code>pSwapchains</code> was created from a display
surface, all display surfaces referenced that refer to the same display
<strong class="purple">must</strong> use the same display mode</p>
</li>
<li>
<p><a id="VUID-vkQueuePresentKHR-pWaitSemaphores-01294"></a>
When a semaphore unsignal operation defined by the elements of the
<code>pWaitSemaphores</code> member of <code>pPresentInfo</code> executes on
<code>queue</code>, no other queue <strong class="purple">must</strong> be waiting on the same semaphore.</p>
</li>
<li>
<p><a id="VUID-vkQueuePresentKHR-pWaitSemaphores-01295"></a>
All elements of the <code>pWaitSemaphores</code> member of <code>pPresentInfo</code>
<strong class="purple">must</strong> be semaphores that are signaled, or have
<a href="chap6.html#synchronization-semaphores-signaling">semaphore signal operations</a>
previously submitted for execution.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Any writes to memory backing the images referenced by the
<code>pImageIndices</code> and <code>pSwapchains</code> members of <code>pPresentInfo</code>,
that are available before <a href="#vkQueuePresentKHR">vkQueuePresentKHR</a> is executed, are
automatically made visible to the read access performed by the presentation
engine.
This automatic visibility operation for an image happens-after the semaphore
signal operation, and happens-before the presentation engine accesses the
image.</p>
</div>
<div class="paragraph">
<p>Queueing an image for presentation defines a set of <em>queue operations</em>,
including waiting on the semaphores and submitting a presentation request to
the presentation engine.
However, the scope of this set of queue operations does not include the
actual processing of the image by the presentation engine.</p>
</div>
<div class="paragraph">
<p>If <code>vkQueuePresentKHR</code> fails to enqueue the corresponding set of queue
operations, it <strong class="purple">may</strong> return <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> or
<code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.
If it does, the implementation <strong class="purple">must</strong> ensure that the state and contents of
any resources or synchronization primitives referenced is unaffected by the
call or its failure.</p>
</div>
<div class="paragraph">
<p>If <code>vkQueuePresentKHR</code> fails in such a way that the implementation is
unable to make that guarantee, the implementation <strong class="purple">must</strong> return
<code>VK_ERROR_DEVICE_LOST</code>.</p>
</div>
<div class="paragraph">
<p>However, if the presentation request is rejected by the presentation engine
with an error <code>VK_ERROR_OUT_OF_DATE_KHR</code> or
<code>VK_ERROR_SURFACE_LOST_KHR</code>, the set of queue operations are still
considered to be enqueued and thus any semaphore to be waited on gets
unsignaled when the corresponding queue operation is complete.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkQueuePresentKHR-queue-parameter"></a> <code>queue</code> <strong class="purple">must</strong> be a valid <code>VkQueue</code> handle</p>
</li>
<li>
<p><a id="VUID-vkQueuePresentKHR-pPresentInfo-parameter"></a> <code>pPresentInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <code>VkPresentInfoKHR</code> structure</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>queue</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to <code>pPresentInfo.pWaitSemaphores</code>[] <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to <code>pPresentInfo.pSwapchains</code>[] <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Command Properties</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><a href="chap5.html#VkCommandBufferLevel">Command Buffer Levels</a></th>
<th class="tableblock halign-left valign-top"><a href="chap7.html#vkCmdBeginRenderPass">Render Pass Scope</a></th>
<th class="tableblock halign-left valign-top"><a href="chap4.html#VkQueueFlagBits">Supported Queue Types</a></th>
<th class="tableblock halign-left valign-top"><a href="chap6.html#synchronization-pipeline-stages-types">Pipeline Type</a></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
<li>
<p><code>VK_SUBOPTIMAL_KHR</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_DEVICE_LOST</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DATE_KHR</code></p>
</li>
<li>
<p><code>VK_ERROR_SURFACE_LOST_KHR</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkPresentInfoKHR</code> structure is defined as:</p>
</div>
<div id="VkPresentInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkPresentInfoKHR {
    VkStructureType          sType;
    <span class="directive">const</span> <span class="directive">void</span>*              pNext;
    uint32_t                 waitSemaphoreCount;
    <span class="directive">const</span> VkSemaphore*       pWaitSemaphores;
    uint32_t                 swapchainCount;
    <span class="directive">const</span> VkSwapchainKHR*    pSwapchains;
    <span class="directive">const</span> uint32_t*          pImageIndices;
    VkResult*                pResults;
} VkPresentInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>waitSemaphoreCount</code> is the number of semaphores to wait for before
issuing the present request.
The number <strong class="purple">may</strong> be zero.</p>
</li>
<li>
<p><code>pWaitSemaphores</code>, if not <code>NULL</code>, is an array of <a href="chap6.html#VkSemaphore">VkSemaphore</a>
objects with <code>waitSemaphoreCount</code> entries, and specifies the
semaphores to wait for before issuing the present request.</p>
</li>
<li>
<p><code>swapchainCount</code> is the number of swapchains being presented to by
this command.</p>
</li>
<li>
<p><code>pSwapchains</code> is an array of <a href="#VkSwapchainKHR">VkSwapchainKHR</a> objects with
<code>swapchainCount</code> entries.
A given swapchain <strong class="purple">must</strong> not appear in this list more than once.</p>
</li>
<li>
<p><code>pImageIndices</code> is an array of indices into the array of each
swapchain’s presentable images, with <code>swapchainCount</code> entries.
Each entry in this array identifies the image to present on the
corresponding entry in the <code>pSwapchains</code> array.</p>
</li>
<li>
<p><code>pResults</code> is an array of <a href="chap2.html#VkResult">VkResult</a> typed elements with
<code>swapchainCount</code> entries.
Applications that do not need per-swapchain results <strong class="purple">can</strong> use <code>NULL</code> for
<code>pResults</code>.
If non-<code>NULL</code>, each entry in <code>pResults</code> will be set to the
<a href="chap2.html#VkResult">VkResult</a> for presenting the swapchain corresponding to the same
index in <code>pSwapchains</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Before an application <strong class="purple">can</strong> present an image, the image’s layout <strong class="purple">must</strong> be
transitioned to the <code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code>
layout, or for a shared presentable image the
<code>VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR</code>
layout.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>When transitioning the image to
<code>VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR</code> or
<code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code>, there is no need to delay subsequent
processing, or perform any visibility operations (as <a href="#vkQueuePresentKHR">vkQueuePresentKHR</a>
performs automatic visibility operations).
To achieve this, the <code>dstAccessMask</code> member of the
<a href="chap6.html#VkImageMemoryBarrier">VkImageMemoryBarrier</a> <strong class="purple">should</strong> be set to <code>0</code>, and the <code>dstStageMask</code>
parameter <strong class="purple">should</strong> be set to <code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPresentInfoKHR-pImageIndices-01430"></a>
Each element of <code>pImageIndices</code> <strong class="purple">must</strong> be the index of a presentable
image acquired from the swapchain specified by the corresponding element
of the <code>pSwapchains</code> array, and the presented image subresource
<strong class="purple">must</strong> be in the <code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code> or
<code>VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR</code> layout at the time the
operation is executed on a <code>VkDevice</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPresentInfoKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_PRESENT_INFO_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkPresentInfoKHR-pNext-pNext"></a> Each <code>pNext</code> member of any structure (including this one) in the <code>pNext</code> chain <strong class="purple">must</strong> be either <code>NULL</code> or a pointer to a valid instance of <a href="#VkDeviceGroupPresentInfoKHR">VkDeviceGroupPresentInfoKHR</a>, <a href="#VkDisplayPresentInfoKHR">VkDisplayPresentInfoKHR</a>, <a href="#VkPresentRegionsKHR">VkPresentRegionsKHR</a>, or <a href="#VkPresentTimesInfoGOOGLE">VkPresentTimesInfoGOOGLE</a></p>
</li>
<li>
<p><a id="VUID-VkPresentInfoKHR-sType-unique"></a> Each <code>sType</code> member in the <code>pNext</code> chain <strong class="purple">must</strong> be unique</p>
</li>
<li>
<p><a id="VUID-VkPresentInfoKHR-pWaitSemaphores-parameter"></a> If <code>waitSemaphoreCount</code> is not <code>0</code>, <code>pWaitSemaphores</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>waitSemaphoreCount</code> valid <code>VkSemaphore</code> handles</p>
</li>
<li>
<p><a id="VUID-VkPresentInfoKHR-pSwapchains-parameter"></a> <code>pSwapchains</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>swapchainCount</code> valid <code>VkSwapchainKHR</code> handles</p>
</li>
<li>
<p><a id="VUID-VkPresentInfoKHR-pImageIndices-parameter"></a> <code>pImageIndices</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>swapchainCount</code> <code>uint32_t</code> values</p>
</li>
<li>
<p><a id="VUID-VkPresentInfoKHR-pResults-parameter"></a> If <code>pResults</code> is not <code>NULL</code>, <code>pResults</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>swapchainCount</code> <a href="chap2.html#VkResult">VkResult</a> values</p>
</li>
<li>
<p><a id="VUID-VkPresentInfoKHR-swapchainCount-arraylength"></a> <code>swapchainCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkPresentInfoKHR-commonparent"></a> Both of the elements of <code>pSwapchains</code>, and the elements of <code>pWaitSemaphores</code> that are valid handles <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>When the <code>VK_KHR_incremental_present</code> extension is enabled, additional
fields <strong class="purple">can</strong> be specified that allow an application to specify that only
certain rectangular regions of the presentable images of a swapchain are
changed.
This is an optimization hint that a presentation engine <strong class="purple">may</strong> use to only
update the region of a surface that is actually changing.
The application still <strong class="purple">must</strong> ensure that all pixels of a presented image
contain the desired values, in case the presentation engine ignores this
hint.
An application <strong class="purple">can</strong> provide this hint by including the
<code>VkPresentRegionsKHR</code> structure in the <code>pNext</code> chain of the
<code>VkPresentInfoKHR</code> structure.</p>
</div>
<div class="paragraph">
<p>The <code>VkPresentRegionsKHR</code> structure is defined as:</p>
</div>
<div id="VkPresentRegionsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkPresentRegionsKHR {
    VkStructureType              sType;
    <span class="directive">const</span> <span class="directive">void</span>*                  pNext;
    uint32_t                     swapchainCount;
    <span class="directive">const</span> VkPresentRegionKHR*    pRegions;
} VkPresentRegionsKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>swapchainCount</code> is the number of swapchains being presented to by
this command.</p>
</li>
<li>
<p><code>pRegions</code> is <code>NULL</code> or a pointer to an array of
<code>VkPresentRegionKHR</code> elements with <code>swapchainCount</code> entries.
If not <code>NULL</code>, each element of <code>pRegions</code> contains the region that
has changed since the last present to the swapchain in the corresponding
entry in the <code>VkPresentInfoKHR</code>::<code>pSwapchains</code> array.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPresentRegionsKHR-swapchainCount-01260"></a>
<code>swapchainCount</code> <strong class="purple">must</strong> be the same value as
<code>VkPresentInfoKHR</code>::<code>swapchainCount</code>, where
<code>VkPresentInfoKHR</code> is in the pNext-chain of this
<code>VkPresentRegionsKHR</code> structure.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPresentRegionsKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkPresentRegionsKHR-pRegions-parameter"></a> If <code>pRegions</code> is not <code>NULL</code>, <code>pRegions</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>swapchainCount</code> valid <code>VkPresentRegionKHR</code> structures</p>
</li>
<li>
<p><a id="VUID-VkPresentRegionsKHR-swapchainCount-arraylength"></a> <code>swapchainCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>For a given image and swapchain, the region to present is specified by the
<code>VkPresentRegionKHR</code> structure, which is defined as:</p>
</div>
<div id="VkPresentRegionKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkPresentRegionKHR {
    uint32_t                 rectangleCount;
    <span class="directive">const</span> VkRectLayerKHR*    pRectangles;
} VkPresentRegionKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>rectangleCount</code> is the number of rectangles in <code>pRectangles</code>,
or zero if the entire image has changed and should be presented.</p>
</li>
<li>
<p><code>pRectangles</code> is either <code>NULL</code> or a pointer to an array of
<code>VkRectLayerKHR</code> structures.
The <code>VkRectLayerKHR</code> structure is the framebuffer coordinates, plus
layer, of a portion of a presentable image that has changed and <strong class="purple">must</strong> be
presented.
If non-<code>NULL</code>, each entry in <code>pRectangles</code> is a rectangle of the
given image that has changed since the last image was presented to the
given swapchain.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPresentRegionKHR-pRectangles-parameter"></a> If <code>rectangleCount</code> is not <code>0</code>, and <code>pRectangles</code> is not <code>NULL</code>, <code>pRectangles</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>rectangleCount</code> valid <code>VkRectLayerKHR</code> structures</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkRectLayerKHR</code> structure is defined as:</p>
</div>
<div id="VkRectLayerKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkRectLayerKHR {
    VkOffset2D    offset;
    VkExtent2D    extent;
    uint32_t      layer;
} VkRectLayerKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>offset</code> is the origin of the rectangle, in pixels.</p>
</li>
<li>
<p><code>extent</code> is the size of the rectangle, in pixels.</p>
</li>
<li>
<p><code>layer</code> is the layer of the image.
For images with only one layer, the value of <code>layer</code> <strong class="purple">must</strong> be 0.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkRectLayerKHR-offset-01261"></a>
The sum of <code>offset</code> and <code>extent</code> <strong class="purple">must</strong> be no greater than the
<code>imageExtent</code> member of the <code>VkSwapchainCreateInfoKHR</code> structure
given to <a href="#vkCreateSwapchainKHR">vkCreateSwapchainKHR</a>.</p>
</li>
<li>
<p><a id="VUID-VkRectLayerKHR-layer-01262"></a>
<code>layer</code> <strong class="purple">must</strong> be less than <code>imageArrayLayers</code> member of the
<code>VkSwapchainCreateInfoKHR</code> structure given to
<a href="#vkCreateSwapchainKHR">vkCreateSwapchainKHR</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Some platforms allow the size of a surface to change, and then scale the
pixels of the image to fit the surface.
<code>VkRectLayerKHR</code> specifies pixels of the swapchain’s image(s), which
will be constant for the life of the swapchain.</p>
</div>
</div>
</div>
<div id="display_swapchain_present" class="paragraph">
<p>When the <code>VK_KHR_display_swapchain</code> extension is enabled additional fields
<strong class="purple">can</strong> be specified when presenting an image to a swapchain by setting
<a href="#VkPresentInfoKHR">VkPresentInfoKHR</a>::<code>pNext</code> to point to an instance of the
<a href="#VkDisplayPresentInfoKHR">VkDisplayPresentInfoKHR</a> structure.</p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDisplayPresentInfoKHR</code> structure is defined as:</p>
</div>
<div id="VkDisplayPresentInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDisplayPresentInfoKHR {
    VkStructureType    sType;
    <span class="directive">const</span> <span class="directive">void</span>*        pNext;
    VkRect2D           srcRect;
    VkRect2D           dstRect;
    VkBool32           persistent;
} VkDisplayPresentInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>srcRect</code> is a rectangular region of pixels to present.
It <strong class="purple">must</strong> be a subset of the image being presented.
If <code>VkDisplayPresentInfoKHR</code> is not specified, this region will be
assumed to be the entire presentable image.</p>
</li>
<li>
<p><code>dstRect</code> is a rectangular region within the visible region of the
swapchain’s display mode.
If <code>VkDisplayPresentInfoKHR</code> is not specified, this region will be
assumed to be the entire visible region of the visible region of the
swapchain’s mode.
If the specified rectangle is a subset of the display mode’s visible
region, content from display planes below the swapchain’s plane will be
visible outside the rectangle.
If there are no planes below the swapchain’s, the area outside the
specified rectangle will be black.
If portions of the specified rectangle are outside of the display’s
visible region, pixels mapping only to those portions of the rectangle
will be discarded.</p>
</li>
<li>
<p><code>persistent</code>: If this is <code>VK_TRUE</code>, the display engine will
enable buffered mode on displays that support it.
This allows the display engine to stop sending content to the display
until a new image is presented.
The display will instead maintain a copy of the last presented image.
This allows less power to be used, but <strong class="purple">may</strong> increase presentation
latency.
If <code>VkDisplayPresentInfoKHR</code> is not specified, persistent mode will
not be used.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the extent of the <code>srcRect</code> and <code>dstRect</code> are not equal, the
presented pixels will be scaled accordingly.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDisplayPresentInfoKHR-srcRect-01257"></a>
<code>srcRect</code> <strong class="purple">must</strong> specify a rectangular region that is a subset of the
image being presented</p>
</li>
<li>
<p><a id="VUID-VkDisplayPresentInfoKHR-dstRect-01258"></a>
<code>dstRect</code> <strong class="purple">must</strong> specify a rectangular region that is a subset of the
<code>visibleRegion</code> parameter of the display mode the swapchain being
presented uses</p>
</li>
<li>
<p><a id="VUID-VkDisplayPresentInfoKHR-persistentContent-01259"></a>
If the <code>persistentContent</code> member of the
<code>VkDisplayPropertiesKHR</code> structure returned by
<code>vkGetPhysicalDeviceDisplayPropertiesKHR</code> for the display the
present operation targets then <code>persistent</code> <strong class="purple">must</strong> be <code>VK_FALSE</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDisplayPresentInfoKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>If the <code>pNext</code> chain of <a href="#VkPresentInfoKHR">VkPresentInfoKHR</a> includes a
<code>VkDeviceGroupPresentInfoKHR</code> structure, then that structure includes an
array of device masks and a device group present mode.</p>
</div>
<div class="paragraph">
<p>The <code>VkDeviceGroupPresentInfoKHR</code> structure is defined as:</p>
</div>
<div id="VkDeviceGroupPresentInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDeviceGroupPresentInfoKHR {
    VkStructureType                        sType;
    <span class="directive">const</span> <span class="directive">void</span>*                            pNext;
    uint32_t                               swapchainCount;
    <span class="directive">const</span> uint32_t*                        pDeviceMasks;
    VkDeviceGroupPresentModeFlagBitsKHR    mode;
} VkDeviceGroupPresentInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>swapchainCount</code> is zero or the number of elements in
<code>pDeviceMasks</code>.</p>
</li>
<li>
<p><code>pDeviceMasks</code> is an array of device masks, one for each element of
<a href="#VkPresentInfoKHR">VkPresentInfoKHR</a>::pSwapchains.</p>
</li>
<li>
<p><code>mode</code> is the device group present mode that will be used for this
present.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>mode</code> is <code>VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR</code>, then each
element of <code>pDeviceMasks</code> selects which instance of the swapchain image
is presented.
Each element of <code>pDeviceMasks</code> <strong class="purple">must</strong> have exactly one bit set, and the
corresponding physical device <strong class="purple">must</strong> have a presentation engine as reported
by <a href="#VkDeviceGroupPresentCapabilitiesKHR">VkDeviceGroupPresentCapabilitiesKHR</a>.</p>
</div>
<div class="paragraph">
<p>If <code>mode</code> is <code>VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR</code>, then
each element of <code>pDeviceMasks</code> selects which instance of the swapchain
image is presented.
Each element of <code>pDeviceMasks</code> <strong class="purple">must</strong> have exactly one bit set, and some
physical device in the logical device <strong class="purple">must</strong> include that bit in its
<a href="#VkDeviceGroupPresentCapabilitiesKHR">VkDeviceGroupPresentCapabilitiesKHR</a>::<code>presentMask</code>.</p>
</div>
<div class="paragraph">
<p>If <code>mode</code> is <code>VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR</code>, then each
element of <code>pDeviceMasks</code> selects which instances of the swapchain image
are component-wise summed and the sum of those images is presented.
If the sum in any component is outside the representable range, the value of
that component is undefined.
Each element of <code>pDeviceMasks</code> <strong class="purple">must</strong> have a value for which all set bits
are set in one of the elements of
<a href="#VkDeviceGroupPresentCapabilitiesKHR">VkDeviceGroupPresentCapabilitiesKHR</a>::<code>presentMask</code>.</p>
</div>
<div class="paragraph">
<p>If <code>mode</code> is
<code>VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR</code>, then each
element of <code>pDeviceMasks</code> selects which instance(s) of the swapchain
images are presented.
For each bit set in each element of <code>pDeviceMasks</code>, the corresponding
physical device <strong class="purple">must</strong> have a presentation engine as reported by
<a href="#VkDeviceGroupPresentCapabilitiesKHR">VkDeviceGroupPresentCapabilitiesKHR</a>.</p>
</div>
<div class="paragraph">
<p>If <code>VkDeviceGroupPresentInfoKHR</code> is not provided or <code>swapchainCount</code>
is zero then the masks are considered to be <code>1</code>.
If <code>VkDeviceGroupPresentInfoKHR</code> is not provided, <code>mode</code> is
considered to be <code>VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDeviceGroupPresentInfoKHR-swapchainCount-01297"></a>
<code>swapchainCount</code> <strong class="purple">must</strong> equal <code>0</code> or
<a href="#VkPresentInfoKHR">VkPresentInfoKHR</a>::<code>swapchainCount</code></p>
</li>
<li>
<p><a id="VUID-VkDeviceGroupPresentInfoKHR-mode-01298"></a>
If <code>mode</code> is <code>VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR</code>, then
each element of <code>pDeviceMasks</code> <strong class="purple">must</strong> have exactly one bit set, and
the corresponding element of
<a href="#VkDeviceGroupPresentCapabilitiesKHR">VkDeviceGroupPresentCapabilitiesKHR</a>::<code>presentMask</code> <strong class="purple">must</strong> be
non-zero</p>
</li>
<li>
<p><a id="VUID-VkDeviceGroupPresentInfoKHR-mode-01299"></a>
If <code>mode</code> is <code>VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR</code>, then
each element of <code>pDeviceMasks</code> <strong class="purple">must</strong> have exactly one bit set, and
some physical device in the logical device <strong class="purple">must</strong> include that bit in its
<a href="#VkDeviceGroupPresentCapabilitiesKHR">VkDeviceGroupPresentCapabilitiesKHR</a>::<code>presentMask</code>.</p>
</li>
<li>
<p><a id="VUID-VkDeviceGroupPresentInfoKHR-mode-01300"></a>
If <code>mode</code> is <code>VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR</code>, then
each element of <code>pDeviceMasks</code> <strong class="purple">must</strong> have a value for which all set
bits are set in one of the elements of
<a href="#VkDeviceGroupPresentCapabilitiesKHR">VkDeviceGroupPresentCapabilitiesKHR</a>::<code>presentMask</code></p>
</li>
<li>
<p><a id="VUID-VkDeviceGroupPresentInfoKHR-mode-01301"></a>
If <code>mode</code> is
<code>VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR</code>, then for
each bit set in each element of <code>pDeviceMasks</code>, the corresponding
element of <a href="#VkDeviceGroupPresentCapabilitiesKHR">VkDeviceGroupPresentCapabilitiesKHR</a>::<code>presentMask</code>
<strong class="purple">must</strong> be non-zero</p>
</li>
<li>
<p><a id="VUID-VkDeviceGroupPresentInfoKHR-pDeviceMasks-01302"></a>
The value of each element of <code>pDeviceMasks</code> <strong class="purple">must</strong> be equal to the
device mask passed in <a href="#VkAcquireNextImageInfoKHR">VkAcquireNextImageInfoKHR</a>::<code>deviceMask</code>
when the image index was last acquired</p>
</li>
<li>
<p><a id="VUID-VkDeviceGroupPresentInfoKHR-mode-01303"></a>
<code>mode</code> <strong class="purple">must</strong> have exactly one bit set, and that bit <strong class="purple">must</strong> have been
included in <a href="#VkDeviceGroupSwapchainCreateInfoKHR">VkDeviceGroupSwapchainCreateInfoKHR</a>::<code>modes</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDeviceGroupPresentInfoKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkDeviceGroupPresentInfoKHR-pDeviceMasks-parameter"></a> If <code>swapchainCount</code> is not <code>0</code>, <code>pDeviceMasks</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>swapchainCount</code> <code>uint32_t</code> values</p>
</li>
<li>
<p><a id="VUID-VkDeviceGroupPresentInfoKHR-mode-parameter"></a> <code>mode</code> <strong class="purple">must</strong> be a valid <a href="#VkDeviceGroupPresentModeFlagBitsKHR">VkDeviceGroupPresentModeFlagBitsKHR</a> value</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>When the <code><a href="chap40.html#VK_GOOGLE_display_timing">VK_GOOGLE_display_timing</a></code> extension is enabled, additional
fields <strong class="purple">can</strong> be specified that allow an application to specify the earliest
time that an image should be displayed.
This allows an application to avoid stutter that is caused by an image being
displayed earlier than planned.
Such stuttering can occur with both fixed and variable-refresh-rate
displays, because stuttering occurs when the geometry is not correctly
positioned for when the image is displayed.
An application <strong class="purple">can</strong> instruct the presentation engine that an image should
not be displayed earlier than a specified time by including the
<code>VkPresentTimesInfoGOOGLE</code> structure in the <code>pNext</code> chain of the
<code>VkPresentInfoKHR</code> structure.</p>
</div>
<div class="paragraph">
<p>The <code>VkPresentTimesInfoGOOGLE</code> structure is defined as:</p>
</div>
<div id="VkPresentTimesInfoGOOGLE" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkPresentTimesInfoGOOGLE {
    VkStructureType               sType;
    <span class="directive">const</span> <span class="directive">void</span>*                   pNext;
    uint32_t                      swapchainCount;
    <span class="directive">const</span> VkPresentTimeGOOGLE*    pTimes;
} VkPresentTimesInfoGOOGLE;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>swapchainCount</code> is the number of swapchains being presented to by
this command.</p>
</li>
<li>
<p><code>pTimes</code> is <code>NULL</code> or a pointer to an array of
<code>VkPresentTimeGOOGLE</code> elements with <code>swapchainCount</code> entries.
If not <code>NULL</code>, each element of <code>pTimes</code> contains the earliest time
to present the image corresponding to the entry in the
<code>VkPresentInfoKHR</code>::<code>pImageIndices</code> array.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPresentTimesInfoGOOGLE-swapchainCount-01247"></a>
<code>swapchainCount</code> <strong class="purple">must</strong> be the same value as
<code>VkPresentInfoKHR</code>::<code>swapchainCount</code>, where
<code>VkPresentInfoKHR</code> is in the <code>pNext</code> chain of this
<code>VkPresentTimesInfoGOOGLE</code> structure.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPresentTimesInfoGOOGLE-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE</code></p>
</li>
<li>
<p><a id="VUID-VkPresentTimesInfoGOOGLE-pTimes-parameter"></a> If <code>pTimes</code> is not <code>NULL</code>, <code>pTimes</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>swapchainCount</code> <code>VkPresentTimeGOOGLE</code> structures</p>
</li>
<li>
<p><a id="VUID-VkPresentTimesInfoGOOGLE-swapchainCount-arraylength"></a> <code>swapchainCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkPresentTimeGOOGLE</code> structure is defined as:</p>
</div>
<div id="VkPresentTimeGOOGLE" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkPresentTimeGOOGLE {
    uint32_t    presentID;
    uint64_t    desiredPresentTime;
} VkPresentTimeGOOGLE;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>presentID</code> is an application-provided identification value, that
<strong class="purple">can</strong> be used with the results of
<a href="#vkGetPastPresentationTimingGOOGLE">vkGetPastPresentationTimingGOOGLE</a>, in order to uniquely identify
this present.
In order to be useful to the application, it <strong class="purple">should</strong> be unique within
some period of time that is meaningful to the application.</p>
</li>
<li>
<p><code>desiredPresentTime</code> specifies that the image given <strong class="purple">should</strong> not be
displayed to the user any earlier than this time.
<code>desiredPresentTime</code> is a time in nanoseconds, relative to a
monotonically-increasing clock (e.g. <code>CLOCK_MONOTONIC</code> (see
clock_gettime(2)) on Android and Linux).
A value of zero specifies that the presentation engine <strong class="purple">may</strong> display the
image at any time.
This is useful when the application desires to provide <code>presentID</code>,
but doesn’t need a specific <code>desiredPresentTime</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><code>vkQueuePresentKHR</code>, releases the acquisition of the images referenced
by <code>imageIndices</code>.
The queue family corresponding to the queue <code>vkQueuePresentKHR</code> is
executed on <strong class="purple">must</strong> have ownership of the presented images as defined in
<a href="chap11.html#resources-sharing">Resource Sharing</a>.
<code>vkQueuePresentKHR</code> does not alter the queue family ownership, but the
presented images <strong class="purple">must</strong> not be used again before they have been reacquired
using <code>vkAcquireNextImageKHR</code>.</p>
</div>
<div class="paragraph">
<p>The processing of the presentation happens in issue order with other queue
operations, but semaphores have to be used to ensure that prior rendering
and other commands in the specified queue complete before the presentation
begins.
The presentation command itself does not delay processing of subsequent
commands on the queue, however, presentation requests sent to a particular
queue are always performed in order.
Exact presentation timing is controlled by the semantics of the presentation
engine and native platform in use.</p>
</div>
<div class="paragraph">
<p>If an image is presented to a swapchain created from a display surface, the
mode of the associated display will be updated, if necessary, to match the
mode specified when creating the display surface.
The mode switch and presentation of the specified image will be performed as
one atomic operation.</p>
</div>
<div class="paragraph">
<p>The result codes <code>VK_ERROR_OUT_OF_DATE_KHR</code> and <code>VK_SUBOPTIMAL_KHR</code>
have the same meaning when returned by <code>vkQueuePresentKHR</code> as they do
when returned by <code>vkAcquireNextImageKHR</code>.
If multiple swapchains are presented, the result code is determined applying
the following rules in order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the device is lost, <code>VK_ERROR_DEVICE_LOST</code> is returned.</p>
</li>
<li>
<p>If any of the target surfaces are no longer available the error
<code>VK_ERROR_SURFACE_LOST_KHR</code> is returned.</p>
</li>
<li>
<p>If any of the presents would have a result of
<code>VK_ERROR_OUT_OF_DATE_KHR</code> if issued separately then
<code>VK_ERROR_OUT_OF_DATE_KHR</code> is returned.</p>
</li>
<li>
<p>If any of the presents would have a result of <code>VK_SUBOPTIMAL_KHR</code> if
issued separately then <code>VK_SUBOPTIMAL_KHR</code> is returned.</p>
</li>
<li>
<p>Otherwise <code>VK_SUCCESS</code> is returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Presentation is a read-only operation that will not affect the content of
the presentable images.
Upon reacquiring the image and transitioning it away from the
<code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code> layout, the contents will be the same
as they were prior to transitioning the image to the present source layout
and presenting it.
However, if a mechanism other than Vulkan is used to modify the platform
window associated with the swapchain, the content of all presentable images
in the swapchain becomes undefined.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>The application <strong class="purple">can</strong> continue to present any acquired images from a retired
swapchain as long as the swapchain has not entered a state that causes
<a href="#vkQueuePresentKHR">vkQueuePresentKHR</a> to return <code>VK_ERROR_OUT_OF_DATE_KHR</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_hdr_metadata">32.9. Hdr Metadata</h3>
<div class="paragraph">
<p>To improve color reproduction of content it is useful to have information
that can be used to better reproduce the colors as seen on the mastering
display.
That information can be provided to an implementation by calling
<code>vkSetHdrMetadataEXT</code>.
The metadata will be applied to the specified <code>VkSwapchainKHR</code> objects
at the next <code>vkQueuePresentKHR</code> call using that <code>VkSwapchainKHR</code>
object.
The metadata will persist until a subsequent <code>vkSetHdrMetadataEXT</code>
changes it.
The definitions below are from the associated SMPTE 2086, CTA 861.3 and CIE
15:2004 specifications.</p>
</div>
<div class="paragraph">
<p>The definition of <code>vkSetHdrMetadataEXT</code> is:</p>
</div>
<div class="openblock">
<div class="content">
<div id="vkSetHdrMetadataEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> vkSetHdrMetadataEXT(
    VkDevice                                    device,
    uint32_t                                    swapchainCount,
    <span class="directive">const</span> VkSwapchainKHR*                       pSwapchains,
    <span class="directive">const</span> VkHdrMetadataEXT*                     pMetadata);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device where the swapchain(s) were created.</p>
</li>
<li>
<p><code>swapchainCount</code> is the number of swapchains included in
<code>pSwapchains</code>.</p>
</li>
<li>
<p><code>pSwapchains</code> is a pointer to the array of <code>swapchainCount</code>
<code>VkSwapchainKHR</code> handles.</p>
</li>
<li>
<p><code>pMetadata</code> is a pointer to the array of <code>swapchainCount</code>
<code>VkHdrMetadataEXT</code> structures.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkSetHdrMetadataEXT-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <code>VkDevice</code> handle</p>
</li>
<li>
<p><a id="VUID-vkSetHdrMetadataEXT-pSwapchains-parameter"></a> <code>pSwapchains</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>swapchainCount</code> valid <code>VkSwapchainKHR</code> handles</p>
</li>
<li>
<p><a id="VUID-vkSetHdrMetadataEXT-pMetadata-parameter"></a> <code>pMetadata</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>swapchainCount</code> valid <code>VkHdrMetadataEXT</code> structures</p>
</li>
<li>
<p><a id="VUID-vkSetHdrMetadataEXT-swapchainCount-arraylength"></a> <code>swapchainCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-vkSetHdrMetadataEXT-commonparent"></a> Both of <code>device</code>, and the elements of <code>pSwapchains</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <code>VkInstance</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkXYColorEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkXYColorEXT {
    <span class="predefined-type">float</span>    x;
    <span class="predefined-type">float</span>    y;
} VkXYColorEXT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Chromaticity coordinates x and y are as specified in CIE 15:2004
“Calculation of chromaticity coordinates” (Section 7.3) and are limited to
between 0 and 1 for real colors for the mastering display.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkHdrMetadataEXT" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkHdrMetadataEXT {
    VkStructureType    sType;
    <span class="directive">const</span> <span class="directive">void</span>*        pNext;
    VkXYColorEXT       displayPrimaryRed;
    VkXYColorEXT       displayPrimaryGreen;
    VkXYColorEXT       displayPrimaryBlue;
    VkXYColorEXT       whitePoint;
    <span class="predefined-type">float</span>              maxLuminance;
    <span class="predefined-type">float</span>              minLuminance;
    <span class="predefined-type">float</span>              maxContentLightLevel;
    <span class="predefined-type">float</span>              maxFrameAverageLightLevel;
} VkHdrMetadataEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>displayPrimaryRed</code> is the mastering display’s red primary in
chromaticity coordinates</p>
</li>
<li>
<p><code>displayPrimaryGreen</code> is the mastering display’s green primary in
chromaticity coordinates</p>
</li>
<li>
<p><code>displayPrimaryBlue</code> is the mastering display’s blue primary in
chromaticity coordinates</p>
</li>
<li>
<p><code>whitePoint</code> is the mastering display’s white-point in chromaticity
coordinates</p>
</li>
<li>
<p><code>maxLuminance</code> is the maximum luminance of the mastering display in
nits</p>
</li>
<li>
<p><code>minLuminance</code> is the minimum luminance of the mastering display in
nits</p>
</li>
<li>
<p><code>maxContentLightLevel</code> is content’s maximum luminance in nits</p>
</li>
<li>
<p><code>maxFrameAverageLightLevel</code> is the maximum frame average light level
in nits</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkHdrMetadataEXT-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_HDR_METADATA_EXT</code></p>
</li>
<li>
<p><a id="VUID-VkHdrMetadataEXT-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>The validity and use of this data is outside the scope of Vulkan.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div id="footer">
<div id="footer-text">
Version 1.0.98<br>
Last updated 2019-01-05 19:39:28 -0800
</div>
</div>


</body>
</html>