<!DOCTYPE html><html lang="en"><head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<meta name="author" content="The Khronos® Vulkan Working Group">
<title>Vulkan® 1.2.184 - A Specification (with KHR extensions)</title>
<link rel="stylesheet" href="style0.css" type="text/css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="style1.css" type="text/css">

<!-- dragged in by font-awesome css included by asciidoctor, but preloaded in this extension for convenience -->
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/fonts/fontawesome-webfont.woff2?v=4.7.0" as="font" type="font/woff2" crossorigin="">

<!-- Note: Chrome needs crossorigin="" even for same-origin fonts -->
<link rel="preload" href="../katex/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Main-Italic.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Typewriter-Regular.woff2" as="font" type="font/woff2" crossorigin=""><link rel="stylesheet" href="../katex/katex.min.css">
<!--ChunkedSearchJSMarker-->
<link href="chunked.css?4" rel="stylesheet">
<script>var searchindexurl = 'search.index.js?4' + (document.title.replace(/[^0-9.]/g, ''));</script>
<script src="chunked.js?4"></script>
<link rel="stylesheet" href="style2.css" type="text/css">
<script>
    function hideElement(e){
        e.setAttribute("hidden", "");
        e.classList.add("hidden");
    }

    function unhideElement(e){
        e.classList.remove("hidden");
        e.removeAttribute("hidden");
    }

    function hideLoadableContent(){
        unhideElement( document.getElementById("loading_msg") );
        for( var loadable of document.getElementsByClassName("loadable") ) hideElement(loadable);
    }

    function unhideLoadableContent(){
        hideElement( document.getElementById("loading_msg") );
        for( var loadable of document.getElementsByClassName("loadable") ) unhideElement(loadable);
    }

    window.addEventListener("load", unhideLoadableContent);
</script>
<link rel="stylesheet" href="asciidoctor-chunker.css" type="text/css"></head>
<body class="book toc2 toc-left">
<div id="header" style="max-width: 100%;">
<h1>Vulkan<sup>®</sup> 1.2.184 - A Specification (with KHR extensions)</h1>
<div class="details">
<span id="author" class="author">The Khronos<sup>®</sup> Vulkan Working Group</span><br>
<span id="revnumber">version 1.2.184,</span>
<span id="revdate">2021-07-05 12:32:34Z</span>
<br><span id="revremark">from git branch: github-main commit: 02c265fb0af1eb5e82651e6c001d3790101adf96</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="index.html">Titlepage</a></li><li><a href="chap1.html">1. Preamble</a></li>
<li><a href="chap2.html">2. Introduction</a>
<ul class="sectlevel2">
<li><a href="chap2.html#introduction-conventions">2.1. Document Conventions</a></li>
</ul>
</li>
<li><a href="chap3.html">3. Fundamentals</a>
<ul class="sectlevel2">
<li><a href="chap3.html#fundamentals-host-environment">3.1. Host and Device Environment</a></li>
<li><a href="chap3.html#fundamentals-execmodel">3.2. Execution Model</a></li>
<li><a href="chap3.html#fundamentals-objectmodel-overview">3.3. Object Model</a></li>
<li><a href="chap3.html#fundamentals-abi">3.4. Application Binary Interface</a></li>
<li><a href="chap3.html#fundamentals-commandsyntax">3.5. Command Syntax and Duration</a></li>
<li><a href="chap3.html#fundamentals-threadingbehavior">3.6. Threading Behavior</a></li>
<li><a href="chap3.html#fundamentals-validusage">3.7. Valid Usage</a></li>
<li><a href="chap3.html#fundamentals-returncodes">3.8. <code>VkResult</code> Return Codes</a></li>
<li><a href="chap3.html#fundamentals-numerics">3.9. Numeric Representation and Computation</a></li>
<li><a href="chap3.html#fundamentals-fixedconv">3.10. Fixed-Point Data Conversions</a></li>
<li><a href="chap3.html#fundamentals-common-objects">3.11. Common Object Types</a></li>
</ul>
</li>
<li><a href="chap4.html">4. Initialization</a>
<ul class="sectlevel2">
<li><a href="chap4.html#initialization-functionpointers">4.1. Command Function Pointers</a></li>
<li><a href="chap4.html#initialization-instances">4.2. Instances</a></li>
</ul>
</li>
<li><a href="chap5.html">5. Devices and Queues</a>
<ul class="sectlevel2">
<li><a href="chap5.html#devsandqueues-physical-device-enumeration">5.1. Physical Devices</a></li>
<li><a href="chap5.html#devsandqueues-devices">5.2. Devices</a></li>
<li><a href="chap5.html#devsandqueues-queues">5.3. Queues</a></li>
</ul>
</li>
<li><a href="chap6.html">6. Command Buffers</a>
<ul class="sectlevel2">
<li><a href="chap6.html#commandbuffers-lifecycle">6.1. Command Buffer Lifecycle</a></li>
<li><a href="chap6.html#commandbuffers-pools">6.2. Command Pools</a></li>
<li><a href="chap6.html#commandbuffer-allocation">6.3. Command Buffer Allocation and Management</a></li>
<li><a href="chap6.html#commandbuffers-recording">6.4. Command Buffer Recording</a></li>
<li><a href="chap6.html#commandbuffers-submission">6.5. Command Buffer Submission</a></li>
<li><a href="chap6.html#commandbuffers-submission-progress">6.6. Queue Forward Progress</a></li>
<li><a href="chap6.html#commandbuffers-secondary">6.7. Secondary Command Buffer Execution</a></li>
<li><a href="chap6.html#commandbuffers-devicemask">6.8. Command Buffer Device Mask</a></li>
</ul>
</li>
<li><a href="chap7.html">7. Synchronization and Cache Control</a>
<ul class="sectlevel2">
<li><a href="chap7.html#synchronization-dependencies">7.1. Execution and Memory Dependencies</a></li>
<li><a href="chap7.html#synchronization-implicit">7.2. Implicit Synchronization Guarantees</a></li>
<li><a href="chap7.html#synchronization-fences">7.3. Fences</a></li>
<li><a href="chap7.html#synchronization-semaphores">7.4. Semaphores</a></li>
<li><a href="chap7.html#synchronization-events">7.5. Events</a></li>
<li><a href="chap7.html#synchronization-pipeline-barriers">7.6. Pipeline Barriers</a></li>
<li><a href="chap7.html#synchronization-memory-barriers">7.7. Memory Barriers</a></li>
<li><a href="chap7.html#synchronization-wait-idle">7.8. Wait Idle Operations</a></li>
<li><a href="chap7.html#synchronization-submission-host-writes">7.9. Host Write Ordering Guarantees</a></li>
<li><a href="chap7.html#synchronization-device-group">7.10. Synchronization and Multiple Physical Devices</a></li>
</ul>
</li>
<li><a href="chap8.html">8. Render Pass</a>
<ul class="sectlevel2">
<li><a href="chap8.html#renderpass-creation">8.1. Render Pass Creation</a></li>
<li><a href="chap8.html#renderpass-compatibility">8.2. Render Pass Compatibility</a></li>
<li><a href="chap8.html#_framebuffers">8.3. Framebuffers</a></li>
<li><a href="chap8.html#renderpass-commands">8.4. Render Pass Commands</a></li>
</ul>
</li>
<li><a href="chap9.html">9. Shaders</a>
<ul class="sectlevel2">
<li><a href="chap9.html#shader-modules">9.1. Shader Modules</a></li>
<li><a href="chap9.html#shaders-execution">9.2. Shader Execution</a></li>
<li><a href="chap9.html#shaders-execution-memory-ordering">9.3. Shader Memory Access Ordering</a></li>
<li><a href="chap9.html#shaders-inputs">9.4. Shader Inputs and Outputs</a></li>
<li><a href="chap9.html#shaders-vertex">9.5. Vertex Shaders</a></li>
<li><a href="chap9.html#shaders-tessellation-control">9.6. Tessellation Control Shaders</a></li>
<li><a href="chap9.html#shaders-tessellation-evaluation">9.7. Tessellation Evaluation Shaders</a></li>
<li><a href="chap9.html#shaders-geometry">9.8. Geometry Shaders</a></li>
<li><a href="chap9.html#shaders-fragment">9.9. Fragment Shaders</a></li>
<li><a href="chap9.html#shaders-compute">9.10. Compute Shaders</a></li>
<li><a href="chap9.html#shaders-ray-generation">9.11. Ray Generation Shaders</a></li>
<li><a href="chap9.html#shaders-intersection">9.12. Intersection Shaders</a></li>
<li><a href="chap9.html#shaders-any-hit">9.13. Any-Hit Shaders</a></li>
<li><a href="chap9.html#shaders-closest-hit">9.14. Closest Hit Shaders</a></li>
<li><a href="chap9.html#shaders-miss">9.15. Miss Shaders</a></li>
<li><a href="chap9.html#shaders-callable">9.16. Callable Shaders</a></li>
<li><a href="chap9.html#shaders-interpolation-decorations">9.17. Interpolation Decorations</a></li>
<li><a href="chap9.html#shaders-staticuse">9.18. Static Use</a></li>
<li><a href="chap9.html#shaders-scope">9.19. Scope</a></li>
<li><a href="chap9.html#shaders-group-operations">9.20. Group Operations</a></li>
<li><a href="chap9.html#shaders-quad-operations">9.21. Quad Group Operations</a></li>
<li><a href="chap9.html#shaders-derivative-operations">9.22. Derivative Operations</a></li>
<li><a href="chap9.html#shaders-helper-invocations">9.23. Helper Invocations</a></li>
</ul>
</li>
<li><a href="chap10.html">10. Pipelines</a>
<ul class="sectlevel2">
<li><a href="chap10.html#pipelines-compute">10.1. Compute Pipelines</a></li>
<li><a href="chap10.html#pipelines-graphics">10.2. Graphics Pipelines</a></li>
<li><a href="chap10.html#pipelines-ray-tracing">10.3. Ray Tracing Pipelines</a></li>
<li><a href="chap10.html#pipelines-destruction">10.4. Pipeline Destruction</a></li>
<li><a href="chap10.html#pipelines-multiple">10.5. Multiple Pipeline Creation</a></li>
<li><a href="chap10.html#pipelines-pipeline-derivatives">10.6. Pipeline Derivatives</a></li>
<li><a href="chap10.html#pipelines-cache">10.7. Pipeline Cache</a></li>
<li><a href="chap10.html#pipelines-specialization-constants">10.8. Specialization Constants</a></li>
<li><a href="chap10.html#pipeline-library">10.9. Pipeline Libraries</a></li>
<li><a href="chap10.html#pipelines-binding">10.10. Pipeline Binding</a></li>
<li><a href="chap10.html#pipelines-dynamic-state">10.11. Dynamic State</a></li>
<li><a href="chap10.html#pipelines-shader-information">10.12. Pipeline Shader Information</a></li>
</ul>
</li>
<li><a href="chap11.html">11. Memory Allocation</a>
<ul class="sectlevel2">
<li><a href="chap11.html#memory-host">11.1. Host Memory</a></li>
<li><a href="chap11.html#memory-device">11.2. Device Memory</a></li>
</ul>
</li>
<li><a href="chap12.html">12. Resource Creation</a>
<ul class="sectlevel2">
<li><a href="chap12.html#resources-buffers">12.1. Buffers</a></li>
<li><a href="chap12.html#resources-buffer-views">12.2. Buffer Views</a></li>
<li><a href="chap12.html#resources-images">12.3. Images</a></li>
<li><a href="chap12.html#resources-image-layouts">12.4. Image Layouts</a></li>
<li><a href="chap12.html#resources-image-views">12.5. Image Views</a></li>
<li><a href="chap12.html#resources-acceleration-structures">12.6. Acceleration Structures</a></li>
<li><a href="chap12.html#resources-association">12.7. Resource Memory Association</a></li>
<li><a href="chap12.html#resources-sharing">12.8. Resource Sharing Mode</a></li>
<li><a href="chap12.html#resources-memory-aliasing">12.9. Memory Aliasing</a></li>
</ul>
</li>
<li><a href="chap13.html">13. Samplers</a>
<ul class="sectlevel2">
<li><a href="chap13.html#samplers-YCbCr-conversion">13.1. Sampler Y′C<sub>B</sub>C<sub>R</sub> conversion</a></li>
</ul>
</li>
<li><a href="chap14.html">14. Resource Descriptors</a>
<ul class="sectlevel2">
<li><a href="chap14.html#descriptorsets-types">14.1. Descriptor Types</a></li>
<li><a href="chap14.html#descriptorsets-sets">14.2. Descriptor Sets</a></li>
<li><a href="chap14.html#descriptorsets-physical-storage-buffer">14.3. Physical Storage Buffer Access</a></li>
</ul>
</li>
<li><a href="chap15.html">15. Shader Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap15.html#interfaces-iointerfaces">15.1. Shader Input and Output Interfaces</a></li>
<li><a href="chap15.html#interfaces-vertexinput">15.2. Vertex Input Interface</a></li>
<li><a href="chap15.html#interfaces-fragmentoutput">15.3. Fragment Output Interface</a></li>
<li><a href="chap15.html#interfaces-inputattachment">15.4. Fragment Input Attachment Interface</a></li>
<li><a href="chap15.html#interfaces-raypipeline">15.5. Ray Tracing Pipeline Interface</a></li>
<li><a href="chap15.html#interfaces-resources">15.6. Shader Resource Interface</a></li>
<li><a href="chap15.html#interfaces-builtin-variables">15.7. Built-In Variables</a></li>
</ul>
</li>
<li><a href="chap16.html">16. Image Operations</a>
<ul class="sectlevel2">
<li><a href="chap16.html#_image_operations_overview">16.1. Image Operations Overview</a></li>
<li><a href="chap16.html#_conversion_formulas">16.2. Conversion Formulas</a></li>
<li><a href="chap16.html#_texel_input_operations">16.3. Texel Input Operations</a></li>
<li><a href="chap16.html#_texel_output_operations">16.4. Texel Output Operations</a></li>
<li><a href="chap16.html#textures-normalized-operations">16.5. Normalized Texel Coordinate Operations</a></li>
<li><a href="chap16.html#_unnormalized_texel_coordinate_operations">16.6. Unnormalized Texel Coordinate Operations</a></li>
<li><a href="chap16.html#textures-integer-coordinate-operations">16.7. Integer Texel Coordinate Operations</a></li>
<li><a href="chap16.html#textures-sample-operations">16.8. Image Sample Operations</a></li>
<li><a href="chap16.html#textures-instructions">16.9. Image Operation Steps</a></li>
<li><a href="chap16.html#textures-queries">16.10. Image Query Instructions</a></li>
</ul>
</li>
<li><a href="chap17.html">17. Queries</a>
<ul class="sectlevel2">
<li><a href="chap17.html#queries-pools">17.1. Query Pools</a></li>
<li><a href="chap17.html#queries-operation">17.2. Query Operation</a></li>
<li><a href="chap17.html#queries-occlusion">17.3. Occlusion Queries</a></li>
<li><a href="chap17.html#queries-pipestats">17.4. Pipeline Statistics Queries</a></li>
<li><a href="chap17.html#queries-timestamps">17.5. Timestamp Queries</a></li>
<li><a href="chap17.html#queries-performance">17.6. Performance Queries</a></li>
<li><a href="chap17.html#queries-result-status-only">17.7. Result Status Queries</a></li>
<li><a href="chap17.html#queries-video-encode-bitstream-buffer-range">17.8. Video Encode Bitstream Buffer Range</a></li>
</ul>
</li>
<li><a href="chap18.html">18. Clear Commands</a>
<ul class="sectlevel2">
<li><a href="chap18.html#clears-outside">18.1. Clearing Images Outside A Render Pass Instance</a></li>
<li><a href="chap18.html#clears-inside">18.2. Clearing Images Inside A Render Pass Instance</a></li>
<li><a href="chap18.html#clears-values">18.3. Clear Values</a></li>
<li><a href="chap18.html#clears-filling-buffers">18.4. Filling Buffers</a></li>
<li><a href="chap18.html#clears-updating-buffers">18.5. Updating Buffers</a></li>
</ul>
</li>
<li><a href="chap19.html">19. Copy Commands</a>
<ul class="sectlevel2">
<li><a href="chap19.html#_common_operation">19.1. Common Operation</a></li>
<li><a href="chap19.html#copies-buffers">19.2. Copying Data Between Buffers</a></li>
<li><a href="chap19.html#copies-images">19.3. Copying Data Between Images</a></li>
<li><a href="chap19.html#copies-buffers-images">19.4. Copying Data Between Buffers and Images</a></li>
<li><a href="chap19.html#copies-imagescaling">19.5. Image Copies with Scaling</a></li>
<li><a href="chap19.html#copies-resolve">19.6. Resolving Multisample Images</a></li>
</ul>
</li>
<li><a href="chap20.html">20. Drawing Commands</a>
<ul class="sectlevel2">
<li><a href="chap20.html#drawing-primitive-topologies">20.1. Primitive Topologies</a></li>
<li><a href="chap20.html#drawing-primitive-order">20.2. Primitive Order</a></li>
<li><a href="chap20.html#drawing-primitive-shading">20.3. Programmable Primitive Shading</a></li>
</ul>
</li>
<li><a href="chap21.html">21. Fixed-Function Vertex Processing</a>
<ul class="sectlevel2">
<li><a href="chap21.html#fxvertex-attrib">21.1. Vertex Attributes</a></li>
<li><a href="chap21.html#fxvertex-input">21.2. Vertex Input Description</a></li>
</ul>
</li>
<li><a href="chap22.html">22. Tessellation</a>
<ul class="sectlevel2">
<li><a href="chap22.html#_tessellator">22.1. Tessellator</a></li>
<li><a href="chap22.html#_tessellator_patch_discard">22.2. Tessellator Patch Discard</a></li>
<li><a href="chap22.html#tessellation-tessellator-spacing">22.3. Tessellator Spacing</a></li>
<li><a href="chap22.html#tessellation-primitive-order">22.4. Tessellation Primitive Ordering</a></li>
<li><a href="chap22.html#tessellation-vertex-winding-order">22.5. Tessellator Vertex Winding Order</a></li>
<li><a href="chap22.html#tessellation-triangle-tessellation">22.6. Triangle Tessellation</a></li>
<li><a href="chap22.html#tessellation-quad-tessellation">22.7. Quad Tessellation</a></li>
<li><a href="chap22.html#tessellation-isoline-tessellation">22.8. Isoline Tessellation</a></li>
<li><a href="chap22.html#tessellation-point-mode">22.9. Tessellation Point Mode</a></li>
<li><a href="chap22.html#_tessellation_pipeline_state">22.10. Tessellation Pipeline State</a></li>
</ul>
</li>
<li><a href="chap23.html">23. Geometry Shading</a>
<ul class="sectlevel2">
<li><a href="chap23.html#geometry-input">23.1. Geometry Shader Input Primitives</a></li>
<li><a href="chap23.html#geometry-output">23.2. Geometry Shader Output Primitives</a></li>
<li><a href="chap23.html#geometry-invocations">23.3. Multiple Invocations of Geometry Shaders</a></li>
<li><a href="chap23.html#geometry-ordering">23.4. Geometry Shader Primitive Ordering</a></li>
</ul>
</li>
<li><a href="chap24.html">24. Fixed-Function Vertex Post-Processing</a>
<ul class="sectlevel2">
<li><a href="chap24.html#vertexpostproc-flatshading">24.1. Flat Shading</a></li>
<li><a href="chap24.html#vertexpostproc-clipping">24.2. Primitive Clipping</a></li>
<li><a href="chap24.html#vertexpostproc-clipping-shader-outputs">24.3. Clipping Shader Outputs</a></li>
<li><a href="chap24.html#vertexpostproc-coord-transform">24.4. Coordinate Transformations</a></li>
<li><a href="chap24.html#vertexpostproc-viewport">24.5. Controlling the Viewport</a></li>
</ul>
</li>
<li><a href="chap25.html">25. Rasterization</a>
<ul class="sectlevel2">
<li><a href="chap25.html#primsrast-discard">25.1. Discarding Primitives Before Rasterization</a></li>
<li><a href="chap25.html#primrast-order">25.2. Rasterization Order</a></li>
<li><a href="chap25.html#primsrast-multisampling">25.3. Multisampling</a></li>
<li><a href="chap25.html#primsrast-fragment-shading-rate">25.4. Fragment Shading Rates</a></li>
<li><a href="chap25.html#primsrast-sampleshading">25.5. Sample Shading</a></li>
<li><a href="chap25.html#primsrast-points">25.6. Points</a></li>
<li><a href="chap25.html#primsrast-lines">25.7. Line Segments</a></li>
<li><a href="chap25.html#primsrast-polygons">25.8. Polygons</a></li>
</ul>
</li>
<li><a href="chap26.html">26. Fragment Operations</a>
<ul class="sectlevel2">
<li><a href="chap26.html#fragops-scissor">26.1. Scissor Test</a></li>
<li><a href="chap26.html#fragops-samplemask">26.2. Sample Mask Test</a></li>
<li><a href="chap26.html#fragops-covg">26.3. Multisample Coverage</a></li>
<li><a href="chap26.html#fragops-ds-state">26.4. Depth and Stencil Operations</a></li>
<li><a href="chap26.html#fragops-dbt">26.5. Depth Bounds Test</a></li>
<li><a href="chap26.html#fragops-stencil">26.6. Stencil Test</a></li>
<li><a href="chap26.html#fragops-depth">26.7. Depth Test</a></li>
<li><a href="chap26.html#fragops-samplecount">26.8. Sample Counting</a></li>
<li><a href="chap26.html#fragops-coverage-reduction">26.9. Coverage Reduction</a></li>
</ul>
</li>
<li><a href="chap27.html">27. The Framebuffer</a>
<ul class="sectlevel2">
<li><a href="chap27.html#framebuffer-blending">27.1. Blending</a></li>
<li><a href="chap27.html#framebuffer-logicop">27.2. Logical Operations</a></li>
<li><a href="chap27.html#framebuffer-color-write-mask">27.3. Color Write Mask</a></li>
</ul>
</li>
<li><a href="chap28.html">28. Dispatching Commands</a></li>
<li><a href="chap29.html">29. Sparse Resources</a>
<ul class="sectlevel2">
<li><a href="chap29.html#sparsememory-sparseresourcefeatures">29.1. Sparse Resource Features</a></li>
<li><a href="chap29.html#sparsememory-fully-resident">29.2. Sparse Buffers and Fully-Resident Images</a></li>
<li><a href="chap29.html#sparsememory-partially-resident-buffers">29.3. Sparse Partially-Resident Buffers</a></li>
<li><a href="chap29.html#sparsememory-partially-resident-images">29.4. Sparse Partially-Resident Images</a></li>
<li><a href="chap29.html#sparsememory-sparse-memory-aliasing">29.5. Sparse Memory Aliasing</a></li>
<li><a href="chap29.html#_sparse_resource_implementation_guidelines_informative">29.6. Sparse Resource Implementation Guidelines (Informative)</a></li>
<li><a href="chap29.html#sparsememory-resourceapi">29.7. Sparse Resource API</a></li>
</ul>
</li>
<li><a href="chap30.html">30. Window System Integration (WSI)</a>
<ul class="sectlevel2">
<li><a href="chap30.html#_wsi_platform">30.1. WSI Platform</a></li>
<li><a href="chap30.html#_wsi_surface">30.2. WSI Surface</a></li>
<li><a href="chap30.html#display">30.3. Presenting Directly to Display Devices</a></li>
<li><a href="chap30.html#_querying_for_wsi_support">30.4. Querying for WSI Support</a></li>
<li><a href="chap30.html#_surface_queries">30.5. Surface Queries</a></li>
<li><a href="chap30.html#_device_group_queries">30.6. Device Group Queries</a></li>
<li><a href="chap30.html#_wsi_swapchain">30.7. WSI Swapchain</a></li>
</ul>
</li>
<li><a href="chap31.html">31. Deferred Host Operations</a>
<ul class="sectlevel2">
<li><a href="chap31.html#deferred-host-operations-requesting">31.1. Requesting Deferral</a></li>
<li><a href="chap31.html#_deferred_host_operations_api">31.2. Deferred Host Operations API</a></li>
</ul>
</li>
<li><a href="chap32.html">32. Acceleration Structures</a>
<ul class="sectlevel2">
<li><a href="chap32.html#acceleration-structure-def">32.1. Acceleration Structures</a></li>
<li><a href="chap32.html#host-acceleration-structure">32.2. Host Acceleration Structure Operations</a></li>
</ul>
</li>
<li><a href="chap33.html">33. Ray Traversal</a>
<ul class="sectlevel2">
<li><a href="chap33.html#ray-intersection-candidate-determination">33.1. Ray Intersection Candidate Determination</a></li>
<li><a href="chap33.html#ray-intersection-culling">33.2. Ray Intersection Culling</a></li>
<li><a href="chap33.html#ray-intersection-confirmation">33.3. Ray Intersection Confirmation</a></li>
<li><a href="chap33.html#ray-closest-hit-determination">33.4. Ray Closest Hit Determination</a></li>
<li><a href="chap33.html#ray-result-determination">33.5. Ray Result Determination</a></li>
</ul>
</li>
<li><a href="chap34.html">34. Ray Tracing</a>
<ul class="sectlevel2">
<li><a href="chap34.html#ray-tracing-shader-call">34.1. Shader Call Instructions</a></li>
<li><a href="chap34.html#ray-tracing-commands">34.2. Ray Tracing Commands</a></li>
<li><a href="chap34.html#shader-binding-table">34.3. Shader Binding Table</a></li>
<li><a href="chap34.html#ray-tracing-pipeline-stack">34.4. Ray Tracing Pipeline Stack</a></li>
</ul>
</li>
<li><a href="chap35.html">35. Video Decode and Encode Operations</a>
<ul class="sectlevel2">
<li><a href="chap35.html#_technical_terminology_and_semantics">35.1. Technical Terminology and Semantics</a></li>
<li><a href="chap35.html#_introduction">35.2. Introduction</a></li>
<li><a href="chap35.html#video-physical-device-capabilities">35.3. Video Physical Device Capabilities</a></li>
<li><a href="chap35.html#video-session-objects">35.4. Video Session Objects</a></li>
<li><a href="chap35.html#video-decode-operations">35.5. Video Decode Operations</a></li>
<li><a href="chap35.html#video-encode-operations">35.6. Video Encode Operations</a></li>
</ul>
</li>
<li><a href="chap36.html">36. Extending Vulkan</a>
<ul class="sectlevel2">
<li><a href="chap36.html#extendingvulkan-instanceanddevicefunctionality">36.1. Instance and Device Functionality</a></li>
<li><a href="chap36.html#extendingvulkan-coreversions">36.2. Core Versions</a></li>
<li><a href="chap36.html#extendingvulkan-layers">36.3. Layers</a></li>
<li><a href="chap36.html#extendingvulkan-extensions">36.4. Extensions</a></li>
<li><a href="chap36.html#extendingvulkan-extensions-extensiondependencies">36.5. Extension Dependencies</a></li>
<li><a href="chap36.html#_compatibility_guarantees_informative">36.6. Compatibility Guarantees (Informative)</a></li>
</ul>
</li>
<li><a href="chap37.html">37. Features</a>
<ul class="sectlevel2">
<li><a href="chap37.html#features-requirements">37.1. Feature Requirements</a></li>
</ul>
</li>
<li><a href="chap38.html">38. Limits</a>
<ul class="sectlevel2">
<li><a href="chap38.html#limits-minmax">38.1. Limit Requirements</a></li>
</ul>
</li>
<li><a href="chap39.html">39. Formats</a>
<ul class="sectlevel2">
<li><a href="chap39.html#formats-definition">39.1. Format Definition</a></li>
<li><a href="chap39.html#formats-properties">39.2. Format Properties</a></li>
<li><a href="chap39.html#features-required-format-support">39.3. Required Format Support</a></li>
</ul>
</li>
<li><a href="chap40.html">40. Additional Capabilities</a>
<ul class="sectlevel2">
<li><a href="chap40.html#capabilities-image">40.1. Additional Image Capabilities</a></li>
<li><a href="chap40.html#capabilities-buffer">40.2. Additional Buffer Capabilities</a></li>
<li><a href="chap40.html#capabilities-semaphore">40.3. Optional Semaphore Capabilities</a></li>
<li><a href="chap40.html#capabilities-fence">40.4. Optional Fence Capabilities</a></li>
</ul>
</li>
<li><a href="chap41.html">41. Debugging</a></li>
<li><a href="chap42.html">Appendix A: Vulkan Environment for SPIR-V</a>
<ul class="sectlevel2">
<li><a href="chap42.html#_versions_and_formats">Versions and Formats</a></li>
<li><a href="chap42.html#spirvenv-capabilities">Capabilities</a></li>
<li><a href="chap42.html#spirvenv-module-validation">Validation Rules within a Module</a></li>
<li><a href="chap42.html#spirvenv-precision-operation">Precision and Operation of SPIR-V Instructions</a></li>
<li><a href="chap42.html#spirvenv-image-signedness">Signedness of SPIR-V Image Accesses</a></li>
<li><a href="chap42.html#spirvenv-format-type-matching">Image Format and Type Matching</a></li>
<li><a href="chap42.html#spirvenv-image-formats">Compatibility Between SPIR-V Image Formats And Vulkan Formats</a></li>
</ul>
</li>
<li class="current"><a href="chap43.html">Appendix B: Memory Model</a>
<ul class="sectlevel2">
<li class="current"><a href="chap43.html#memory-model-agent">Agent</a></li>
<li class="current"><a href="chap43.html#memory-model-memory-location">Memory Location</a></li>
<li class="current"><a href="chap43.html#memory-model-allocation">Allocation</a></li>
<li class="current"><a href="chap43.html#memory-model-memory-operation">Memory Operation</a></li>
<li class="current"><a href="chap43.html#memory-model-references">Reference</a></li>
<li class="current"><a href="chap43.html#memory-model-program-order">Program-Order</a></li>
<li class="current"><a href="chap43.html#shader-call-related">Shader Call Related</a></li>
<li class="current"><a href="chap43.html#shader-call-order">Shader Call Order</a></li>
<li class="current"><a href="chap43.html#memory-model-scope">Scope</a></li>
<li class="current"><a href="chap43.html#memory-model-atomic-operation">Atomic Operation</a></li>
<li class="current"><a href="chap43.html#memory-model-scoped-modification-order">Scoped Modification Order</a></li>
<li class="current"><a href="chap43.html#memory-model-memory-semantics">Memory Semantics</a></li>
<li class="current"><a href="chap43.html#memory-model-release-sequence">Release Sequence</a></li>
<li class="current"><a href="chap43.html#memory-model-synchronizes-with">Synchronizes-With</a></li>
<li class="current"><a href="chap43.html#memory-model-system-synchronizes-with">System-Synchronizes-With</a></li>
<li class="current"><a href="chap43.html#memory-model-non-private">Private vs. Non-Private</a></li>
<li class="current"><a href="chap43.html#memory-model-inter-thread-happens-before">Inter-Thread-Happens-Before</a></li>
<li class="current"><a href="chap43.html#memory-model-happens-before">Happens-Before</a></li>
<li class="current"><a href="chap43.html#memory-model-availability-visibility">Availability and Visibility</a></li>
<li class="current"><a href="chap43.html#memory-model-vulkan-availability-visibility">Availability, Visibility, and Domain Operations</a></li>
<li class="current"><a href="chap43.html#memory-model-availability-visibility-semantics">Availability and Visibility Semantics</a></li>
<li class="current"><a href="chap43.html#memory-model-instruction-av-vis">Per-Instruction Availability and Visibility Semantics</a></li>
<li class="current"><a href="chap43.html#memory-model-location-ordered">Location-Ordered</a></li>
<li class="current"><a href="chap43.html#memory-model-access-data-race">Data Race</a></li>
<li class="current"><a href="chap43.html#memory-model-visible-to">Visible-To</a></li>
<li class="current"><a href="chap43.html#memory-model-acyclicity">Acyclicity</a></li>
<li class="current"><a href="chap43.html#memory-model-shader-io">Shader I/O</a></li>
<li class="current"><a href="chap43.html#memory-model-deallocation">Deallocation</a></li>
<li class="current"><a href="chap43.html#memory-model-informative-descriptions">Descriptions (Informative)</a></li>
<li class="current"><a href="chap43.html#memory-model-tessellation-output-ordering">Tessellation Output Ordering</a></li>
</ul>
</li>
<li><a href="chap44.html">Appendix C: Compressed Image Formats</a>
<ul class="sectlevel2">
<li><a href="chap44.html#appendix-compressedtex-bc">Block-Compressed Image Formats</a></li>
<li><a href="chap44.html#appendix-compressedtex-etc2">ETC Compressed Image Formats</a></li>
<li><a href="chap44.html#appendix-compressedtex-astc">ASTC Compressed Image Formats</a></li>
</ul>
</li>
<li><a href="chap45.html">Appendix D: Core Revisions (Informative)</a>
<ul class="sectlevel2">
<li><a href="chap45.html#versions-1.2">Version 1.2</a></li>
<li><a href="chap45.html#versions-1.1">Version 1.1</a></li>
</ul>
</li>
<li><a href="chap46.html">Appendix E: Layers &amp; Extensions (Informative)</a>
<ul class="sectlevel2">
<li><a href="chap46.html#extension-appendices-list">List of Current Extensions</a></li>
<li><a href="chap46.html#provisional-extension-appendices-list">List of Provisional Extensions</a></li>
<li><a href="chap46.html#deprecated-extension-appendices-list">List of Deprecated Extensions</a></li>
</ul>
</li>
<li><a href="chap47.html">Appendix F: API Boilerplate</a>
<ul class="sectlevel2">
<li><a href="chap47.html#boilerplate-headers">Vulkan Header Files</a></li>
<li><a href="chap47.html#boilerplate-wsi-header">Window System-Specific Header Control (Informative)</a></li>
<li><a href="chap47.html#boilerplate-provisional-header">Provisional Extension Header Control (Informative)</a></li>
</ul>
</li>
<li><a href="chap48.html">Appendix G: Invariance</a>
<ul class="sectlevel2">
<li><a href="chap48.html#_repeatability">Repeatability</a></li>
<li><a href="chap48.html#_multi_pass_algorithms">Multi-pass Algorithms</a></li>
<li><a href="chap48.html#_invariance_rules">Invariance Rules</a></li>
<li><a href="chap48.html#_tessellation_invariance">Tessellation Invariance</a></li>
</ul>
</li>
<li><a href="chap49.html">Appendix H: Lexicon</a>
<ul class="sectlevel2">
<li><a href="chap49.html#glossary">Glossary</a></li>
<li><a href="chap49.html#lexicon-common-abbreviations">Common Abbreviations</a></li>
<li><a href="chap49.html#lexicon-prefixes">Prefixes</a></li>
</ul>
</li>
<li><a href="chap50.html">Appendix I: Credits (Informative)</a>
<ul class="sectlevel2">
<li><a href="chap50.html#_working_group_contributors_to_vulkan">Working Group Contributors to Vulkan</a></li>
<li><a href="chap50.html#_other_credits">Other Credits</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="loading_msg" class="hidden" hidden=""><p>Loading… please wait.</p></div>
<!--ChunkedSearchboxMarker-->
<div class="searchbox"><label for="searchbox">Search: </label><input id="searchbox" type="text" disabled="disabled" value="Loading Search Data"><div id="resultsdiv"><ol id="results"></ol></div></div>
<div id="content" class="loadable" style="max-width: 100%;"><div class="sect1">
<h2 id="memory-model"><a class="anchor" href="chap43.html"></a>Appendix B: Memory Model</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="memory-model-agent"><a class="anchor" href="chap43.html#memory-model-agent"></a>Agent</h3>
<div class="paragraph">
<p><em>Operation</em> is a general term for any task that is executed on the system.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>An operation is by definition something that is executed.
Thus if an instruction is skipped due to control flow, it does not
constitute an operation.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Each operation is executed by a particular <em>agent</em>.
Possible agents include each shader invocation, each host thread, and each
fixed-function stage of the pipeline.</p>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-memory-location"><a class="anchor" href="chap43.html#memory-model-memory-location"></a>Memory Location</h3>
<div class="paragraph">
<p>A <em>memory location</em> identifies unique storage for 8 bits of data.
Memory operations access a <em>set of memory locations</em> consisting of one or
more memory locations at a time, e.g. an operation accessing a 32-bit
integer in memory would read/write a set of four memory locations.
Memory operations that access whole aggregates <strong class="purple">may</strong> access any padding bytes
between elements or members, but no padding bytes at the end of the
aggregate.
Two sets of memory locations <em>overlap</em> if the intersection of their sets of
memory locations is non-empty.
A memory operation <strong class="purple">must</strong> not affect memory at a memory location not within
its set of memory locations.</p>
</div>
<div class="paragraph">
<p>Memory locations for buffers and images are explicitly allocated in
<a href="chap11.html#VkDeviceMemory">VkDeviceMemory</a> objects, and are implicitly allocated for SPIR-V
variables in each shader invocation.</p>
</div>
<div class="paragraph">
<p>Variables with <code>Workgroup</code> storage class that point to a block-decorated
type share a set of memory locations.</p>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-allocation"><a class="anchor" href="chap43.html#memory-model-allocation"></a>Allocation</h3>
<div class="paragraph">
<p>The values stored in newly allocated memory locations are determined by a
SPIR-V variable’s initializer, if present, or else are undefined.
At the time an allocation is created there have been no
<a href="chap43.html#memory-model-memory-operation">memory operations</a> to any of its memory
locations.
The initialization is not considered to be a memory operation.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>For tessellation control shader output variables, a consequence of
initialization not being considered a memory operation is that some
implementations may need to insert a barrier between the initialization of
the output variables and any reads of those variables.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-memory-operation"><a class="anchor" href="chap43.html#memory-model-memory-operation"></a>Memory Operation</h3>
<div class="paragraph">
<p>For an operation A and memory location M:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="memory-model-access-read"></a> A <em>reads</em> M if and only if the data stored
in M is an input to A.</p>
</li>
<li>
<p><a id="memory-model-access-write"></a> A <em>writes</em> M if and only if the data
output from A is stored to M.</p>
</li>
<li>
<p><a id="memory-model-access-access"></a> A <em>accesses</em> M if and only if it either
reads or writes (or both) M.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>A write whose value is the same as what was already in those memory
locations is still considered to be a write and has all the same effects.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-references"><a class="anchor" href="chap43.html#memory-model-references"></a>Reference</h3>
<div class="paragraph">
<p>A <em>reference</em> is an object that a particular agent <strong class="purple">can</strong> use to access a set
of memory locations.
On the host, a reference is a host virtual address.
On the device, a reference is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The descriptor that a variable is bound to, for variables in Image,
Uniform, or StorageBuffer storage classes.
If the variable is an array (or array of arrays, etc.) then each element
of the array <strong class="purple">may</strong> be a unique reference.</p>
</li>
<li>
<p>The address range for a buffer in <code>PhysicalStorageBuffer</code> storage
class, where the base of the address range is queried with
<a href="chap14.html#vkGetBufferDeviceAddress">vkGetBufferDeviceAddress</a>
and the length of the range is the size of the buffer.</p>
</li>
<li>
<p>A single common reference for all variables with <code>Workgroup</code> storage
class that point to a block-decorated type.</p>
</li>
<li>
<p>The variable itself for non-block-decorated type variables in
<code>Workgroup</code> storage class.</p>
</li>
<li>
<p>The variable itself for variables in other storage classes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Two memory accesses through distinct references <strong class="purple">may</strong> require availability
and visibility operations as defined
<a href="chap43.html#memory-model-location-ordered">below</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-program-order"><a class="anchor" href="chap43.html#memory-model-program-order"></a>Program-Order</h3>
<div class="paragraph">
<p>A <em>dynamic instance</em> of an instruction is defined in SPIR-V
(<a href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#DynamicInstance" class="bare">https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#DynamicInstance</a>)
as a way of referring to a particular execution of a static instruction.
Program-order is an ordering on dynamic instances of instructions executed
by a single shader invocation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(Basic block): If instructions A and B are in the same basic block, and
A is listed in the module before B, then the n’th dynamic instance of A
is program-ordered before the n’th dynamic instance of B.</p>
</li>
<li>
<p>(Branch): The dynamic instance of a branch or switch instruction is
program-ordered before the dynamic instance of the OpLabel instruction
to which it transfers control.</p>
</li>
<li>
<p>(Call entry): The dynamic instance of an <code>OpFunctionCall</code> instruction
is program-ordered before the dynamic instances of the
<code>OpFunctionParameter</code> instructions and the body of the called
function.</p>
</li>
<li>
<p>(Call exit): The dynamic instance of the instruction following an
<code>OpFunctionCall</code> instruction is program-ordered after the dynamic
instance of the return instruction executed by the called function.</p>
</li>
<li>
<p>(Transitive Closure): If dynamic instance A of any instruction is
program-ordered before dynamic instance B of any instruction and B is
program-ordered before dynamic instance C of any instruction then A is
program-ordered before C.</p>
</li>
<li>
<p>(Complete definition): No other dynamic instances are program-ordered.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For instructions executed on the host, the source language defines the
program-order relation (e.g. as “sequenced-before”).</p>
</div>
</div>
<div class="sect2">
<h3 id="shader-call-related"><a class="anchor" href="chap43.html#shader-call-related"></a>Shader Call Related</h3>
<div class="paragraph">
<p>Shader-call-related is an equivalence relation on invocations defined as the
symmetric and transitive closure of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A is shader-call-related to B if A is created by an
<a href="chap34.html#ray-tracing-repack">invocation repack</a> instruction executed by B.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="shader-call-order"><a class="anchor" href="chap43.html#shader-call-order"></a>Shader Call Order</h3>
<div class="paragraph">
<p>Shader-call-order is a partial order on dynamic instances of instructions
executed by invocations that are shader-call-related:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(Program order): If dynamic instance A is program-ordered before B, then
A is shader-call-ordered before B.</p>
</li>
<li>
<p>(Shader call entry): If A is a dynamic instance of an
<a href="chap34.html#ray-tracing-repack">invocation repack</a> instruction and B is a dynamic
instance executed by an invocation that is created by A, then A is
shader-call-ordered before B.</p>
</li>
<li>
<p>(Shader call exit): If A is a dynamic instance of an
<a href="chap34.html#ray-tracing-repack">invocation repack</a> instruction, B is the next
dynamic instance executed by the same invocation, and C is a dynamic
instance executed by an invocation that is created by A, then C is
shader-call-ordered before B.</p>
</li>
<li>
<p>(Transitive closure): If A is shader-call-ordered-before B and B is
shader-call-ordered-before C, then A is shader-call-ordered-before C.</p>
</li>
<li>
<p>(Complete definition): No other dynamic instances are
shader-call-ordered.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-scope"><a class="anchor" href="chap43.html#memory-model-scope"></a>Scope</h3>
<div class="paragraph">
<p>Atomic and barrier instructions include scopes which identify sets of shader
invocations that <strong class="purple">must</strong> obey the requested ordering and atomicity rules of
the operation, as defined below.</p>
</div>
<div class="paragraph">
<p>The various scopes are described in detail in <a href="chap9.html#shaders-scope">the Shaders
chapter</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-atomic-operation"><a class="anchor" href="chap43.html#memory-model-atomic-operation"></a>Atomic Operation</h3>
<div class="paragraph">
<p>An <em>atomic operation</em> on the device is any SPIR-V operation whose name
begins with <code>OpAtomic</code>.
An atomic operation on the host is any operation performed with an
std::atomic typed object.</p>
</div>
<div class="paragraph">
<p>Each atomic operation has a memory <a href="chap43.html#memory-model-scope">scope</a> and a
<a href="chap43.html#memory-model-memory-semantics">semantics</a>.
Informally, the scope determines which other agents it is atomic with
respect to, and the <a href="chap43.html#memory-model-memory-semantics">semantics</a> constrains
its ordering against other memory accesses.
Device atomic operations have explicit scopes and semantics.
Each host atomic operation implicitly uses the <code>CrossDevice</code> scope, and
uses a memory semantics equivalent to a C++ std::memory_order value of
relaxed, acquire, release, acq_rel, or seq_cst.</p>
</div>
<div class="paragraph">
<p>Two atomic operations A and B are <em>potentially-mutually-ordered</em> if and only
if all of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>They access the same set of memory locations.</p>
</li>
<li>
<p>They use the same reference.</p>
</li>
<li>
<p>A is in the instance of B’s memory scope.</p>
</li>
<li>
<p>B is in the instance of A’s memory scope.</p>
</li>
<li>
<p>A and B are not the same operation (irreflexive).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Two atomic operations A and B are <em>mutually-ordered</em> if and only if they are
potentially-mutually-ordered and any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A and B are both device operations.</p>
</li>
<li>
<p>A and B are both host operations.</p>
</li>
<li>
<p>A is a device operation, B is a host operation, and the implementation
supports concurrent host- and device-atomics.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>If two atomic operations are not mutually-ordered, and if their sets of
memory locations overlap, then each <strong class="purple">must</strong> be synchronized against the other
as if they were non-atomic operations.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-scoped-modification-order"><a class="anchor" href="chap43.html#memory-model-scoped-modification-order"></a>Scoped Modification Order</h3>
<div class="paragraph">
<p>For a given atomic write A, all atomic writes that are mutually-ordered with
A occur in an order known as A’s <em>scoped modification order</em>.
A’s scoped modification order relates no other operations.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Invocations outside the instance of A’s memory scope <strong class="purple">may</strong> observe the values
at A’s set of memory locations becoming visible to it in an order that
disagrees with the scoped modification order.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>It is valid to have non-atomic operations or atomics in a different scope
instance to the same set of memory locations, as long as they are
synchronized against each other as if they were non-atomic (if they are not,
it is treated as a <a href="chap43.html#memory-model-access-data-race">data race</a>).
That means this definition of A’s scoped modification order could include
atomic operations that occur much later, after intervening non-atomics.
That is a bit non-intuitive, but it helps to keep this definition simple and
non-circular.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-memory-semantics"><a class="anchor" href="chap43.html#memory-model-memory-semantics"></a>Memory Semantics</h3>
<div class="paragraph">
<p>Non-atomic memory operations, by default, <strong class="purple">may</strong> be observed by one agent in a
different order than they were written by another agent.</p>
</div>
<div class="paragraph">
<p>Atomics and some synchronization operations include <em>memory semantics</em>,
which are flags that constrain the order in which other memory accesses
(including non-atomic memory accesses and
<a href="chap43.html#memory-model-availability-visibility">availability and visibility
operations</a>) performed by the same agent <strong class="purple">can</strong> be observed by other agents,
or <strong class="purple">can</strong> observe accesses by other agents.</p>
</div>
<div class="paragraph">
<p>Device instructions that include semantics are <code>OpAtomic*</code>,
<code>OpControlBarrier</code>, <code>OpMemoryBarrier</code>, and <code>OpMemoryNamedBarrier</code>.
Host instructions that include semantics are some std::atomic methods and
memory fences.</p>
</div>
<div class="paragraph">
<p>SPIR-V supports the following memory semantics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Relaxed: No constraints on order of other memory accesses.</p>
</li>
<li>
<p>Acquire: A memory read with this semantic performs an <em>acquire
operation</em>.
A memory barrier with this semantic is an <em>acquire barrier</em>.</p>
</li>
<li>
<p>Release: A memory write with this semantic performs a <em>release
operation</em>.
A memory barrier with this semantic is a <em>release barrier</em>.</p>
</li>
<li>
<p>AcquireRelease: A memory read-modify-write operation with this semantic
performs both an acquire operation and a release operation, and inherits
the limitations on ordering from both of those operations.
A memory barrier with this semantic is both a release and acquire
barrier.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>SPIR-V does not support “consume” semantics on the device.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>The memory semantics operand also includes <em>storage class semantics</em> which
indicate which storage classes are constrained by the synchronization.
SPIR-V storage class semantics include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>UniformMemory</p>
</li>
<li>
<p>WorkgroupMemory</p>
</li>
<li>
<p>ImageMemory</p>
</li>
<li>
<p>OutputMemory</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each SPIR-V memory operation accesses a single storage class.
Semantics in synchronization operations can include a combination of storage
classes.</p>
</div>
<div class="paragraph">
<p>The UniformMemory storage class semantic applies to accesses to memory in
the
PhysicalStorageBuffer,
<code>ShaderRecordBufferKHR</code>,
Uniform and StorageBuffer storage classes.
The WorkgroupMemory storage class semantic applies to accesses to memory in
the Workgroup storage class.
The ImageMemory storage class semantic applies to accesses to memory in the
Image storage class.
The OutputMemory storage class semantic applies to accesses to memory in the
Output storage class.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Informally, these constraints limit how memory operations can be reordered,
and these limits apply not only to the order of accesses as performed in the
agent that executes the instruction, but also to the order the effects of
writes become visible to all other agents within the same instance of the
instruction’s memory scope.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Release and acquire operations in different threads <strong class="purple">can</strong> act as
synchronization operations, to guarantee that writes that happened before
the release are visible after the acquire.
(This is not a formal definition, just an Informative forward reference.)</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>The OutputMemory storage class semantic is only useful in tessellation
control shaders, which is the only execution model where output variables
are shared between invocations.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>The memory semantics operand also optionally includes availability and
visibility flags, which apply optional availability and visibility
operations as described in
<a href="chap43.html#memory-model-availability-visibility">availability and visibility</a>.
The availability/visibility flags are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>MakeAvailable: Semantics <strong class="purple">must</strong> be Release or AcquireRelease.
Performs an availability operation before the release operation or
barrier.</p>
</li>
<li>
<p>MakeVisible: Semantics <strong class="purple">must</strong> be Acquire or AcquireRelease.
Performs a visibility operation after the acquire operation or barrier.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The specifics of these operations are defined in
<a href="chap43.html#memory-model-availability-visibility-semantics">Availability and Visibility
Semantics</a>.</p>
</div>
<div class="paragraph">
<p>Host atomic operations <strong class="purple">may</strong> support a different list of memory semantics and
synchronization operations, depending on the host architecture and source
language.</p>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-release-sequence"><a class="anchor" href="chap43.html#memory-model-release-sequence"></a>Release Sequence</h3>
<div class="paragraph">
<p>After an atomic operation A performs a release operation on a set of memory
locations M, the <em>release sequence headed by A</em> is the longest continuous
subsequence of A’s scoped modification order that consists of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the atomic operation A as its first element</p>
</li>
<li>
<p>atomic read-modify-write operations on M by any agent</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>The atomics in the last bullet <strong class="purple">must</strong> be mutually-ordered with A by virtue of
being in A’s scoped modification order.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>This intentionally omits “atomic writes to M performed by the same agent
that performed A”, which is present in the corresponding C++ definition.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-synchronizes-with"><a class="anchor" href="chap43.html#memory-model-synchronizes-with"></a>Synchronizes-With</h3>
<div class="paragraph">
<p><em>Synchronizes-with</em> is a relation between operations, where each operation
is either an atomic operation or a memory barrier (aka fence on the host).</p>
</div>
<div class="paragraph">
<p>If A and B are atomic operations, then A synchronizes-with B if and only if
all of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A performs a release operation</p>
</li>
<li>
<p>B performs an acquire operation</p>
</li>
<li>
<p>A and B are mutually-ordered</p>
</li>
<li>
<p>B reads a value written by A or by an operation in the release sequence
headed by A</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>OpControlBarrier</code>, <code>OpMemoryBarrier</code>, and <code>OpMemoryNamedBarrier</code>
are <em>memory barrier</em> instructions in SPIR-V.</p>
</div>
<div class="paragraph">
<p>If A is a release barrier and B is an atomic operation that performs an
acquire operation, then A synchronizes-with B if and only if all of the
following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>there exists an atomic write X (with any memory semantics)</p>
</li>
<li>
<p>A is program-ordered before X</p>
</li>
<li>
<p>X and B are mutually-ordered</p>
</li>
<li>
<p>B reads a value written by X or by an operation in the release sequence
headed by X</p>
<div class="ulist">
<ul>
<li>
<p>If X is relaxed, it is still considered to head a hypothetical release
sequence for this rule</p>
</li>
</ul>
</div>
</li>
<li>
<p>A and B are in the instance of each other’s memory scopes</p>
</li>
<li>
<p>X’s storage class is in A’s semantics.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If A is an atomic operation that performs a release operation and B is an
acquire barrier, then A synchronizes-with B if and only if all of the
following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>there exists an atomic read X (with any memory semantics)</p>
</li>
<li>
<p>X is program-ordered before B</p>
</li>
<li>
<p>X and A are mutually-ordered</p>
</li>
<li>
<p>X reads a value written by A or by an operation in the release sequence
headed by A</p>
</li>
<li>
<p>A and B are in the instance of each other’s memory scopes</p>
</li>
<li>
<p>X’s storage class is in B’s semantics.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If A is a release barrier and B is an acquire barrier, then A
synchronizes-with B if all of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>there exists an atomic write X (with any memory semantics)</p>
</li>
<li>
<p>A is program-ordered before X</p>
</li>
<li>
<p>there exists an atomic read Y (with any memory semantics)</p>
</li>
<li>
<p>Y is program-ordered before B</p>
</li>
<li>
<p>X and Y are mutually-ordered</p>
</li>
<li>
<p>Y reads the value written by X or by an operation in the release
sequence headed by X</p>
<div class="ulist">
<ul>
<li>
<p>If X is relaxed, it is still considered to head a hypothetical release
sequence for this rule</p>
</li>
</ul>
</div>
</li>
<li>
<p>A and B are in the instance of each other’s memory scopes</p>
</li>
<li>
<p>X’s and Y’s storage class is in A’s and B’s semantics.</p>
<div class="ulist">
<ul>
<li>
<p>NOTE: X and Y must have the same storage class, because they are
mutually ordered.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If A is a release barrier and B is an acquire barrier and C is a control
barrier (where A can optionally equal C and B can optionally equal C), then
A synchronizes-with B if all of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A is program-ordered before (or equals) C</p>
</li>
<li>
<p>C is program-ordered before (or equals) B</p>
</li>
<li>
<p>A and B are in the instance of each other’s memory scopes</p>
</li>
<li>
<p>A and B are in the instance of C’s execution scope</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>This is similar to the barrier-barrier synchronization above, but with a
control barrier filling the role of the relaxed atomics.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>If A is a release barrier and B is an acquire barrier, then A
synchronizes-with B if all of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A is shader-call-ordered-before B</p>
</li>
<li>
<p>A and B are in the instance of each other’s memory scopes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>No other release and acquire barriers synchronize-with each other.</p>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-system-synchronizes-with"><a class="anchor" href="chap43.html#memory-model-system-synchronizes-with"></a>System-Synchronizes-With</h3>
<div class="paragraph">
<p><em>System-synchronizes-with</em> is a relation between arbitrary operations on the
device or host.
Certain operations system-synchronize-with each other, which informally
means the first operation occurs before the second and that the
synchronization is performed without using application-visible memory
accesses.</p>
</div>
<div class="paragraph">
<p>If there is an <a href="chap7.html#synchronization-dependencies-execution">execution
dependency</a> between two operations A and B, then the operation in the first
synchronization scope system-synchronizes-with the operation in the second
synchronization scope.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>This covers all Vulkan synchronization primitives, including device
operations executing before a synchronization primitive is signaled, wait
operations happening before subsequent device operations, signal operations
happening before host operations that wait on them, and host operations
happening before <a href="chap6.html#vkQueueSubmit">vkQueueSubmit</a>.
The list is spread throughout the synchronization chapter, and is not
repeated here.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>System-synchronizes-with implicitly includes all storage class semantics and
has <code>CrossDevice</code> scope.</p>
</div>
<div class="paragraph">
<p>If A system-synchronizes-with B, we also say A is
<em>system-synchronized-before</em> B and B is <em>system-synchronized-after</em> A.</p>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-non-private"><a class="anchor" href="chap43.html#memory-model-non-private"></a>Private vs. Non-Private</h3>
<div class="paragraph">
<p>By default, non-atomic memory operations are treated as <em>private</em>, meaning
such a memory operation is not intended to be used for communication with
other agents.
Memory operations with the NonPrivatePointer/NonPrivateTexel bit set are
treated as <em>non-private</em>, and are intended to be used for communication with
other agents.</p>
</div>
<div class="paragraph">
<p>More precisely, for private memory operations to be
<a href="chap43.html#memory-model-location-ordered">Location-Ordered</a> between distinct agents
requires using system-synchronizes-with rather than shader-based
synchronization.
Non-private memory operations still obey program-order.</p>
</div>
<div class="paragraph">
<p>Atomic operations are always considered non-private.</p>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-inter-thread-happens-before"><a class="anchor" href="chap43.html#memory-model-inter-thread-happens-before"></a>Inter-Thread-Happens-Before</h3>
<div class="paragraph">
<p>Let SC be a non-empty set of storage class semantics.
Then (using template syntax) operation A <em>inter-thread-happens-before</em>&lt;SC&gt;
operation B if and only if any of the following is true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A system-synchronizes-with B</p>
</li>
<li>
<p>A synchronizes-with B, and both A and B have all of SC in their
semantics</p>
</li>
<li>
<p>A is an operation on memory in a storage class in SC or that has all of
SC in its semantics, B is a release barrier or release atomic with all
of SC in its semantics, and A is program-ordered before B</p>
</li>
<li>
<p>A is an acquire barrier or acquire atomic with all of SC in its
semantics, B is an operation on memory in a storage class in SC or that
has all of SC in its semantics, and A is program-ordered before B</p>
</li>
<li>
<p>A and B are both host operations and A inter-thread-happens-before B as
defined in the host language spec</p>
</li>
<li>
<p>A inter-thread-happens-before&lt;SC&gt; some X and X
inter-thread-happens-before&lt;SC&gt; B</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-happens-before"><a class="anchor" href="chap43.html#memory-model-happens-before"></a>Happens-Before</h3>
<div class="paragraph">
<p>Operation A <em>happens-before</em> operation B if and only if any of the following
is true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A is program-ordered before B</p>
</li>
<li>
<p>A inter-thread-happens-before&lt;SC&gt; B for some set of storage classes SC</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Happens-after</em> is defined similarly.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Unlike C++, happens-before is not always sufficient for a write to be
visible to a read.
Additional <a href="chap43.html#memory-model-availability-visibility">availability and
visibility</a> operations <strong class="purple">may</strong> be required for writes to be
<a href="chap43.html#memory-model-visible-to">visible-to</a> other memory accesses.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Happens-before is not transitive, but each of program-order and
inter-thread-happens-before&lt;SC&gt; are transitive.
These can be thought of as covering the “single-threaded” case and the
“multi-threaded” case, and it is not necessary (and not valid) to form
chains between the two.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-availability-visibility"><a class="anchor" href="chap43.html#memory-model-availability-visibility"></a>Availability and Visibility</h3>
<div class="paragraph">
<p><em>Availability</em> and <em>visibility</em> are states of a write operation, which
(informally) track how far the write has permeated the system, i.e. which
agents and references are able to observe the write.
Availability state is per <em>memory domain</em>.
Visibility state is per (agent,reference) pair.
Availability and visibility states are per-memory location for each write.</p>
</div>
<div class="paragraph">
<p>Memory domains are named according to the agents whose memory accesses use
the domain.
Domains used by shader invocations are organized hierarchically into
multiple smaller memory domains which correspond to the different
<a href="chap9.html#shaders-scope">scopes</a>.
Each memory domain is considered the <em>dual</em> of a scope, and vice versa.
The memory domains defined in Vulkan include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>host</em> - accessible by host agents</p>
</li>
<li>
<p><em>device</em> - accessible by all device agents for a particular device</p>
</li>
<li>
<p><em>shader</em> - accessible by shader agents for a particular device,
corresponding to the <code>Device</code> scope</p>
</li>
<li>
<p><em>queue family instance</em> - accessible by shader agents in a single queue
family, corresponding to the <code>QueueFamily</code> scope.</p>
</li>
<li>
<p><em>shader call instance</em> - accessible by shader agents that are
<a href="chap43.html#shader-call-related">shader-call-related</a>, corresponding to the
<code>ShaderCallKHR</code> scope.</p>
</li>
<li>
<p><em>workgroup instance</em> - accessible by shader agents in the same
workgroup, corresponding to the <code>Workgroup</code> scope.</p>
</li>
<li>
<p><em>subgroup instance</em> - accessible by shader agents in the same subgroup,
corresponding to the <code>Subgroup</code> scope.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The memory domains are nested in the order listed above,
except for shader call instance domain,
with memory domains later in the list nested in the domains earlier in the
list.
The shader call instance domain is at an implementation-dependent location
in the list, and is nested according to that location.
The shader call instance domain is not broader than the queue family
instance domain.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Memory domains do not correspond to storage classes or device-local and
host-local <a href="chap11.html#VkDeviceMemory">VkDeviceMemory</a> allocations, rather they indicate whether a
write can be made visible only to agents in the same subgroup, same
workgroup,
shader-call-related ray tracing invocation,
in any shader invocation, or anywhere on the device, or host.
The shader, queue family instance,
shader call instance,
workgroup instance, and subgroup instance domains are only used for
shader-based availability/visibility operatons, in other cases writes can be
made available from/visible to the shader via the device domain.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><em>Availability operations</em>, <em>visibility operations</em>, and <em>memory domain
operations</em> alter the state of the write operations that happen-before them,
and which are included in their <em>source scope</em> to be available or visible to
their <em>destination scope</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For an availability operation, the source scope is a set of
(agent,reference,memory location) tuples, and the destination scope is a
set of memory domains.</p>
</li>
<li>
<p>For a memory domain operation, the source scope is a memory domain and
the destination scope is a memory domain.</p>
</li>
<li>
<p>For a visibility operation, the source scope is a set of memory domains
and the destination scope is a set of (agent,reference,memory location)
tuples.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>How the scopes are determined depends on the specific operation.
Availability and memory domain operations expand the set of memory domains
to which the write is available.
Visibility operations expand the set of (agent,reference,memory location)
tuples to which the write is visible.</p>
</div>
<div class="paragraph">
<p>Recall that availability and visibility states are per-memory location, and
let W be a write operation to one or more locations performed by agent A via
reference R. Let L be one of the locations written.
(W,L) (the write W to L), is initially not available to any memory domain
and only visible to (A,R,L).
An availability operation AV that happens-after W and that includes (A,R,L)
in its source scope makes (W,L) <em>available</em> to the memory domains in its
destination scope.</p>
</div>
<div class="paragraph">
<p>A memory domain operation DOM that happens-after AV and for which (W,L) is
available in the source scope makes (W,L) available in the destination
memory domain.</p>
</div>
<div class="paragraph">
<p>A visibility operation VIS that happens-after AV (or DOM) and for which
(W,L) is available in any domain in the source scope makes (W,L) <em>visible</em>
to all (agent,reference,L) tuples included in its destination scope.</p>
</div>
<div class="paragraph">
<p>If write W<sub>2</sub> happens-after W, and their sets of memory locations overlap,
then W will not be available/visible to all agents/references for those
memory locations that overlap (and future AV/DOM/VIS ops cannot revive W’s
write to those locations).</p>
</div>
<div class="paragraph">
<p>Availability, memory domain, and visibility operations are treated like
other non-atomic memory accesses for the purpose of
<a href="chap43.html#memory-model-memory-semantics">memory semantics</a>, meaning they can be
ordered by release-acquire sequences or memory barriers.</p>
</div>
<div class="paragraph">
<p>An <em>availability chain</em> is a sequence of availability operations to
increasingly broad memory domains, where element N+1 of the chain is
performed in the dual scope instance of the destination memory domain of
element N and element N happens-before element N+1.
An example is an availability operation with destination scope of the
workgroup instance domain that happens-before an availability operation to
the shader domain performed by an invocation in the same workgroup.
An availability chain AVC that happens-after W and that includes (A,R,L) in
the source scope makes (W,L) <em>available</em> to the memory domains in its final
destination scope.
An availability chain with a single element is just the availability
operation.</p>
</div>
<div class="paragraph">
<p>Similarly, a <em>visibility chain</em> is a sequence of visibility operations from
increasingly narrow memory domains, where element N of the chain is
performed in the dual scope instance of the source memory domain of element
N+1 and element N happens-before element N+1.
An example is a visibility operation with source scope of the shader domain
that happens-before a visibility operation with source scope of the
workgroup instance domain performed by an invocation in the same workgroup.
A visibility chain VISC that happens-after AVC (or DOM) and for which (W,L)
is available in any domain in the source scope makes (W,L) <em>visible</em> to all
(agent,reference,L) tuples included in its final destination scope.
A visibility chain with a single element is just the visibility operation.</p>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-vulkan-availability-visibility"><a class="anchor" href="chap43.html#memory-model-vulkan-availability-visibility"></a>Availability, Visibility, and Domain Operations</h3>
<div class="paragraph">
<p>The following operations generate availability, visibility, and domain
operations.
When multiple availability/visibility/domain operations are described, they
are system-synchronized-with each other in the order listed.</p>
</div>
<div class="paragraph">
<p>An operation that performs a <a href="chap7.html#synchronization-dependencies-memory">memory
dependency</a> generates:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the source access mask includes <code>VK_ACCESS_HOST_WRITE_BIT</code>, then
the dependency includes a memory domain operation from host domain to
device domain.</p>
</li>
<li>
<p>An availability operation with source scope of all writes in the first
<a href="chap7.html#synchronization-dependencies-access-scopes">access scope</a> of the
dependency and a destination scope of the device domain.</p>
</li>
<li>
<p>A visibility operation with source scope of the device domain and
destination scope of the second access scope of the dependency.</p>
</li>
<li>
<p>If the destination access mask includes <code>VK_ACCESS_HOST_READ_BIT</code> or
<code>VK_ACCESS_HOST_WRITE_BIT</code>, then the dependency includes a memory
domain operation from device domain to host domain.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="chap11.html#vkFlushMappedMemoryRanges">vkFlushMappedMemoryRanges</a> performs an availability operation, with a
source scope of (agents,references) = (all host threads, all mapped memory
ranges passed to the command), and destination scope of the host domain.</p>
</div>
<div class="paragraph">
<p><a href="chap11.html#vkInvalidateMappedMemoryRanges">vkInvalidateMappedMemoryRanges</a> performs a visibility operation, with a
source scope of the host domain and a destination scope of
(agents,references) = (all host threads, all mapped memory ranges passed to
the command).</p>
</div>
<div class="paragraph">
<p><a href="chap6.html#vkQueueSubmit">vkQueueSubmit</a> performs a memory domain operation from host to device,
and a visibility operation with source scope of the device domain and
destination scope of all agents and references on the device.</p>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-availability-visibility-semantics"><a class="anchor" href="chap43.html#memory-model-availability-visibility-semantics"></a>Availability and Visibility Semantics</h3>
<div class="paragraph">
<p>A memory barrier or atomic operation via agent A that includes MakeAvailable
in its semantics performs an availability operation whose source scope
includes agent A and all references in the storage classes in that
instruction’s storage class semantics, and all memory locations, and whose
destination scope is a set of memory domains selected as specified below.
The implicit availability operation is program-ordered between the barrier
or atomic and all other operations program-ordered before the barrier or
atomic.</p>
</div>
<div class="paragraph">
<p>A memory barrier or atomic operation via agent A that includes MakeVisible
in its semantics performs a visibility operation whose source scope is a set
of memory domains selected as specified below, and whose destination scope
includes agent A and all references in the storage classes in that
instruction’s storage class semantics, and all memory locations.
The implicit visibility operation is program-ordered between the barrier or
atomic and all other operations program-ordered after the barrier or atomic.</p>
</div>
<div class="paragraph">
<p>The memory domains are selected based on the memory scope of the instruction
as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Device</code> scope uses the shader domain</p>
</li>
<li>
<p><code>QueueFamily</code> scope uses the queue family instance domain</p>
</li>
<li>
<p><code>ShaderCallKHR</code> scope uses the shader call instance domain</p>
</li>
<li>
<p><code>Workgroup</code> scope uses the workgroup instance domain</p>
</li>
<li>
<p><code>Subgroup</code> uses the subgroup instance domain</p>
</li>
<li>
<p><code>Invocation</code> perform no availability/visibility operations.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When an availability operation performed by an agent A includes a memory
domain D in its destination scope, where D corresponds to scope instance S,
it also includes the memory domains that correspond to each smaller scope
instance S' that is a subset of S and that includes A. Similarly for
visibility operations.</p>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-instruction-av-vis"><a class="anchor" href="chap43.html#memory-model-instruction-av-vis"></a>Per-Instruction Availability and Visibility Semantics</h3>
<div class="paragraph">
<p>A memory write instruction that includes MakePointerAvailable, or an image
write instruction that includes MakeTexelAvailable, performs an availability
operation whose source scope includes the agent and reference used to
perform the write and the memory locations written by the instruction, and
whose destination scope is a set of memory domains selected by the Scope
operand specified in <a href="chap43.html#memory-model-availability-visibility-semantics">Availability and Visibility Semantics</a>.
The implicit availability operation is program-ordered between the write and
all other operations program-ordered after the write.</p>
</div>
<div class="paragraph">
<p>A memory read instruction that includes MakePointerVisible, or an image read
instruction that includes MakeTexelVisible, performs a visibility operation
whose source scope is a set of memory domains selected by the Scope operand
as specified in <a href="chap43.html#memory-model-availability-visibility-semantics">Availability and Visibility Semantics</a>, and whose destination scope
includes the agent and reference used to perform the read and the memory
locations read by the instruction.
The implicit visibility operation is program-ordered between read and all
other operations program-ordered before the read.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Although reads with per-instruction visibility only perform visibility ops
from the shader or
shader call instance or
workgroup instance or subgroup instance domain, they will also see writes
that were made visible via the device domain, i.e. those writes previously
performed by non-shader agents and made visible via API commands.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>It is expected that all invocations in a subgroup execute on the same
processor with the same path to memory, and thus availability and visibility
operations with subgroup scope can be expected to be “free”.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-location-ordered"><a class="anchor" href="chap43.html#memory-model-location-ordered"></a>Location-Ordered</h3>
<div class="paragraph">
<p>Let X and Y be memory accesses to overlapping sets of memory locations M,
where X != Y. Let (A<sub>X</sub>,R<sub>X</sub>) be the agent and reference used for X, and
(A<sub>Y</sub>,R<sub>Y</sub>) be the agent and reference used for Y. For now, let “→”
denote happens-before and “→<sup>rcpo</sup>” denote the reflexive closure of
program-ordered before.</p>
</div>
<div class="paragraph">
<p>If D<sub>1</sub> and D<sub>2</sub> are different memory domains, then let DOM(D<sub>1</sub>,D<sub>2</sub>) be a
memory domain operation from D<sub>1</sub> to D<sub>2</sub>.
Otherwise, let DOM(D,D) be a placeholder such that X→DOM(D,D)→Y if and
only if X→Y.</p>
</div>
<div class="paragraph">
<p>X is <em>location-ordered</em> before Y for a location L in M if and only if any of
the following is true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A<sub>X</sub> == A<sub>Y</sub> and R<sub>X</sub> == R<sub>Y</sub> and X→Y</p>
<div class="ulist">
<ul>
<li>
<p>NOTE: this case means no availability/visibility ops are required when
it is the same (agent,reference).</p>
</li>
</ul>
</div>
</li>
<li>
<p>X is a read, both X and Y are non-private, and X→Y</p>
</li>
<li>
<p>X is a read, and X (transitively) system-synchronizes with Y</p>
</li>
<li>
<p>If R<sub>X</sub> == R<sub>Y</sub> and A<sub>X</sub> and A<sub>Y</sub> access a common memory domain D (e.g.
are in the same workgroup instance if D is the workgroup instance
domain), and both X and Y are non-private:</p>
<div class="ulist">
<ul>
<li>
<p>X is a write, Y is a write, AVC(A<sub>X</sub>,R<sub>X</sub>,D,L) is an availability chain
making (X,L) available to domain D, and X→<sup>rcpo</sup>AVC(A<sub>X</sub>,R<sub>X</sub>,D,L)→Y</p>
</li>
<li>
<p>X is a write, Y is a read, AVC(A<sub>X</sub>,R<sub>X</sub>,D,L) is an availability chain
making (X,L) available to domain D, VISC(A<sub>Y</sub>,R<sub>Y</sub>,D,L) is a visibility
chain making writes to L available in domain D visible to Y, and
X→<sup>rcpo</sup>AVC(A<sub>X</sub>,R<sub>X</sub>,D,L)→VISC(A<sub>Y</sub>,R<sub>Y</sub>,D,L)→<sup>rcpo</sup>Y</p>
</li>
<li>
<p>If
<a href="chap37.html#VkPhysicalDeviceVulkanMemoryModelFeatures">VkPhysicalDeviceVulkanMemoryModelFeatures</a>::<code>vulkanMemoryModelAvailabilityVisibilityChains</code>
is <code>VK_FALSE</code>, then AVC and VISC <strong class="purple">must</strong> each only have a single
element in the chain, in each sub-bullet above.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Let D<sub>X</sub> and D<sub>Y</sub> each be either the device domain or the host domain,
depending on whether A<sub>X</sub> and A<sub>Y</sub> execute on the device or host:</p>
<div class="ulist">
<ul>
<li>
<p>X is a write and Y is a write, and
X→AV(A<sub>X</sub>,R<sub>X</sub>,D<sub>X</sub>,L)→DOM(D<sub>X</sub>,D<sub>Y</sub>)→Y</p>
</li>
<li>
<p>X is a write and Y is a read, and
X→AV(A<sub>X</sub>,R<sub>X</sub>,D<sub>X</sub>,L)→DOM(D<sub>X</sub>,D<sub>Y</sub>)→VIS(A<sub>Y</sub>,R<sub>Y</sub>,D<sub>Y</sub>,L)→Y</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>The final bullet (synchronization through device/host domain) requires
API-level synchronization operations, since the device/host domains are not
accessible via shader instructions.
And “device domain” is not to be confused with “device scope”, which
synchronizes through the “shader domain”.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-access-data-race"><a class="anchor" href="chap43.html#memory-model-access-data-race"></a>Data Race</h3>
<div class="paragraph">
<p>Let X and Y be operations that access overlapping sets of memory locations
M, where X != Y, and at least one of X and Y is a write, and X and Y are not
mutually-ordered atomic operations.
If there does not exist a location-ordered relation between X and Y for each
location in M, then there is a <em>data race</em>.</p>
</div>
<div class="paragraph">
<p>Applications <strong class="purple">must</strong> ensure that no data races occur during the execution of
their application.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Data races can only occur due to instructions that are actually executed.
For example, an instruction skipped due to control flow must not contribute
to a data race.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-visible-to"><a class="anchor" href="chap43.html#memory-model-visible-to"></a>Visible-To</h3>
<div class="paragraph">
<p>Let X be a write and Y be a read whose sets of memory locations overlap, and
let M be the set of memory locations that overlap.
Let M<sub>2</sub> be a non-empty subset of M. Then X is <em>visible-to</em> Y for memory
locations M<sub>2</sub> if and only if all of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>X is location-ordered before Y for each location L in M<sub>2</sub>.</p>
</li>
<li>
<p>There does not exist another write Z to any location L in M<sub>2</sub> such that
X is location-ordered before Z for location L and Z is location-ordered
before Y for location L.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If X is visible-to Y, then Y reads the value written by X for locations
M<sub>2</sub>.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>It is possible for there to be a write between X and Y that overwrites a
subset of the memory locations, but the remaining memory locations (M<sub>2</sub>)
will still be visible-to Y.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-acyclicity"><a class="anchor" href="chap43.html#memory-model-acyclicity"></a>Acyclicity</h3>
<div class="paragraph">
<p><em>Reads-from</em> is a relation between operations, where the first operation is
a write, the second operation is a read, and the second operation reads the
value written by the first operation.
<em>From-reads</em> is a relation between operations, where the first operation is
a read, the second operation is a write, and the first operation reads a
value written earlier than the second operation in the second operation’s
scoped modification order (or the first operation reads from the initial
value, and the second operation is any write to the same locations).</p>
</div>
<div class="paragraph">
<p>Then the implementation <strong class="purple">must</strong> guarantee that no cycles exist in the union of
the following relations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>location-ordered</p>
</li>
<li>
<p>scoped modification order (over all atomic writes)</p>
</li>
<li>
<p>reads-from</p>
</li>
<li>
<p>from-reads</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>This is a “consistency” axiom, which informally guarantees that sequences
of operations can’t violate causality.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="memory-model-scoped-modification-order-coherence"><a class="anchor" href="chap43.html#memory-model-scoped-modification-order-coherence"></a>Scoped Modification Order Coherence</h4>
<div class="paragraph">
<p>Let A and B be mutually-ordered atomic operations, where A is
location-ordered before B. Then the following rules are a consequence of
acyclicity:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If A and B are both reads and A does not read the initial value, then
the write that A takes its value from <strong class="purple">must</strong> be earlier in its own scoped
modification order than (or the same as) the write that B takes its
value from (no cycles between location-order, reads-from, and
from-reads).</p>
</li>
<li>
<p>If A is a read and B is a write and A does not read the initial value,
then A <strong class="purple">must</strong> take its value from a write earlier than B in B’s scoped
modification order (no cycles between location-order, scope modification
order, and reads-from).</p>
</li>
<li>
<p>If A is a write and B is a read, then B <strong class="purple">must</strong> take its value from A or a
write later than A in A’s scoped modification order (no cycles between
location-order, scoped modification order, and from-reads).</p>
</li>
<li>
<p>If A and B are both writes, then A <strong class="purple">must</strong> be earlier than B in A’s scoped
modification order (no cycles between location-order and scoped
modification order).</p>
</li>
<li>
<p>If A is a write and B is a read-modify-write and B reads the value
written by A, then B comes immediately after A in A’s scoped
modification order (no cycles between scoped modification order and
from-reads).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-shader-io"><a class="anchor" href="chap43.html#memory-model-shader-io"></a>Shader I/O</h3>
<div class="paragraph">
<p>If a shader invocation A in a shader stage other than <code>Vertex</code> performs a
memory read operation X from an object in storage class
<code>CallableDataKHR</code>, <code>IncomingCallableDataKHR</code>, <code>RayPayloadKHR</code>,
<code>HitAttributeKHR</code>, <code>IncomingRayPayloadKHR</code>, or
<code>Input</code>, then X is system-synchronized-after all writes to the
corresponding
<code>CallableDataKHR</code>, <code>IncomingCallableDataKHR</code>, <code>RayPayloadKHR</code>,
<code>HitAttributeKHR</code>, <code>IncomingRayPayloadKHR</code>, or
<code>Output</code> storage variable(s) in the shader invocation(s) that contribute
to generating invocation A, and those writes are all visible-to X.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>It is not necessary for the upstream shader invocations to have completed
execution, they only need to have generated the output that is being read.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-deallocation"><a class="anchor" href="chap43.html#memory-model-deallocation"></a>Deallocation</h3>
<div class="paragraph">
<p>A call to <a href="chap11.html#vkFreeMemory">vkFreeMemory</a> <strong class="purple">must</strong> happen-after all memory operations on all
memory locations in that <a href="chap11.html#VkDeviceMemory">VkDeviceMemory</a> object.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Normally, device memory operations in a given queue are synchronized with
<a href="chap11.html#vkFreeMemory">vkFreeMemory</a> by having a host thread wait on a fence signalled by that
queue, and the wait happens-before the call to <a href="chap11.html#vkFreeMemory">vkFreeMemory</a> on the
host.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>The deallocation of SPIR-V variables is managed by the system and
happens-after all operations on those variables.</p>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-informative-descriptions"><a class="anchor" href="chap43.html#memory-model-informative-descriptions"></a>Descriptions (Informative)</h3>
<div class="paragraph">
<p>This subsection offers more easily understandable consequences of the memory
model for app/compiler developers.</p>
</div>
<div class="paragraph">
<p>Let SC be the storage class(es) specified by a release or acquire operation
or barrier.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An atomic write with release semantics must not be reordered against any
read or write to SC that is program-ordered before it (regardless of the
storage class the atomic is in).</p>
</li>
<li>
<p>An atomic read with acquire semantics must not be reordered against any
read or write to SC that is program-ordered after it (regardless of the
storage class the atomic is in).</p>
</li>
<li>
<p>Any write to SC program-ordered after a release barrier must not be
reordered against any read or write to SC program-ordered before that
barrier.</p>
</li>
<li>
<p>Any read from SC program-ordered before an acquire barrier must not be
reordered against any read or write to SC program-ordered after the
barrier.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A control barrier (even if it has no memory semantics) must not be reordered
against any memory barriers.</p>
</div>
<div class="paragraph">
<p>This memory model allows memory accesses with and without availability and
visibility operations, as well as atomic operations, all to be performed on
the same memory location.
This is critical to allow it to reason about memory that is reused in
multiple ways, e.g. across the lifetime of different shader invocations or
draw calls.
While GLSL (and legacy SPIR-V) applies the “coherent” decoration to
variables (for historical reasons), this model treats each memory access
instruction as having optional implicit availability/visibility operations.
GLSL to SPIR-V compilers should map all (non-atomic) operations on a
coherent variable to Make{Pointer,Texel}{Available}{Visible} flags in this
model.</p>
</div>
<div class="paragraph">
<p>Atomic operations implicitly have availability/visibility operations, and
the scope of those operations is taken from the atomic operation’s scope.</p>
</div>
</div>
<div class="sect2">
<h3 id="memory-model-tessellation-output-ordering"><a class="anchor" href="chap43.html#memory-model-tessellation-output-ordering"></a>Tessellation Output Ordering</h3>
<div class="paragraph">
<p>For SPIR-V that uses the Vulkan Memory Model, the <code>OutputMemory</code> storage
class is used to synchronize accesses to tessellation control output
variables.
For legacy SPIR-V that does not enable the Vulkan Memory Model via
<code>OpMemoryModel</code>, tessellation outputs can be ordered using a control
barrier with no particular memory scope or semantics, as defined below.</p>
</div>
<div class="paragraph">
<p>Let X and Y be memory operations performed by shader invocations A<sub>X</sub> and
A<sub>Y</sub>.
Operation X is <em>tessellation-output-ordered</em> before operation Y if and only
if all of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There is a dynamic instance of an <code>OpControlBarrier</code> instruction C
such that X is program-ordered before C in A<sub>X</sub> and C is program-ordered
before Y in A<sub>Y</sub>.</p>
</li>
<li>
<p>A<sub>X</sub> and A<sub>Y</sub> are in the same instance of C’s execution scope.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If shader invocations A<sub>X</sub> and A<sub>Y</sub> in the <code>TessellationControl</code>
execution model execute memory operations X and Y, respectively, on the
<code>Output</code> storage class, and X is tessellation-output-ordered before Y
with a scope of <code>Workgroup</code>, then X is location-ordered before Y, and if
X is a write and Y is a read then X is visible-to Y.</p>
</div>
</div>
</div>
</div></div>

<nav>
  <a rel="prev" href="chap42.html" class="nav nav-prev" aria-keyshortcuts="Left">
        <i class="fa fa-angle-left"></i>
     </a>
  <a rel="next" href="chap44.html" class="nav nav-next" aria-keyshortcuts="Right">
        <i class="fa fa-angle-right"></i>
     </a>
  <div style="clear: both"></div>
</nav>
<div id="footer" style="max-width: 100%;">
<div id="footer-text">
Version 1.2.184<br>
Last updated 2021-04-13 01:33:51 -0700
</div>
</div>



</body>
  <script>
  function isInViewport(ele) {
    const rect = ele.getBoundingClientRect();
    return (
        rect.top >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)
    );
  }
  function yPosition (ele) {
    const rect = ele.getBoundingClientRect();
    return (rect.top - 20); // 20px above
  }
  let curr = document.getElementsByClassName('current');
  if (!isInViewport(curr[curr.length - 1])) {
    document.getElementById('toc').scrollTo({
      top: yPosition(curr[0]),
      left: 0,
      behavior: 'smooth'
    });
  }
  </script>
  </html>