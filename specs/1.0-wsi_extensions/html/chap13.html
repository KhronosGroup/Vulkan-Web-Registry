<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="The Khronos® Vulkan Working Group">
<title>Vulkan® 1.0.137 - A Specification (with KHR extensions)</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: #fff; color: #222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

object, svg { display: inline-block; vertical-align: middle; }

.center { margin-left: auto; margin-right: auto; }

.spread { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.4; color: black; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #0068b0; text-decoration: none; line-height: inherit; }
a:hover, a:focus { color: #333; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: Noto, sans-serif; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 0.75em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Noto, sans-serif; font-weight: normal; font-style: normal; color: black; text-rendering: optimizeLegibility; margin-top: 0.5em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #4d4d4d; line-height: 0; }

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid #ddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; color: #264357; }

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 0.75em; list-style-position: outside; font-family: Noto, sans-serif; }

ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3em; font-weight: bold; }
dl dd { margin-bottom: 0.75em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: black; border-bottom: 1px dotted #ddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 0.75em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #ddd; }
blockquote cite { display: block; font-size: 0.8125em; color: #5e93b8; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #5e93b8; }

blockquote, blockquote p { line-height: 1.6; color: #333; }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #ddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
/* Tables */
table { background: #fff; margin-bottom: 1.25em; border: solid 1px #d8d8ce; }
table thead, table tfoot { background: #eee; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #6d6e71; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f8f8f8; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.4; }

body { -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; tab-size: 4; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }

a:hover, a:focus { text-decoration: underline; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: inherit; font-style: normal !important; letter-spacing: 0; padding: 0; background-color: transparent; -webkit-border-radius: 0; border-radius: 0; line-height: inherit; word-wrap: break-word; }
*:not(pre) > code.nobreak { word-wrap: normal; }
*:not(pre) > code.nowrap { white-space: nowrap; }

pre, pre > code { line-height: 1.6; color: #264357; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }

em em { font-style: normal; }

strong strong { font-weight: normal; }

.keyseq { color: #333333; }

kbd { font-family: Consolas, "Liberation Mono", Courier, monospace; display: inline-block; color: black; font-size: 0.65em; line-height: 1.45; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -moz-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: 0 0.15em; padding: 0.2em 0.5em; vertical-align: middle; position: relative; top: -0.1em; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menuref { color: #000; }

.menuseq b:not(.caret), .menuref { font-weight: inherit; }

.menuseq { word-spacing: -0.02em; }
.menuseq b.caret { font-size: 1.25em; line-height: 0.8; }
.menuseq i.caret { font-weight: bold; text-align: center; width: 0.45em; }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 1.5em; padding-right: 1.5em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: black; margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #ddd; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #ddd; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #ddd; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: #5e93b8; display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: #333; }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: #333; }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: black; border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 0 solid #ddd; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: Noto, sans-serif; list-style-type: none; }
#toc li { line-height: 1.3334; margin-top: 0.3334em; }
#toc a { text-decoration: none; }
#toc a:active { text-decoration: underline; }

#toctitle { color: black; font-size: 1.2em; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
  body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { margin-top: 0 !important; background-color: #fff; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #ddd; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #ddd; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
  #toc.toc2 { width: 20em; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background-color: none; padding: 1.25em; }

#footer-text { color: black; line-height: 1.44; }

#content { margin-bottom: 0.625em; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { #content { margin-bottom: 1.25em; }
  .sect1 { padding-bottom: 1.25em; } }
.sect1:last-child { padding-bottom: 0; }

.sect1 + .sect1 { border-top: 0 solid #ddd; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: black; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: black; }

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; }

table.tableblock > caption.title { white-space: nowrap; overflow: visible; max-width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: black; }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: initial; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: Noto, sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #ddd; color: #5e93b8; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: black; margin-top: 0; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint { background: #eee; }
.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint { background: #f2f1f1; }

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { border: 1px hidden #666; -webkit-border-radius: 0; border-radius: 0; word-wrap: break-word; padding: 1.25em 1.5625em 1.125em 1.5625em; font-size: 0.8125em; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.90625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 1em; } }

.literalblock.output pre { color: #eee; background-color: #264357; }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1.25em 1.5625em 1.125em 1.5625em; -webkit-border-radius: 0; border-radius: 0; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: #999; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

table.pyhltable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; line-height: 1.6; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

pre.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #ddd; }

pre.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background: none !important; padding-right: 0 !important; }

.quoteblock { margin: 0 1em 0.75em 1.5em; display: table; }
.quoteblock > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock blockquote p { color: #333; font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: black; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.5em; margin-right: 0.5ex; text-align: right; }
.quoteblock .quoteblock { margin-left: 0; margin-right: 0; padding: 0.5em 0; border-left: 3px solid #5e93b8; }
.quoteblock .quoteblock blockquote { padding: 0 0 0 0.75em; }
.quoteblock .quoteblock blockquote:before { display: none; }

.verseblock { margin: 0 1em 0.75em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: #333; font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.8125em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.025em; color: #5e93b8; }

.quoteblock.abstract { margin: 0 0 0.75em 0; display: block; }
.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p { text-align: left; word-spacing: 0; }
.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before { display: none; }

table.tableblock { max-width: 100%; border-collapse: separate; }
table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid #d8d8ce; }

table.grid-all > thead > tr > .tableblock, table.grid-all > tbody > tr > .tableblock { border-width: 0 1px 1px 0; }

table.grid-all > tfoot > tr > .tableblock { border-width: 1px 1px 0 0; }

table.grid-cols > * > tr > .tableblock { border-width: 0 1px 0 0; }

table.grid-rows > thead > tr > .tableblock, table.grid-rows > tbody > tr > .tableblock { border-width: 0 0 1px 0; }

table.grid-rows > tfoot > tr > .tableblock { border-width: 1px 0 0 0; }

table.grid-all > * > tr > .tableblock:last-child, table.grid-cols > * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-all > tbody > tr:last-child > .tableblock, table.grid-all > thead:last-child > tr > .tableblock, table.grid-rows > tbody > tr:last-child > .tableblock, table.grid-rows > thead:last-child > tr > .tableblock { border-bottom-width: 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot { border-width: 1px 0; }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.4; background: #eee; }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: #222; font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 1em; }

td > div.verse { white-space: pre; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.375em; }

ul.checklist, ul.none, ol.none, ul.no-bullet, ol.no-bullet, ol.unnumbered, ul.unstyled, ol.unstyled { list-style-type: none; }

ul.no-bullet, ol.no-bullet, ol.unnumbered { margin-left: 0.625em; }

ul.unstyled, ol.unstyled { margin-left: 0; }

ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1.25em; font-size: 0.8em; position: relative; bottom: 0.125em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }

ul.inline { display: -ms-flexbox; display: -webkit-box; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; list-style: none; margin: 0 0 0.375em -0.75em; }

ul.inline > li { margin-left: 0.75em; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1, td.hdlist2 { vertical-align: top; padding: 0 0.625em; }

td.hdlist1 { font-weight: bold; padding-bottom: 0.75em; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0.4em 0.75em 0 0.75em; line-height: 1; vertical-align: top; }
.colist > table tr > td:first-of-type img { max-width: initial; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px #fff; -webkit-box-shadow: 0 0 0 1px #ddd; box-shadow: 0 0 0 1px #ddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; display: inline-block; }
a.image object { pointer-events: none; }

sup.footnote, sup.footnoteref { font-size: 0.875em; position: static; vertical-align: super; }
sup.footnote a, sup.footnoteref a { text-decoration: none; }
sup.footnote a:active, sup.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -0.25em 0 0.75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em 0 0.225em; line-height: 1.3334; font-size: 0.875em; margin-left: 1.2em; margin-bottom: 0.2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; margin-left: -1.05em; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }
a span.icon > .fa { cursor: inherit; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #29475c; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: black; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { border-bottom: 1px solid #ddd; }

.sect1 { padding-bottom: 0; }

#toctitle { color: #00406F; font-weight: normal; margin-top: 1.5em; }

.sidebarblock { border-color: #aaa; }

code { -webkit-border-radius: 4px; border-radius: 4px; }

p.tableblock.header { color: #6d6e71; }

.literalblock pre, .listingblock pre { background: #eee; }

/* From https://github.com/KhronosGroup/Vulkan-Docs/pull/901 */
a code { color: inherit; }

/* Make VUID anchor handles*/
li > p > a[id^="VUID-"] { visibility: hidden; position: absolute; z-index: 1001; width: 2.2ex; margin-left: -2.2ex; display: block; text-decoration: none !important; text-align: center; font-weight: normal; }
li > p > a[id^="VUID-"]:before { content: "\00A7"; font-size: 1em; display: block; padding-top: 0em; background: #fff }
li > p:hover > a[id^="VUID-"], li > p > a[id^="VUID-"]:hover { visibility: visible; }
li > p > a[id^="VUID-"].link { color: black; text-decoration: none; } /* TODO: not quite sure what these two do */
li > p > a[id^="VUID-"].link:hover { color: black; }

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<!-- dragged in by font-awesome css included by asciidoctor, but preloaded in this extension for convenience -->
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/fonts/fontawesome-webfont.woff2?v=4.7.0" as="font" type="font/woff2" crossorigin="">

<!-- Note: Chrome needs crossorigin even for same-origin fonts -->
<link rel="preload" href="../katex/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Main-Italic.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../katex/fonts/KaTeX_Typewriter-Regular.woff2" as="font" type="font/woff2" crossorigin=""><link rel="stylesheet" href="../katex/katex.min.css">
<style>
    #loading_msg {
        width: 100%;
        margin-left: auto;
        margin-right: auto;
        margin-top: 1ex;
        margin-bottom: 1ex;
        max-width: 62.5em;
        position: relative;
        padding-left: 1.5em;
        padding-right: 1.5em;
    }
    .loadable {display: none !important;}
</style>
<script>
    function unhideLoadableContent(){
        document.getElementById("loading_msg").style.display = "none";
        var loadables = document.getElementsByClassName("loadable");
        for( var i = 0; i < loadables.length; ++i ) loadables[i].classList.remove("loadable");
    }

    window.addEventListener("load", unhideLoadableContent);
</script>
</head>
<body class="book toc2 toc-left" style="max-width: 100%;">
<div id="header">
<h1>Vulkan<sup>®</sup> 1.0.137 - A Specification (with KHR extensions)</h1>
<div class="details">
<span id="author" class="author">The Khronos<sup>®</sup> Vulkan Working Group</span><br>
<span id="revnumber">version 1.0.137,</span>
<span id="revdate">2020-04-07 05:44:44Z</span>
<br><span id="revremark">from git branch: github-master commit: 019f62b11de9358d3383ead2e1a8c5bc2fda23ad</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="chap1.html#introduction">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="chap1.html#introduction-conventions">1.1. Document Conventions</a></li>
</ul>
</li>
<li><a href="chap2.html#fundamentals">2. Fundamentals</a>
<ul class="sectlevel2">
<li><a href="chap2.html#fundamentals-host-environment">2.1. Host and Device Environment</a></li>
<li><a href="chap2.html#fundamentals-execmodel">2.2. Execution Model</a></li>
<li><a href="chap2.html#fundamentals-objectmodel-overview">2.3. Object Model</a></li>
<li><a href="chap2.html#fundamentals-abi">2.4. Application Binary Interface</a></li>
<li><a href="chap2.html#fundamentals-commandsyntax">2.5. Command Syntax and Duration</a></li>
<li><a href="chap2.html#fundamentals-threadingbehavior">2.6. Threading Behavior</a></li>
<li><a href="chap2.html#fundamentals-errors">2.7. Errors</a></li>
<li><a href="chap2.html#fundamentals-numerics">2.8. Numeric Representation and Computation</a></li>
<li><a href="chap2.html#fundamentals-fixedconv">2.9. Fixed-Point Data Conversions</a></li>
<li><a href="chap2.html#fundamentals-common-objects">2.10. Common Object Types</a></li>
</ul>
</li>
<li><a href="chap3.html#initialization">3. Initialization</a>
<ul class="sectlevel2">
<li><a href="chap3.html#initialization-functionpointers">3.1. Command Function Pointers</a></li>
<li><a href="chap3.html#initialization-instances">3.2. Instances</a></li>
</ul>
</li>
<li><a href="chap4.html#devsandqueues">4. Devices and Queues</a>
<ul class="sectlevel2">
<li><a href="chap4.html#devsandqueues-physical-device-enumeration">4.1. Physical Devices</a></li>
<li><a href="chap4.html#devsandqueues-devices">4.2. Devices</a></li>
<li><a href="chap4.html#devsandqueues-queues">4.3. Queues</a></li>
</ul>
</li>
<link href="chunked.css?4" rel="stylesheet">
<script>var searchindexurl = 'search.index.js?4' + (document.title.replace(/[^0-9.]/g, ''));</script>
<script src="chunked.js?4"></script>
<li><a href="chap5.html#commandbuffers">5. Command Buffers</a>
<ul class="sectlevel2">
<li><a href="chap5.html#commandbuffers-lifecycle">5.1. Command Buffer Lifecycle</a></li>
<li><a href="chap5.html#commandbuffers-pools">5.2. Command Pools</a></li>
<li><a href="chap5.html#commandbuffer-allocation">5.3. Command Buffer Allocation and Management</a></li>
<li><a href="chap5.html#commandbuffers-recording">5.4. Command Buffer Recording</a></li>
<li><a href="chap5.html#commandbuffers-submission">5.5. Command Buffer Submission</a></li>
<li><a href="chap5.html#commandbuffers-submission-progress">5.6. Queue Forward Progress</a></li>
<li><a href="chap5.html#commandbuffers-secondary">5.7. Secondary Command Buffer Execution</a></li>
<li><a href="chap5.html#commandbuffers-devicemask">5.8. Command Buffer Device Mask</a></li>
</ul>
</li>
<li><a href="chap6.html#synchronization">6. Synchronization and Cache Control</a>
<ul class="sectlevel2">
<li><a href="chap6.html#synchronization-dependencies">6.1. Execution and Memory Dependencies</a></li>
<li><a href="chap6.html#synchronization-implicit">6.2. Implicit Synchronization Guarantees</a></li>
<li><a href="chap6.html#synchronization-fences">6.3. Fences</a></li>
<li><a href="chap6.html#synchronization-semaphores">6.4. Semaphores</a></li>
<li><a href="chap6.html#synchronization-events">6.5. Events</a></li>
<li><a href="chap6.html#synchronization-pipeline-barriers">6.6. Pipeline Barriers</a></li>
<li><a href="chap6.html#synchronization-memory-barriers">6.7. Memory Barriers</a></li>
<li><a href="chap6.html#synchronization-wait-idle">6.8. Wait Idle Operations</a></li>
<li><a href="chap6.html#synchronization-submission-host-writes">6.9. Host Write Ordering Guarantees</a></li>
<li><a href="chap6.html#synchronization-device-group">6.10. Synchronization and Multiple Physical Devices</a></li>
</ul>
</li>
<li><a href="chap7.html#renderpass">7. Render Pass</a>
<ul class="sectlevel2">
<li><a href="chap7.html#renderpass-creation">7.1. Render Pass Creation</a></li>
<li><a href="chap7.html#renderpass-compatibility">7.2. Render Pass Compatibility</a></li>
<ul class="sectlevel1"><li><a href="index.html#preamble">0. Preamble</a></li></ul>
<li><a href="chap7.html#_framebuffers">7.3. Framebuffers</a></li>
<li><a href="chap7.html#renderpass-commands">7.4. Render Pass Commands</a></li>
</ul>
</li>
<li><a href="chap8.html#shaders">8. Shaders</a>
<ul class="sectlevel2">
<li><a href="chap8.html#shader-modules">8.1. Shader Modules</a></li>
<li><a href="chap8.html#shaders-execution">8.2. Shader Execution</a></li>
<li><a href="chap8.html#shaders-execution-memory-ordering">8.3. Shader Memory Access Ordering</a></li>
<li><a href="chap8.html#shaders-inputs">8.4. Shader Inputs and Outputs</a></li>
<li><a href="chap8.html#shaders-vertex">8.5. Vertex Shaders</a></li>
<li><a href="chap8.html#shaders-tessellation-control">8.6. Tessellation Control Shaders</a></li>
<li><a href="chap8.html#shaders-tessellation-evaluation">8.7. Tessellation Evaluation Shaders</a></li>
<li><a href="chap8.html#shaders-geometry">8.8. Geometry Shaders</a></li>
<li><a href="chap8.html#shaders-fragment">8.9. Fragment Shaders</a></li>
<li><a href="chap8.html#shaders-compute">8.10. Compute Shaders</a></li>
<li><a href="chap8.html#shaders-interpolation-decorations">8.11. Interpolation Decorations</a></li>
<li><a href="chap8.html#shaders-ray-generation">8.12. Ray Generation Shaders</a></li>
<li><a href="chap8.html#shaders-intersection">8.13. Intersection Shaders</a></li>
<li><a href="chap8.html#shaders-any-hit">8.14. Any-Hit Shaders</a></li>
<li><a href="chap8.html#shaders-closest-hit">8.15. Closest Hit Shaders</a></li>
<li><a href="chap8.html#shaders-miss">8.16. Miss Shaders</a></li>
<li><a href="chap8.html#shaders-callable">8.17. Callable Shaders</a></li>
<li><a href="chap8.html#shaders-staticuse">8.18. Static Use</a></li>
<li><a href="chap8.html#shaders-scope">8.19. Scope</a></li>
<li><a href="chap8.html#shaders-derivative-operations">8.20. Derivative Operations</a></li>
<li><a href="chap8.html#_helper_invocations">8.21. Helper Invocations</a></li>
</ul>
</li>
<li><a href="chap9.html#pipelines">9. Pipelines</a>
<ul class="sectlevel2">
<li><a href="chap9.html#pipelines-compute">9.1. Compute Pipelines</a></li>
<li><a href="chap9.html#pipelines-graphics">9.2. Graphics Pipelines</a></li>
<li><a href="chap9.html#pipelines-destruction">9.3. Pipeline destruction</a></li>
<li><a href="chap9.html#pipelines-multiple">9.4. Multiple Pipeline Creation</a></li>
<li><a href="chap9.html#pipelines-pipeline-derivatives">9.5. Pipeline Derivatives</a></li>
<li><a href="chap9.html#pipelines-cache">9.6. Pipeline Cache</a></li>
<li><a href="chap9.html#pipelines-specialization-constants">9.7. Specialization Constants</a></li>
<li><a href="chap9.html#pipeline-library">9.8. Pipeline Libraries</a></li>
<li><a href="chap9.html#pipelines-binding">9.9. Pipeline Binding</a></li>
<li><a href="chap9.html#pipelines-dynamic-state">9.10. Dynamic State</a></li>
<li><a href="chap9.html#pipelines-shader-information">9.11. Pipeline Shader Information</a></li>
<li><a href="chap9.html#pipelines-ray-tracing">9.12. Ray Tracing Pipeline</a></li>
</ul>
</li>
<li><a href="chap10.html#memory">10. Memory Allocation</a>
<ul class="sectlevel2">
<li><a href="chap10.html#memory-host">10.1. Host Memory</a></li>
<li><a href="chap10.html#memory-device">10.2. Device Memory</a></li>
</ul>
</li>
<li><a href="chap11.html#resources">11. Resource Creation</a>
<ul class="sectlevel2">
<li><a href="chap11.html#resources-buffers">11.1. Buffers</a></li>
<li><a href="chap11.html#resources-buffer-views">11.2. Buffer Views</a></li>
<li><a href="chap11.html#resources-images">11.3. Images</a></li>
<li><a href="chap11.html#resources-image-layouts">11.4. Image Layouts</a></li>
<li><a href="chap11.html#resources-image-views">11.5. Image Views</a></li>
<li><a href="chap11.html#resources-association">11.6. Resource Memory Association</a></li>
<li><a href="chap11.html#resources-sharing">11.7. Resource Sharing Mode</a></li>
<li><a href="chap11.html#resources-memory-aliasing">11.8. Memory Aliasing</a></li>
<li><a href="chap11.html#resources-acceleration-structures">11.9. Acceleration Structures</a></li>
</ul>
</li>
<li><a href="chap12.html#samplers">12. Samplers</a>
<ul class="sectlevel2">
<li><a href="chap12.html#samplers-YCbCr-conversion">12.1. Sampler Y′C<sub>B</sub>C<sub>R</sub> conversion</a></li>
</ul>
</li>
<li><a href="#descriptorsets">13. Resource Descriptors</a>
<ul class="sectlevel2">
<li><a href="#descriptorsets-types">13.1. Descriptor Types</a></li>
<li><a href="#descriptorsets-sets">13.2. Descriptor Sets</a></li>
<li><a href="#_physical_storage_buffer_access">13.3. Physical Storage Buffer Access</a></li>
</ul>
</li>
<li><a href="chap14.html#interfaces">14. Shader Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap14.html#interfaces-iointerfaces">14.1. Shader Input and Output Interfaces</a></li>
<li><a href="chap14.html#interfaces-vertexinput">14.2. Vertex Input Interface</a></li>
<li><a href="chap14.html#interfaces-fragmentoutput">14.3. Fragment Output Interface</a></li>
<li><a href="chap14.html#interfaces-inputattachment">14.4. Fragment Input Attachment Interface</a></li>
<li><a href="chap14.html#interfaces-resources">14.5. Shader Resource Interface</a></li>
<li><a href="chap14.html#interfaces-builtin-variables">14.6. Built-In Variables</a></li>
</ul>
</li>
<li><a href="chap15.html#textures">15. Image Operations</a>
<ul class="sectlevel2">
<li><a href="chap15.html#_image_operations_overview">15.1. Image Operations Overview</a></li>
<li><a href="chap15.html#_conversion_formulas">15.2. Conversion Formulas</a></li>
<li><a href="chap15.html#_texel_input_operations">15.3. Texel Input Operations</a></li>
<li><a href="chap15.html#_texel_output_operations">15.4. Texel Output Operations</a></li>
<li><a href="chap15.html#textures-normalized-operations">15.5. Normalized Texel Coordinate Operations</a></li>
<li><a href="chap15.html#_unnormalized_texel_coordinate_operations">15.6. Unnormalized Texel Coordinate Operations</a></li>
<li><a href="chap15.html#textures-integer-coordinate-operations">15.7. Integer Texel Coordinate Operations</a></li>
<li><a href="chap15.html#textures-sample-operations">15.8. Image Sample Operations</a></li>
<li><a href="chap15.html#textures-instructions">15.9. Image Operation Steps</a></li>
</ul>
</li>
<li><a href="chap16.html#queries">16. Queries</a>
<ul class="sectlevel2">
<li><a href="chap16.html#queries-pools">16.1. Query Pools</a></li>
<li><a href="chap16.html#queries-operation">16.2. Query Operation</a></li>
<li><a href="chap16.html#queries-occlusion">16.3. Occlusion Queries</a></li>
<li><a href="chap16.html#queries-pipestats">16.4. Pipeline Statistics Queries</a></li>
<li><a href="chap16.html#queries-timestamps">16.5. Timestamp Queries</a></li>
<li><a href="chap16.html#queries-performance">16.6. Performance Queries</a></li>
</ul>
</li>
<li><a href="chap17.html#clears">17. Clear Commands</a>
<ul class="sectlevel2">
<li><a href="chap17.html#clears-outside">17.1. Clearing Images Outside A Render Pass Instance</a></li>
<li><a href="chap17.html#clears-inside">17.2. Clearing Images Inside A Render Pass Instance</a></li>
<li><a href="chap17.html#clears-values">17.3. Clear Values</a></li>
<li><a href="chap17.html#clears-filling-buffers">17.4. Filling Buffers</a></li>
<li><a href="chap17.html#clears-updating-buffers">17.5. Updating Buffers</a></li>
</ul>
</li>
<li><a href="chap18.html#copies">18. Copy Commands</a>
<ul class="sectlevel2">
<li><a href="chap18.html#_common_operation">18.1. Common Operation</a></li>
<li><a href="chap18.html#copies-buffers">18.2. Copying Data Between Buffers</a></li>
<li><a href="chap18.html#copies-images">18.3. Copying Data Between Images</a></li>
<li><a href="chap18.html#copies-buffers-images">18.4. Copying Data Between Buffers and Images</a></li>
<li><a href="chap18.html#copies-imagescaling">18.5. Image Copies with Scaling</a></li>
<li><a href="chap18.html#copies-resolve">18.6. Resolving Multisample Images</a></li>
</ul>
</li>
<li><a href="chap19.html#drawing">19. Drawing Commands</a>
<ul class="sectlevel2">
<li><a href="chap19.html#drawing-primitive-topologies">19.1. Primitive Topologies</a></li>
<li><a href="chap19.html#drawing-primitive-order">19.2. Primitive Order</a></li>
<li><a href="chap19.html#drawing-primitive-shading">19.3. Programmable Primitive Shading</a></li>
</ul>
</li>
<li><a href="chap20.html#fxvertex">20. Fixed-Function Vertex Processing</a>
<ul class="sectlevel2">
<li><a href="chap20.html#fxvertex-attrib">20.1. Vertex Attributes</a></li>
<li><a href="chap20.html#fxvertex-input">20.2. Vertex Input Description</a></li>
<li><a href="chap20.html#fxvertex-example">20.3. Example</a></li>
</ul>
</li>
<li><a href="chap21.html#tessellation">21. Tessellation</a>
<ul class="sectlevel2">
<li><a href="chap21.html#_tessellator">21.1. Tessellator</a></li>
<li><a href="chap21.html#_tessellator_patch_discard">21.2. Tessellator Patch Discard</a></li>
<li><a href="chap21.html#tessellation-tessellator-spacing">21.3. Tessellator Spacing</a></li>
<li><a href="chap21.html#tessellation-primitive-order">21.4. Tessellation Primitive Ordering</a></li>
<li><a href="chap21.html#tessellation-vertex-winding-order">21.5. Tessellator Vertex Winding Order</a></li>
<li><a href="chap21.html#tessellation-triangle-tessellation">21.6. Triangle Tessellation</a></li>
<li><a href="chap21.html#tessellation-quad-tessellation">21.7. Quad Tessellation</a></li>
<li><a href="chap21.html#tessellation-isoline-tessellation">21.8. Isoline Tessellation</a></li>
<li><a href="chap21.html#tessellation-point-mode">21.9. Tessellation Point Mode</a></li>
<li><a href="chap21.html#_tessellation_pipeline_state">21.10. Tessellation Pipeline State</a></li>
</ul>
</li>
<li><a href="chap22.html#geometry">22. Geometry Shading</a>
<ul class="sectlevel2">
<li><a href="chap22.html#geometry-input">22.1. Geometry Shader Input Primitives</a></li>
<li><a href="chap22.html#geometry-output">22.2. Geometry Shader Output Primitives</a></li>
<li><a href="chap22.html#geometry-invocations">22.3. Multiple Invocations of Geometry Shaders</a></li>
<li><a href="chap22.html#geometry-ordering">22.4. Geometry Shader Primitive Ordering</a></li>
</ul>
</li>
<li><a href="chap23.html#vertexpostproc">23. Fixed-Function Vertex Post-Processing</a>
<ul class="sectlevel2">
<li><a href="chap23.html#vertexpostproc-flatshading">23.1. Flat Shading</a></li>
<li><a href="chap23.html#vertexpostproc-clipping">23.2. Primitive Clipping</a></li>
<li><a href="chap23.html#vertexpostproc-clipping-shader-outputs">23.3. Clipping Shader Outputs</a></li>
<li><a href="chap23.html#vertexpostproc-coord-transform">23.4. Coordinate Transformations</a></li>
<li><a href="chap23.html#vertexpostproc-viewport">23.5. Controlling the Viewport</a></li>
</ul>
</li>
<li><a href="chap24.html#primsrast">24. Rasterization</a>
<ul class="sectlevel2">
<li><a href="chap24.html#primsrast-discard">24.1. Discarding Primitives Before Rasterization</a></li>
<li><a href="chap24.html#primrast-order">24.2. Rasterization Order</a></li>
<li><a href="chap24.html#primsrast-multisampling">24.3. Multisampling</a></li>
<li><a href="chap24.html#primsrast-sampleshading">24.4. Sample Shading</a></li>
<li><a href="chap24.html#primsrast-points">24.5. Points</a></li>
<li><a href="chap24.html#primsrast-lines">24.6. Line Segments</a></li>
<li><a href="chap24.html#primsrast-polygons">24.7. Polygons</a></li>
</ul>
</li>
<li><a href="chap25.html#fragops">25. Fragment Operations</a>
<ul class="sectlevel2">
<li><a href="chap25.html#fragops-early">25.1. Early Per-Fragment Tests</a></li>
<li><a href="chap25.html#fragops-scissor">25.2. Scissor Test</a></li>
<li><a href="chap25.html#fragops-samplemask">25.3. Sample Mask</a></li>
<li><a href="chap25.html#fragops-early-mode">25.4. Early Fragment Test Mode</a></li>
<li><a href="chap25.html#fragops-late">25.5. Late Per-Fragment Tests</a></li>
<li><a href="chap25.html#fragops-covg">25.6. Multisample Coverage</a></li>
<li><a href="chap25.html#fragops-ds-state">25.7. Depth and Stencil Operations</a></li>
<li><a href="chap25.html#fragops-dbt">25.8. Depth Bounds Test</a></li>
<li><a href="chap25.html#fragops-stencil">25.9. Stencil Test</a></li>
<li><a href="chap25.html#fragops-depth">25.10. Depth Test</a></li>
<li><a href="chap25.html#fragops-samplecount">25.11. Sample Counting</a></li>
<li><a href="chap25.html#fragops-coverage-reduction">25.12. Coverage Reduction</a></li>
</ul>
</li>
<li><a href="chap26.html#framebuffer">26. The Framebuffer</a>
<ul class="sectlevel2">
<li><a href="chap26.html#framebuffer-blending">26.1. Blending</a></li>
<li><a href="chap26.html#framebuffer-logicop">26.2. Logical Operations</a></li>
<li><a href="chap26.html#framebuffer-color-write-mask">26.3. Color Write Mask</a></li>
</ul>
</li>
<li><a href="chap27.html#dispatch">27. Dispatching Commands</a></li>
<li><a href="chap28.html#sparsememory">28. Sparse Resources</a>
<ul class="sectlevel2">
<li><a href="chap28.html#sparsememory-sparseresourcefeatures">28.1. Sparse Resource Features</a></li>
<li><a href="chap28.html#sparsememory-fully-resident">28.2. Sparse Buffers and Fully-Resident Images</a></li>
<li><a href="chap28.html#sparsememory-partially-resident-buffers">28.3. Sparse Partially-Resident Buffers</a></li>
<li><a href="chap28.html#sparsememory-partially-resident-images">28.4. Sparse Partially-Resident Images</a></li>
<li><a href="chap28.html#sparsememory-sparse-memory-aliasing">28.5. Sparse Memory Aliasing</a></li>
<li><a href="chap28.html#_sparse_resource_implementation_guidelines">28.6. Sparse Resource Implementation Guidelines</a></li>
<li><a href="chap28.html#sparsememory-resourceapi">28.7. Sparse Resource API</a></li>
<li><a href="chap28.html#sparsememory-examples">28.8. Examples</a></li>
</ul>
</li>
<li><a href="chap29.html#wsi">29. Window System Integration (WSI)</a>
<ul class="sectlevel2">
<li><a href="chap29.html#_wsi_platform">29.1. WSI Platform</a></li>
<li><a href="chap29.html#_wsi_surface">29.2. WSI Surface</a></li>
<li><a href="chap29.html#display">29.3. Presenting Directly to Display Devices</a></li>
<li><a href="chap29.html#_querying_for_wsi_support">29.4. Querying for WSI Support</a></li>
<li><a href="chap29.html#_surface_queries">29.5. Surface Queries</a></li>
<li><a href="chap29.html#_device_group_queries">29.6. Device Group Queries</a></li>
<li><a href="chap29.html#_wsi_swapchain">29.7. WSI Swapchain</a></li>
</ul>
</li>
<li><a href="chap30.html#deferred-host-operations">30. Deferred Host Operations</a>
<ul class="sectlevel2">
<li><a href="chap30.html#_requesting_deferral">30.1. Requesting Deferral</a></li>
<li><a href="chap30.html#_deferred_host_operations_api">30.2. Deferred Host Operations API</a></li>
</ul>
</li>
<li><a href="chap31.html#ray-traversal">31. Ray Traversal</a>
<ul class="sectlevel2">
<li><a href="chap31.html#_ray_intersection_candidate_determination">31.1. Ray Intersection Candidate Determination</a></li>
<li><a href="chap31.html#_ray_intersection_culling">31.2. Ray Intersection Culling</a></li>
<li><a href="chap31.html#_ray_intersection_confirmation">31.3. Ray Intersection Confirmation</a></li>
<li><a href="chap31.html#_ray_closest_hit_determination">31.4. Ray Closest Hit Determination</a></li>
<li><a href="chap31.html#_ray_result_determination">31.5. Ray Result Determination</a></li>
</ul>
</li>
<li><a href="chap32.html#ray-tracing">32. Ray Tracing</a>
<ul class="sectlevel2">
<li><a href="chap32.html#ray-tracing-shader-call">32.1. Shader Call Instructions</a></li>
<li><a href="chap32.html#ray-tracing-commands">32.2. Ray Tracing Commands</a></li>
<li><a href="chap32.html#shader-binding-table">32.3. Shader Binding Table</a></li>
<li><a href="chap32.html#acceleration-structure">32.4. Acceleration Structures</a></li>
<li><a href="chap32.html#host-acceleration-structure">32.5. Host Acceleration Structure Operations</a></li>
</ul>
</li>
<li><a href="chap33.html#extendingvulkan">33. Extending Vulkan</a>
<ul class="sectlevel2">
<li><a href="chap33.html#extendingvulkan-instanceanddevicefunctionality">33.1. Instance and Device Functionality</a></li>
<li><a href="chap33.html#extendingvulkan-coreversions">33.2. Core Versions</a></li>
<li><a href="chap33.html#extendingvulkan-layers">33.3. Layers</a></li>
<li><a href="chap33.html#extendingvulkan-extensions">33.4. Extensions</a></li>
<li><a href="chap33.html#extendingvulkan-extensions-extensiondependencies">33.5. Extension Dependencies</a></li>
<li><a href="chap33.html#_compatibility_guarantees_informative">33.6. Compatibility Guarantees (Informative)</a></li>
</ul>
</li>
<li><a href="chap34.html#features">34. Features</a>
<ul class="sectlevel2">
<li><a href="chap34.html#features-requirements">34.1. Feature Requirements</a></li>
</ul>
</li>
<li><a href="chap35.html#limits">35. Limits</a>
<ul class="sectlevel2">
<li><a href="chap35.html#limits-minmax">35.1. Limit Requirements</a></li>
</ul>
</li>
<li><a href="chap36.html#formats">36. Formats</a>
<ul class="sectlevel2">
<li><a href="chap36.html#formats-definition">36.1. Format Definition</a></li>
<li><a href="chap36.html#formats-properties">36.2. Format Properties</a></li>
<li><a href="chap36.html#features-required-format-support">36.3. Required Format Support</a></li>
</ul>
</li>
<li><a href="chap37.html#capabilities">37. Additional Capabilities</a>
<ul class="sectlevel2">
<li><a href="chap37.html#capabilities-image">37.1. Additional Image Capabilities</a></li>
<li><a href="chap37.html#capabilities-buffer">37.2. Additional Buffer Capabilities</a></li>
<li><a href="chap37.html#capabilities-semaphore">37.3. Optional Semaphore Capabilities</a></li>
<li><a href="chap37.html#capabilities-fence">37.4. Optional Fence Capabilities</a></li>
</ul>
</li>
<li><a href="chap38.html#_debugging">38. Debugging</a></li>
<li><a href="chap39.html#spirvenv">Appendix A: Vulkan Environment for SPIR-V</a>
<ul class="sectlevel2">
<li><a href="chap39.html#_versions_and_formats">Versions and Formats</a></li>
<li><a href="chap39.html#spirvenv-capabilities">Capabilities</a></li>
<li><a href="chap39.html#spirvenv-module-validation">Validation Rules within a Module</a></li>
<li><a href="chap39.html#spirvenv-precision-operation">Precision and Operation of SPIR-V Instructions</a></li>
<li><a href="chap39.html#spirvenv-image-formats">Compatibility Between SPIR-V Image Formats And Vulkan Formats</a></li>
</ul>
</li>
<li><a href="chap40.html#memory-model">Appendix B: Memory Model</a>
<ul class="sectlevel2">
<li><a href="chap40.html#memory-model-agent">Agent</a></li>
<li><a href="chap40.html#memory-model-memory-location">Memory Location</a></li>
<li><a href="chap40.html#memory-model-allocation">Allocation</a></li>
<li><a href="chap40.html#memory-model-memory-operation">Memory Operation</a></li>
<li><a href="chap40.html#memory-model-references">Reference</a></li>
<li><a href="chap40.html#memory-model-program-order">Program-Order</a></li>
<li><a href="chap40.html#shader-call-related">Shader Call Related</a></li>
<li><a href="chap40.html#shader-call-order">Shader Call Order</a></li>
<li><a href="chap40.html#memory-model-scope">Scope</a></li>
<li><a href="chap40.html#memory-model-atomic-operation">Atomic Operation</a></li>
<li><a href="chap40.html#memory-model-scoped-modification-order">Scoped Modification Order</a></li>
<li><a href="chap40.html#memory-model-memory-semantics">Memory Semantics</a></li>
<li><a href="chap40.html#memory-model-release-sequence">Release Sequence</a></li>
<li><a href="chap40.html#memory-model-synchronizes-with">Synchronizes-With</a></li>
<li><a href="chap40.html#memory-model-system-synchronizes-with">System-Synchronizes-With</a></li>
<li><a href="chap40.html#memory-model-non-private">Private vs. Non-Private</a></li>
<li><a href="chap40.html#memory-model-inter-thread-happens-before">Inter-Thread-Happens-Before</a></li>
<li><a href="chap40.html#memory-model-happens-before">Happens-Before</a></li>
<li><a href="chap40.html#memory-model-availability-visibility">Availability and Visibility</a></li>
<li><a href="chap40.html#memory-model-vulkan-availability-visibility">Availability, Visibility, and Domain Operations</a></li>
<li><a href="chap40.html#memory-model-availability-visibility-semantics">Availability and Visibility Semantics</a></li>
<li><a href="chap40.html#memory-model-instruction-av-vis">Per-Instruction Availability and Visibility Semantics</a></li>
<li><a href="chap40.html#memory-model-location-ordered">Location-Ordered</a></li>
<li><a href="chap40.html#memory-model-access-data-race">Data Race</a></li>
<li><a href="chap40.html#memory-model-visible-to">Visible-To</a></li>
<li><a href="chap40.html#memory-model-acyclicity">Acyclicity</a></li>
<li><a href="chap40.html#memory-model-shader-io">Shader I/O</a></li>
<li><a href="chap40.html#memory-model-deallocation">Deallocation</a></li>
<li><a href="chap40.html#memory-model-informative-descriptions">Informative Descriptions</a></li>
<li><a href="chap40.html#memory-model-tessellation-output-ordering">Tessellation Output Ordering</a></li>
</ul>
</li>
<li><a href="chap41.html#_compressed_image_formats">Appendix C: Compressed Image Formats</a>
<ul class="sectlevel2">
<li><a href="chap41.html#appendix-compressedtex-bc">Block-Compressed Image Formats</a></li>
<li><a href="chap41.html#appendix-compressedtex-etc2">ETC Compressed Image Formats</a></li>
<li><a href="chap41.html#appendix-compressedtex-astc">ASTC Compressed Image Formats</a></li>
</ul>
</li>
<li><a href="chap42.html#versions">Appendix D: Core Revisions (Informative)</a></li>
<li><a href="chap43.html#extensions">Appendix E: Layers &amp; Extensions (Informative)</a>
<ul class="sectlevel2">
<li><a href="chap43.html#extension-appendices-list">List of Extensions</a></li>
<li><a href="chap43.html#provisional-extension-appendices-list">List of Provisional Extensions</a></li>
</ul>
</li>
<li><a href="chap44.html#boilerplate">Appendix F: API Boilerplate</a>
<ul class="sectlevel2">
<li><a href="chap44.html#boilerplate-headers">Vulkan Header Files</a></li>
<li><a href="chap44.html#boilerplate-wsi-header">Window System-Specific Header Control (Informative)</a></li>
<li><a href="chap44.html#boilerplate-provisional-header">Provisional Extension Header Control (Informative)</a></li>
</ul>
</li>
<li><a href="chap45.html#invariance">Appendix G: Invariance</a>
<ul class="sectlevel2">
<li><a href="chap45.html#_repeatability">Repeatability</a></li>
<li><a href="chap45.html#_multi_pass_algorithms">Multi-pass Algorithms</a></li>
<li><a href="chap45.html#_invariance_rules">Invariance Rules</a></li>
<li><a href="chap45.html#_tessellation_invariance">Tessellation Invariance</a></li>
</ul>
</li>
<li><a href="chap46.html#glossary">Glossary</a></li>
<li><a href="chap47.html#_common_abbreviations">Common Abbreviations</a></li>
<li><a href="chap48.html#_prefixes">Prefixes</a></li>
<li><a href="chap49.html#credits">Appendix H: Credits (Informative)</a>
<ul class="sectlevel2">
<li><a href="chap49.html#_working_group_contributors_to_vulkan">Working Group Contributors to Vulkan</a></li>
<li><a href="chap49.html#_other_credits">Other Credits</a></li>
</ul>
</li>
</ul>
</div>
<div class="searchbox"><label for="searchbox">Search: </label><input id="searchbox" type="text" disabled="disabled" value="Loading Search Data"><div id="resultsdiv"><ol id="results"></ol></div></div>
</div>

<div id="loading_msg"><p>Loading... please wait.</p></div>
<div id="content"><div class="sect1">
<h2 id="descriptorsets"><a class="anchor" href="#descriptorsets"></a>13. Resource Descriptors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <em>descriptor</em> is an opaque data structure representing a shader resource
such as a buffer, buffer view, image view, sampler, or combined image
sampler.
Descriptors are organised into <em>descriptor sets</em>, which are bound during
command recording for use in subsequent draw commands.
The arrangement of content in each descriptor set is determined by a
<em>descriptor set layout</em>, which determines what descriptors can be stored
within it.
The sequence of descriptor set layouts that <strong class="purple">can</strong> be used by a pipeline is
specified in a <em>pipeline layout</em>.
Each pipeline object <strong class="purple">can</strong> use up to <code>maxBoundDescriptorSets</code> (see
<a href="chap35.html#limits">Limits</a>) descriptor sets.</p>
</div>
<div class="paragraph">
<p>Shaders access resources via variables decorated with a descriptor set and
binding number that link them to a descriptor in a descriptor set.
The shader interface mapping to bound descriptor sets is described in the
<a href="chap14.html#interfaces-resources">Shader Resource Interface</a> section.</p>
</div>
<div class="paragraph">
<p>Shaders <strong class="purple">can</strong> also access buffers without going through descriptors by using
<a href="#descriptorsets-physical-storage-buffer">Physical Storage Buffer Access</a> to
access them through 64-bit addresses.</p>
</div>
<div class="sect2">
<h3 id="descriptorsets-types"><a class="anchor" href="#descriptorsets-types"></a>13.1. Descriptor Types</h3>
<div class="paragraph">
<p>There are a number of different types of descriptor supported by Vulkan,
corresponding to different resources or usage.
The following sections describe the API definitions of each descriptor type.
The mapping of each type to SPIR-V is listed in the
<a href="chap14.html#interfaces-resources-correspondence">Shader Resource and Descriptor Type
Correspondence</a> and <a href="chap14.html#interfaces-resources-storage-class-correspondence">Shader Resource and Storage Class Correspondence</a> tables in the
<a href="chap14.html#interfaces">Shader Interfaces</a> chapter.</p>
</div>
<div class="sect3">
<h4 id="descriptorsets-storageimage"><a class="anchor" href="#descriptorsets-storageimage"></a>13.1.1. Storage Image</h4>
<div class="paragraph">
<p>A <em>storage image</em> (<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>) is a descriptor
type associated with an <a href="chap11.html#resources-images">image resource</a> via an
<a href="chap11.html#resources-image-views">image view</a> that load, store, and atomic
operations <strong class="purple">can</strong> be performed on.</p>
</div>
<div class="paragraph">
<p>Storage image loads are supported in all shader stages for image views whose
<a href="chap11.html#resources-image-view-format-features">format features</a> contain
<a href="chap36.html#formats-properties"><code>VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT</code></a>.</p>
</div>
<div class="paragraph">
<p>Stores to storage images are supported in compute shaders for image views
whose <a href="chap11.html#resources-image-view-format-features">format features</a> contain
<a href="chap36.html#formats-properties"><code>VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT</code></a>.</p>
</div>
<div class="paragraph">
<p>Atomic operations on storage images are supported in compute shaders for
image views whose <a href="chap11.html#resources-image-view-format-features">format features</a>
contain
<a href="chap36.html#formats-properties"><code>VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT</code></a>.</p>
</div>
<div class="paragraph">
<p>When the <a href="chap34.html#features-fragmentStoresAndAtomics"><code>fragmentStoresAndAtomics</code></a> feature is enabled, stores and atomic
operations are also supported for storage images in fragment shaders with
the same set of image formats as supported in compute shaders.
When the <a href="chap34.html#features-vertexPipelineStoresAndAtomics"><code>vertexPipelineStoresAndAtomics</code></a> feature is enabled, stores and atomic
operations are also supported in vertex, tessellation, and geometry shaders
with the same set of image formats as supported in compute shaders.</p>
</div>
<div class="paragraph">
<p>The image subresources for a storage image <strong class="purple">must</strong> be in the
<code>VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR</code> or
<code>VK_IMAGE_LAYOUT_GENERAL</code> layout in order to access its data in a
shader.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-sampler"><a class="anchor" href="#descriptorsets-sampler"></a>13.1.2. Sampler</h4>
<div class="paragraph">
<p>A <em>sampler descriptor</em> (<code>VK_DESCRIPTOR_TYPE_SAMPLER</code>) is a descriptor
type associated with a <a href="chap12.html#samplers">sampler</a> object, used to control the
behavior of <a href="chap15.html#textures">sampling operations</a> performed on a
<a href="#descriptorsets-sampledimage">sampled image</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-sampledimage"><a class="anchor" href="#descriptorsets-sampledimage"></a>13.1.3. Sampled Image</h4>
<div class="paragraph">
<p>A <em>sampled image</em> (<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>) is a descriptor
type associated with an <a href="chap11.html#resources-images">image resource</a> via an
<a href="chap11.html#resources-image-views">image view</a> that <a href="chap15.html#textures">sampling operations</a>
<strong class="purple">can</strong> be performed on.</p>
</div>
<div class="paragraph">
<p>Shaders combine a sampled image variable and a sampler variable to perform
sampling operations.</p>
</div>
<div class="paragraph">
<p>Sampled images are supported in all shader stages for image views whose
<a href="chap11.html#resources-image-view-format-features">format features</a> contain
<a href="chap36.html#formats-properties"><code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</code></a>.</p>
</div>
<div class="paragraph">
<p>The image subresources for a sampled image <strong class="purple">must</strong> be in the
<code>VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>, or
<code>VK_IMAGE_LAYOUT_GENERAL</code> layout in order to access its data in a
shader.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-combinedimagesampler"><a class="anchor" href="#descriptorsets-combinedimagesampler"></a>13.1.4. Combined Image Sampler</h4>
<div class="paragraph">
<p>A <em>combined image sampler</em> (<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>)
is a single descriptor type associated with both a <a href="chap12.html#samplers">sampler</a> and
an <a href="chap11.html#resources-images">image resource</a>, combining both a
<a href="#descriptorsets-sampler">sampler</a> and <a href="#descriptorsets-sampledimage">sampled image</a> descriptor into a single descriptor.</p>
</div>
<div class="paragraph">
<p>If the descriptor refers to a sampler that performs
<a href="chap12.html#samplers-YCbCr-conversion">Y′C<sub>B</sub>C<sub>R</sub> conversion</a>,
the sampler <strong class="purple">must</strong> only be used to sample the image in the same descriptor.
Otherwise, the
sampler and image in this type of descriptor <strong class="purple">can</strong> be used freely with any
other samplers and images.</p>
</div>
<div class="paragraph">
<p>The image subresources for a combined image sampler <strong class="purple">must</strong> be in the
<code>VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>, or
<code>VK_IMAGE_LAYOUT_GENERAL</code> layout in order to access its data in a
shader.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>On some implementations, it <strong class="purple">may</strong> be more efficient to sample from an image
using a combination of sampler and sampled image that are stored together in
the descriptor set in a combined descriptor.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-uniformtexelbuffer"><a class="anchor" href="#descriptorsets-uniformtexelbuffer"></a>13.1.5. Uniform Texel Buffer</h4>
<div class="paragraph">
<p>A <em>uniform texel buffer</em> (<code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>) is
a descriptor type associated with a <a href="chap11.html#resources-buffers">buffer resource</a>
via a <a href="chap11.html#resources-buffer-views">buffer view</a> that <a href="chap15.html#textures">formatted load
operations</a> <strong class="purple">can</strong> be performed on.</p>
</div>
<div class="paragraph">
<p>Uniform texel buffers define a tightly-packed 1-dimensional linear array of
texels, with texels going through format conversion when read in a shader in
the same way as they are for an image.</p>
</div>
<div class="paragraph">
<p>Load operations from uniform texel buffers are supported in all shader
stages for image formats which report support for the
<a href="chap36.html#formats-properties"><code>VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT</code></a>
feature bit via <a href="chap36.html#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a> in
<a href="chap36.html#VkFormatProperties">VkFormatProperties</a>::<code>bufferFeatures</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-storagetexelbuffer"><a class="anchor" href="#descriptorsets-storagetexelbuffer"></a>13.1.6. Storage Texel Buffer</h4>
<div class="paragraph">
<p>A <em>storage texel buffer</em> (<code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>) is
a descriptor type associated with a <a href="chap11.html#resources-buffers">buffer resource</a>
via a <a href="chap11.html#resources-buffer-views">buffer view</a> that <a href="chap15.html#textures">formatted
load, store, and atomic operations</a> <strong class="purple">can</strong> be performed on.</p>
</div>
<div class="paragraph">
<p>Storage texel buffers define a tightly-packed 1-dimensional linear array of
texels, with texels going through format conversion when read in a shader in
the same way as they are for an image.
Unlike <a href="#descriptorsets-uniformtexelbuffer">uniform texel buffers</a>, these
buffers can also be written to in the same way as for
<a href="#descriptorsets-storageimage">storage images</a>.</p>
</div>
<div class="paragraph">
<p>Storage texel buffer loads are supported in all shader stages for texel
buffer formats which report support for the
<a href="chap36.html#formats-properties"><code>VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT</code></a>
feature bit via <a href="chap36.html#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a> in
<a href="chap36.html#VkFormatProperties">VkFormatProperties</a>::<code>bufferFeatures</code>.</p>
</div>
<div class="paragraph">
<p>Stores to storage texel buffers are supported in compute shaders for texel
buffer formats which report support for the
<code>VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT</code> feature via
<a href="chap36.html#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a> in
<a href="chap36.html#VkFormatProperties">VkFormatProperties</a>::<code>bufferFeatures</code>.</p>
</div>
<div class="paragraph">
<p>Atomic operations on storage texel buffers are supported in compute shaders
for texel buffer formats which report support for the
<a href="chap36.html#formats-properties"><code>VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT</code></a>
feature via <a href="chap36.html#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a> in
<a href="chap36.html#VkFormatProperties">VkFormatProperties</a>::<code>bufferFeatures</code>.</p>
</div>
<div class="paragraph">
<p>When the <a href="chap34.html#features-fragmentStoresAndAtomics"><code>fragmentStoresAndAtomics</code></a> feature is enabled, stores and atomic
operations are also supported for storage texel buffers in fragment shaders
with the same set of texel buffer formats as supported in compute shaders.
When the <a href="chap34.html#features-vertexPipelineStoresAndAtomics"><code>vertexPipelineStoresAndAtomics</code></a> feature is enabled, stores and atomic
operations are also supported in vertex, tessellation, and geometry shaders
with the same set of texel buffer formats as supported in compute shaders.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-storagebuffer"><a class="anchor" href="#descriptorsets-storagebuffer"></a>13.1.7. Storage Buffer</h4>
<div class="paragraph">
<p>A <em>storage buffer</em> (<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>) is a descriptor
type associated with a <a href="chap11.html#resources-buffers">buffer resource</a> directly,
described in a shader as a structure with various members that load, store,
and atomic operations <strong class="purple">can</strong> be performed on.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Atomic operations <strong class="purple">can</strong> only be performed on members of certain types as
defined in the <a href="chap39.html#spirvenv">SPIR-V environment appendix</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-uniformbuffer"><a class="anchor" href="#descriptorsets-uniformbuffer"></a>13.1.8. Uniform Buffer</h4>
<div class="paragraph">
<p>A <em>uniform buffer</em> (<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>) is a descriptor
type associated with a <a href="chap11.html#resources-buffers">buffer resource</a> directly,
described in a shader as a structure with various members that load
operations <strong class="purple">can</strong> be performed on.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-uniformbufferdynamic"><a class="anchor" href="#descriptorsets-uniformbufferdynamic"></a>13.1.9. Dynamic Uniform Buffer</h4>
<div class="paragraph">
<p>A <em>dynamic uniform buffer</em> (<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>)
is almost identical to a <a href="#descriptorsets-uniformbuffer">uniform buffer</a>,
and differs only in how the offset into the buffer is specified.
The base offset calculated by the <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a> when
initially <a href="#descriptorsets-updates">updating the descriptor set</a> is added
to a <a href="#descriptorsets-binding-dynamicoffsets">dynamic offset</a> when binding
the descriptor set.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-storagebufferdynamic"><a class="anchor" href="#descriptorsets-storagebufferdynamic"></a>13.1.10. Dynamic Storage Buffer</h4>
<div class="paragraph">
<p>A <em>dynamic storage buffer</em> (<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>)
is almost identical to a <a href="#descriptorsets-storagebuffer">storage buffer</a>,
and differs only in how the offset into the buffer is specified.
The base offset calculated by the <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a> when
initially <a href="#descriptorsets-updates">updating the descriptor set</a> is added
to a <a href="#descriptorsets-binding-dynamicoffsets">dynamic offset</a> when binding
the descriptor set.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-inputattachment"><a class="anchor" href="#descriptorsets-inputattachment"></a>13.1.11. Input Attachment</h4>
<div class="paragraph">
<p>An <em>input attachment</em> (<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>) is a
descriptor type associated with an <a href="chap11.html#resources-images">image resource</a> via
an <a href="chap11.html#resources-image-views">image view</a> that <strong class="purple">can</strong> be used for
<a href="chap6.html#synchronization-framebuffer-regions">framebuffer local</a> load operations in
fragment shaders.</p>
</div>
<div class="paragraph">
<p>All image formats that are supported for color attachments
(<code>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</code>) or depth/stencil attachments
(<code>VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</code>) for a given image
tiling mode are also supported for input attachments.</p>
</div>
<div class="paragraph">
<p>The image subresources for an input attachment <strong class="purple">must</strong> be in the
<code>VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</code>,
<code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>, or
<code>VK_IMAGE_LAYOUT_GENERAL</code> layout in order to access its data in a
shader.</p>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-accelerationstructure"><a class="anchor" href="#descriptorsets-accelerationstructure"></a>13.1.12. Acceleration Structure</h4>
<div class="paragraph">
<p>An <em>acceleration structure</em>
(<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code>) is a descriptor type
that is used to retrieve scene geometry from within shaders bound to ray
tracing pipelines.
Shaders have read-only access to the memory.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="descriptorsets-sets"><a class="anchor" href="#descriptorsets-sets"></a>13.2. Descriptor Sets</h3>
<div class="paragraph">
<p>Descriptors are grouped together into descriptor set objects.
A descriptor set object is an opaque object containing storage for a set of
descriptors, where the types and number of descriptors is defined by a
descriptor set layout.
The layout object <strong class="purple">may</strong> be used to define the association of each descriptor
binding with memory or other implementation resources.
The layout is used both for determining the resources that need to be
associated with the descriptor set, and determining the interface between
shader stages and shader resources.</p>
</div>
<div class="sect3">
<h4 id="descriptorsets-setlayout"><a class="anchor" href="#descriptorsets-setlayout"></a>13.2.1. Descriptor Set Layout</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>A descriptor set layout object is defined by an array of zero or more
descriptor bindings.
Each individual descriptor binding is specified by a descriptor type, a
count (array size) of the number of descriptors in the binding, a set of
shader stages that <strong class="purple">can</strong> access the binding, and (if using immutable
samplers) an array of sampler descriptors.</p>
</div>
<div class="paragraph">
<p>Descriptor set layout objects are represented by <code>VkDescriptorSetLayout</code>
handles:</p>
</div>
<div id="VkDescriptorSetLayout" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create descriptor set layout objects, call:</p>
</div>
<div id="vkCreateDescriptorSetLayout" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateDescriptorSetLayout(
    VkDevice                                    device,
    <span class="directive">const</span> VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkDescriptorSetLayout*                      pSetLayout);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that creates the descriptor set
layout.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to a
<a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a> structure specifying the state of
the descriptor set layout object.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap10.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
<li>
<p><code>pSetLayout</code> is a pointer to a <a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a> handle in
which the resulting descriptor set layout object is returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateDescriptorSetLayout-device-parameter" href="#VUID-vkCreateDescriptorSetLayout-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorSetLayout-pCreateInfo-parameter" href="#VUID-vkCreateDescriptorSetLayout-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorSetLayout-pAllocator-parameter" href="#VUID-vkCreateDescriptorSetLayout-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap10.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorSetLayout-pSetLayout-parameter" href="#VUID-vkCreateDescriptorSetLayout-pSetLayout-parameter"></a> <code>pSetLayout</code> <strong class="purple">must</strong> be a valid pointer to a <a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Information about the descriptor set layout is passed in a
<code>VkDescriptorSetLayoutCreateInfo</code> structure:</p>
</div>
<div id="VkDescriptorSetLayoutCreateInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorSetLayoutCreateInfo {
    VkStructureType                        sType;
    <span class="directive">const</span> <span class="directive">void</span>*                            pNext;
    VkDescriptorSetLayoutCreateFlags       flags;
    uint32_t                               bindingCount;
    <span class="directive">const</span> VkDescriptorSetLayoutBinding*    pBindings;
} VkDescriptorSetLayoutCreateInfo;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is a bitmask
of <a href="#VkDescriptorSetLayoutCreateFlagBits">VkDescriptorSetLayoutCreateFlagBits</a>
specifying options for descriptor set layout creation.</p>
</li>
<li>
<p><code>bindingCount</code> is the number of elements in <code>pBindings</code>.</p>
</li>
<li>
<p><code>pBindings</code> is a pointer to an array of
<a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a> structures.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-binding-00279" href="#VUID-VkDescriptorSetLayoutCreateInfo-binding-00279"></a>
The <a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a>::<code>binding</code> members of the
elements of the <code>pBindings</code> array <strong class="purple">must</strong> each have different values.</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-flags-00280" href="#VUID-VkDescriptorSetLayoutCreateInfo-flags-00280"></a>
If <code>flags</code> contains
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code>, then all
elements of <code>pBindings</code> <strong class="purple">must</strong> not have a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-flags-00281" href="#VUID-VkDescriptorSetLayoutCreateInfo-flags-00281"></a>
If <code>flags</code> contains
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code>, then the
total number of elements of all bindings <strong class="purple">must</strong> be less than or equal to
<a href="chap35.html#VkPhysicalDevicePushDescriptorPropertiesKHR">VkPhysicalDevicePushDescriptorPropertiesKHR</a>::<code>maxPushDescriptors</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-sType-sType" href="#VUID-VkDescriptorSetLayoutCreateInfo-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext" href="#VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter" href="#VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter"></a> <code>flags</code> <strong class="purple">must</strong> be a valid combination of <a href="#VkDescriptorSetLayoutCreateFlagBits">VkDescriptorSetLayoutCreateFlagBits</a> values</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter" href="#VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter"></a> If <code>bindingCount</code> is not <code>0</code>, <code>pBindings</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>bindingCount</code> valid <a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a> structures</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Bits which <strong class="purple">can</strong> be set in <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>::<code>flags</code>
to specify options for descriptor set layout are:</p>
</div>
<div id="VkDescriptorSetLayoutCreateFlagBits" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">enum</span> VkDescriptorSetLayoutCreateFlagBits {
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = <span class="hex">0x00000001</span>,
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = <span class="hex">0x7FFFFFFF</span>
} VkDescriptorSetLayoutCreateFlagBits;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code> specifies
that descriptor sets <strong class="purple">must</strong> not be allocated using this layout, and
descriptors are instead pushed by <a href="#vkCmdPushDescriptorSetKHR">vkCmdPushDescriptorSetKHR</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkDescriptorSetLayoutCreateFlags" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkFlags VkDescriptorSetLayoutCreateFlags;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkDescriptorSetLayoutCreateFlags</code> is a bitmask type for setting a mask
of zero or more <a href="#VkDescriptorSetLayoutCreateFlagBits">VkDescriptorSetLayoutCreateFlagBits</a>.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDescriptorSetLayoutBinding</code> structure is defined as:</p>
</div>
<div id="VkDescriptorSetLayoutBinding" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorSetLayoutBinding {
    uint32_t              binding;
    VkDescriptorType      descriptorType;
    uint32_t              descriptorCount;
    VkShaderStageFlags    stageFlags;
    <span class="directive">const</span> VkSampler*      pImmutableSamplers;
} VkDescriptorSetLayoutBinding;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>binding</code> is the binding number of this entry and corresponds to a
resource of the same binding number in the shader stages.</p>
</li>
<li>
<p><code>descriptorType</code> is a <a href="#VkDescriptorType">VkDescriptorType</a> specifying which type
of resource descriptors are used for this binding.</p>
</li>
<li>
<p><code>descriptorCount</code> is the number of descriptors contained in the
binding, accessed in a shader as an array
.
If <code>descriptorCount</code> is zero this binding entry is reserved and the
resource <strong class="purple">must</strong> not be accessed from any stage via this binding within
any pipeline using the set layout.</p>
</li>
<li>
<p><code>stageFlags</code> member is a bitmask of <a href="chap9.html#VkShaderStageFlagBits">VkShaderStageFlagBits</a>
specifying which pipeline shader stages <strong class="purple">can</strong> access a resource for this
binding.
<code>VK_SHADER_STAGE_ALL</code> is a shorthand specifying that all defined
shader stages, including any additional stages defined by extensions,
<strong class="purple">can</strong> access the resource.</p>
<div class="paragraph">
<p>If a shader stage is not included in <code>stageFlags</code>, then a resource <strong class="purple">must</strong>
not be accessed from that stage via this binding within any pipeline using
the set layout.
Other than input attachments which are limited to the fragment shader, there
are no limitations on what combinations of stages <strong class="purple">can</strong> use a descriptor
binding, and in particular a binding <strong class="purple">can</strong> be used by both graphics stages
and the compute stage.</p>
</div>
</li>
<li>
<p><code>pImmutableSamplers</code> affects initialization of samplers.
If <code>descriptorType</code> specifies a <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> or
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> type descriptor, then
<code>pImmutableSamplers</code> <strong class="purple">can</strong> be used to initialize a set of <em>immutable
samplers</em>.
Immutable samplers are permanently bound into the set layout and <strong class="purple">must</strong>
not be changed; updating a <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> descriptor
with immutable samplers is not allowed and updates to a
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> descriptor with
immutable samplers does not modify the samplers (the image views are
updated, but the sampler updates are ignored).
If <code>pImmutableSamplers</code> is not <code>NULL</code>, then it points to an array of
sampler handles that will be copied into the set layout and used for the
corresponding binding.
Only the sampler handles are copied; the sampler objects <strong class="purple">must</strong> not be
destroyed before the final use of the set layout and any descriptor
pools and sets created using it.
If <code>pImmutableSamplers</code> is <code>NULL</code>, then the sampler slots are
dynamic and sampler handles <strong class="purple">must</strong> be bound into descriptor sets using
this layout.
If <code>descriptorType</code> is not one of these descriptor types, then
<code>pImmutableSamplers</code> is ignored.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The above layout definition allows the descriptor bindings to be specified
sparsely such that not all binding numbers between 0 and the maximum binding
number need to be specified in the <code>pBindings</code> array.
Bindings that are not specified have a <code>descriptorCount</code> and
<code>stageFlags</code> of zero, and the value of <code>descriptorType</code> is
undefined.
However, all binding numbers between 0 and the maximum binding number in the
<a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>::<code>pBindings</code> array <strong class="purple">may</strong> consume
memory in the descriptor set layout even if not all descriptor bindings are
used, though it <strong class="purple">should</strong> not consume additional memory from the descriptor
pool.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>The maximum binding number specified <strong class="purple">should</strong> be as compact as possible to
avoid wasted memory.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBinding-descriptorType-00282" href="#VUID-VkDescriptorSetLayoutBinding-descriptorType-00282"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> or
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and
<code>descriptorCount</code> is not <code>0</code> and <code>pImmutableSamplers</code> is not
<code>NULL</code>, <code>pImmutableSamplers</code> <strong class="purple">must</strong> be a valid pointer to an array of
<code>descriptorCount</code> valid <code>VkSampler</code> handles</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBinding-descriptorCount-00283" href="#VUID-VkDescriptorSetLayoutBinding-descriptorCount-00283"></a>
If <code>descriptorCount</code> is not <code>0</code>, <code>stageFlags</code> <strong class="purple">must</strong> be a valid
combination of <a href="chap9.html#VkShaderStageFlagBits">VkShaderStageFlagBits</a> values</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBinding-descriptorType-01510" href="#VUID-VkDescriptorSetLayoutBinding-descriptorType-01510"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> and
<code>descriptorCount</code> is not <code>0</code>, then <code>stageFlags</code> <strong class="purple">must</strong> be <code>0</code> or
<code>VK_SHADER_STAGE_FRAGMENT_BIT</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter" href="#VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter"></a> <code>descriptorType</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorType">VkDescriptorType</a> value</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query information about whether a descriptor set layout <strong class="purple">can</strong> be created,
call:</p>
</div>
<div id="vkGetDescriptorSetLayoutSupportKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> vkGetDescriptorSetLayoutSupportKHR(
    VkDevice                                    device,
    <span class="directive">const</span> VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    VkDescriptorSetLayoutSupport*               pSupport);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that would create the descriptor set
layout.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to a
<a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a> structure specifying the state of
the descriptor set layout object.</p>
</li>
<li>
<p><code>pSupport</code> is a pointer to a <a href="#VkDescriptorSetLayoutSupport">VkDescriptorSetLayoutSupport</a>
structure, in which information about support for the descriptor set
layout object is returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some implementations have limitations on what fits in a descriptor set which
are not easily expressible in terms of existing limits like
<code>maxDescriptorSet</code>*, for example if all descriptor types share a limited
space in memory but each descriptor is a different size or alignment.
This command returns information about whether a descriptor set satisfies
this limit.
If the descriptor set layout satisfies the
<a href="chap35.html#VkPhysicalDeviceMaintenance3Properties">VkPhysicalDeviceMaintenance3Properties</a>::<code>maxPerSetDescriptors</code>
limit, this command is guaranteed to return <code>VK_TRUE</code> in
<a href="#VkDescriptorSetLayoutSupport">VkDescriptorSetLayoutSupport</a>::<code>supported</code>.
If the descriptor set layout exceeds the
<a href="chap35.html#VkPhysicalDeviceMaintenance3Properties">VkPhysicalDeviceMaintenance3Properties</a>::<code>maxPerSetDescriptors</code>
limit, whether the descriptor set layout is supported is
implementation-dependent and <strong class="purple">may</strong> depend on whether the descriptor sizes and
alignments cause the layout to exceed an internal limit.</p>
</div>
<div class="paragraph">
<p>This command does not consider other limits such as
<code>maxPerStageDescriptor</code>*, and so a descriptor set layout that is
supported according to this command <strong class="purple">must</strong> still satisfy the pipeline layout
limits such as <code>maxPerStageDescriptor</code>* in order to be used in a
pipeline layout.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>This is a <code>VkDevice</code> query rather than <code>VkPhysicalDevice</code> because
the answer <strong class="purple">may</strong> depend on enabled features.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetDescriptorSetLayoutSupport-device-parameter" href="#VUID-vkGetDescriptorSetLayoutSupport-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkGetDescriptorSetLayoutSupport-pCreateInfo-parameter" href="#VUID-vkGetDescriptorSetLayoutSupport-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a> structure</p>
</li>
<li>
<p><a id="VUID-vkGetDescriptorSetLayoutSupport-pSupport-parameter" href="#VUID-vkGetDescriptorSetLayoutSupport-pSupport-parameter"></a> <code>pSupport</code> <strong class="purple">must</strong> be a valid pointer to a <a href="#VkDescriptorSetLayoutSupport">VkDescriptorSetLayoutSupport</a> structure</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Information about support for the descriptor set layout is returned in a
<code>VkDescriptorSetLayoutSupport</code> structure:</p>
</div>
<div id="VkDescriptorSetLayoutSupport" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorSetLayoutSupport {
    VkStructureType    sType;
    <span class="directive">void</span>*              pNext;
    VkBool32           supported;
} VkDescriptorSetLayoutSupport;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorSetLayoutSupportKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkDescriptorSetLayoutSupport VkDescriptorSetLayoutSupportKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>supported</code> specifies whether the descriptor set layout <strong class="purple">can</strong> be
created.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>supported</code> is set to <code>VK_TRUE</code> if the descriptor set <strong class="purple">can</strong> be
created, or else is set to <code>VK_FALSE</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetLayoutSupport-sType-sType" href="#VUID-VkDescriptorSetLayoutSupport-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetLayoutSupport-pNext-pNext" href="#VUID-VkDescriptorSetLayoutSupport-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following examples show a shader snippet using two descriptor sets, and
application code that creates corresponding descriptor set layouts.</p>
</div>
<div class="listingblock">
<div class="title">GLSL example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="glsl">//
// binding to a single sampled image descriptor in set 0
//
layout (set=0, binding=0) uniform texture2D mySampledImage;

//
// binding to an array of sampled image descriptors in set 0
//
layout (set=0, binding=1) uniform texture2D myArrayOfSampledImages[12];

//
// binding to a single uniform buffer descriptor in set 1
//
layout (set=1, binding=0) uniform myUniformBuffer
{
    vec4 myElement[32];
};</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">SPIR-V example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="spirv">               ...
          %1 = OpExtInstImport &quot;GLSL.std.450&quot;
               ...
               OpName %9 &quot;mySampledImage&quot;
               OpName %14 &quot;myArrayOfSampledImages&quot;
               OpName %18 &quot;myUniformBuffer&quot;
               OpMemberName %18 0 &quot;myElement&quot;
               OpName %20 &quot;&quot;
               OpDecorate %9 DescriptorSet 0
               OpDecorate %9 Binding 0
               OpDecorate %14 DescriptorSet 0
               OpDecorate %14 Binding 1
               OpDecorate %17 ArrayStride 16
               OpMemberDecorate %18 0 Offset 0
               OpDecorate %18 Block
               OpDecorate %20 DescriptorSet 1
               OpDecorate %20 Binding 0
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 2D 0 0 0 1 Unknown
          %8 = OpTypePointer UniformConstant %7
          %9 = OpVariable %8 UniformConstant
         %10 = OpTypeInt 32 0
         %11 = OpConstant %10 12
         %12 = OpTypeArray %7 %11
         %13 = OpTypePointer UniformConstant %12
         %14 = OpVariable %13 UniformConstant
         %15 = OpTypeVector %6 4
         %16 = OpConstant %10 32
         %17 = OpTypeArray %15 %16
         %18 = OpTypeStruct %17
         %19 = OpTypePointer Uniform %18
         %20 = OpVariable %19 Uniform
               ...</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">API example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult myResult;

<span class="directive">const</span> VkDescriptorSetLayoutBinding myDescriptorSetLayoutBinding[] =
{
    <span class="comment">// binding to a single image descriptor</span>
    {
        <span class="integer">0</span>,                                      <span class="comment">// binding</span>
        VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,       <span class="comment">// descriptorType</span>
        <span class="integer">1</span>,                                      <span class="comment">// descriptorCount</span>
        VK_SHADER_STAGE_FRAGMENT_BIT,           <span class="comment">// stageFlags</span>
        <span class="predefined-constant">NULL</span>                                    <span class="comment">// pImmutableSamplers</span>
    },

    <span class="comment">// binding to an array of image descriptors</span>
    {
        <span class="integer">1</span>,                                      <span class="comment">// binding</span>
        VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,       <span class="comment">// descriptorType</span>
        <span class="integer">12</span>,                                     <span class="comment">// descriptorCount</span>
        VK_SHADER_STAGE_FRAGMENT_BIT,           <span class="comment">// stageFlags</span>
        <span class="predefined-constant">NULL</span>                                    <span class="comment">// pImmutableSamplers</span>
    },

    <span class="comment">// binding to a single uniform buffer descriptor</span>
    {
        <span class="integer">0</span>,                                      <span class="comment">// binding</span>
        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,      <span class="comment">// descriptorType</span>
        <span class="integer">1</span>,                                      <span class="comment">// descriptorCount</span>
        VK_SHADER_STAGE_FRAGMENT_BIT,           <span class="comment">// stageFlags</span>
        <span class="predefined-constant">NULL</span>                                    <span class="comment">// pImmutableSamplers</span>
    }
};

<span class="directive">const</span> VkDescriptorSetLayoutCreateInfo myDescriptorSetLayoutCreateInfo[] =
{
    <span class="comment">// Create info for first descriptor set with two descriptor bindings</span>
    {
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,    <span class="comment">// sType</span>
        <span class="predefined-constant">NULL</span>,                                                   <span class="comment">// pNext</span>
        <span class="integer">0</span>,                                                      <span class="comment">// flags</span>
        <span class="integer">2</span>,                                                      <span class="comment">// bindingCount</span>
        &amp;myDescriptorSetLayoutBinding[<span class="integer">0</span>]                        <span class="comment">// pBindings</span>
    },

    <span class="comment">// Create info for second descriptor set with one descriptor binding</span>
    {
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,    <span class="comment">// sType</span>
        <span class="predefined-constant">NULL</span>,                                                   <span class="comment">// pNext</span>
        <span class="integer">0</span>,                                                      <span class="comment">// flags</span>
        <span class="integer">1</span>,                                                      <span class="comment">// bindingCount</span>
        &amp;myDescriptorSetLayoutBinding[<span class="integer">2</span>]                        <span class="comment">// pBindings</span>
    }
};

VkDescriptorSetLayout myDescriptorSetLayout[<span class="integer">2</span>];

<span class="comment">//</span>
<span class="comment">// Create first descriptor set layout</span>
<span class="comment">//</span>
myResult = vkCreateDescriptorSetLayout(
    myDevice,
    &amp;myDescriptorSetLayoutCreateInfo[<span class="integer">0</span>],
    <span class="predefined-constant">NULL</span>,
    &amp;myDescriptorSetLayout[<span class="integer">0</span>]);

<span class="comment">//</span>
<span class="comment">// Create second descriptor set layout</span>
<span class="comment">//</span>
myResult = vkCreateDescriptorSetLayout(
    myDevice,
    &amp;myDescriptorSetLayoutCreateInfo[<span class="integer">1</span>],
    <span class="predefined-constant">NULL</span>,
    &amp;myDescriptorSetLayout[<span class="integer">1</span>]);</code></pre>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To destroy a descriptor set layout, call:</p>
</div>
<div id="vkDestroyDescriptorSetLayout" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> vkDestroyDescriptorSetLayout(
    VkDevice                                    device,
    VkDescriptorSetLayout                       descriptorSetLayout,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that destroys the descriptor set
layout.</p>
</li>
<li>
<p><code>descriptorSetLayout</code> is the descriptor set layout to destroy.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap10.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00284" href="#VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00284"></a>
If <code>VkAllocationCallbacks</code> were provided when
<code>descriptorSetLayout</code> was created, a compatible set of callbacks
<strong class="purple">must</strong> be provided here</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00285" href="#VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00285"></a>
If no <code>VkAllocationCallbacks</code> were provided when
<code>descriptorSetLayout</code> was created, <code>pAllocator</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyDescriptorSetLayout-device-parameter" href="#VUID-vkDestroyDescriptorSetLayout-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parameter" href="#VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parameter"></a> If <code>descriptorSetLayout</code> is not <a href="chap44.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>descriptorSetLayout</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorSetLayout-pAllocator-parameter" href="#VUID-vkDestroyDescriptorSetLayout-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap10.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parent" href="#VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parent"></a> If <code>descriptorSetLayout</code> is a valid handle, it <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>descriptorSetLayout</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-pipelinelayout"><a class="anchor" href="#descriptorsets-pipelinelayout"></a>13.2.2. Pipeline Layouts</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Access to descriptor sets from a pipeline is accomplished through a
<em>pipeline layout</em>.
Zero or more descriptor set layouts and zero or more push constant ranges
are combined to form a pipeline layout object describing the complete set of
resources that <strong class="purple">can</strong> be accessed by a pipeline.
The pipeline layout represents a sequence of descriptor sets with each
having a specific layout.
This sequence of layouts is used to determine the interface between shader
stages and shader resources.
Each pipeline is created using a pipeline layout.</p>
</div>
<div class="paragraph">
<p>Pipeline layout objects are represented by <code>VkPipelineLayout</code> handles:</p>
</div>
<div id="VkPipelineLayout" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create a pipeline layout, call:</p>
</div>
<div id="vkCreatePipelineLayout" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreatePipelineLayout(
    VkDevice                                    device,
    <span class="directive">const</span> VkPipelineLayoutCreateInfo*           pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkPipelineLayout*                           pPipelineLayout);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that creates the pipeline layout.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to a <a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a>
structure specifying the state of the pipeline layout object.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap10.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
<li>
<p><code>pPipelineLayout</code> is a pointer to a <a href="#VkPipelineLayout">VkPipelineLayout</a> handle in
which the resulting pipeline layout object is returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreatePipelineLayout-device-parameter" href="#VUID-vkCreatePipelineLayout-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCreatePipelineLayout-pCreateInfo-parameter" href="#VUID-vkCreatePipelineLayout-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreatePipelineLayout-pAllocator-parameter" href="#VUID-vkCreatePipelineLayout-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap10.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreatePipelineLayout-pPipelineLayout-parameter" href="#VUID-vkCreatePipelineLayout-pPipelineLayout-parameter"></a> <code>pPipelineLayout</code> <strong class="purple">must</strong> be a valid pointer to a <a href="#VkPipelineLayout">VkPipelineLayout</a> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a> structure is defined as:</p>
</div>
<div id="VkPipelineLayoutCreateInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkPipelineLayoutCreateInfo {
    VkStructureType                 sType;
    <span class="directive">const</span> <span class="directive">void</span>*                     pNext;
    VkPipelineLayoutCreateFlags     flags;
    uint32_t                        setLayoutCount;
    <span class="directive">const</span> VkDescriptorSetLayout*    pSetLayouts;
    uint32_t                        pushConstantRangeCount;
    <span class="directive">const</span> VkPushConstantRange*      pPushConstantRanges;
} VkPipelineLayoutCreateInfo;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
<li>
<p><code>setLayoutCount</code> is the number of descriptor sets included in the
pipeline layout.</p>
</li>
<li>
<p><code>pSetLayouts</code> is a pointer to an array of
<code>VkDescriptorSetLayout</code> objects.</p>
</li>
<li>
<p><code>pushConstantRangeCount</code> is the number of push constant ranges
included in the pipeline layout.</p>
</li>
<li>
<p><code>pPushConstantRanges</code> is a pointer to an array of
<code>VkPushConstantRange</code> structures defining a set of push constant
ranges for use in a single pipeline layout.
In addition to descriptor set layouts, a pipeline layout also describes
how many push constants <strong class="purple">can</strong> be accessed by each stage of the pipeline.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Push constants represent a high speed path to modify constant data in
pipelines that is expected to outperform memory-backed resource updates.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-setLayoutCount-00286" href="#VUID-VkPipelineLayoutCreateInfo-setLayoutCount-00286"></a>
<code>setLayoutCount</code> <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxBoundDescriptorSets</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00287" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00287"></a>
The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_SAMPLER</code> and
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> accessible to any shader
stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than or
equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorSamplers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00288" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00288"></a>
The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> and
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> accessible to any shader
stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than or
equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorUniformBuffers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00289" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00289"></a>
The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> and
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> accessible to any shader
stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than or
equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorStorageBuffers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00290" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00290"></a>
The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, and
<code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> accessible to any shader
stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than or
equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorSampledImages</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00291" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00291"></a>
The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, and
<code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> accessible to any shader
stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than or
equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorStorageImages</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01676" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01676"></a>
The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> accessible to any given shader
stage across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than or
equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorInputAttachments</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01677" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01677"></a>
The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_SAMPLER</code> and
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetSamplers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01678" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01678"></a>
The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> accessible across all shader
stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than
or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetUniformBuffers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01679" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01679"></a>
The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetUniformBuffersDynamic</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01680" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01680"></a>
The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> accessible across all shader
stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than
or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetStorageBuffers</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01681" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01681"></a>
The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetStorageBuffersDynamic</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01682" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01682"></a>
The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, and
<code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetSampledImages</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01683" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01683"></a>
The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, and
<code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> accessible across all
shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less
than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetStorageImages</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01684" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01684"></a>
The total number of descriptors of the type
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> accessible across all shader
stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be less than
or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxDescriptorSetInputAttachments</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-00292" href="#VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-00292"></a>
Any two elements of <code>pPushConstantRanges</code> <strong class="purple">must</strong> not include the same
stage in <code>stageFlags</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00293" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00293"></a>
<code>pSetLayouts</code> <strong class="purple">must</strong> not contain more than one descriptor set layout
that was created with
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code> set</p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-descriptorType-02381" href="#VUID-VkPipelineLayoutCreateInfo-descriptorType-02381"></a>
The total number of bindings with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code> accessible across
all shader stages and across all elements of <code>pSetLayouts</code> <strong class="purple">must</strong> be
less than or equal to
<code>VkPhysicalDeviceRayTracingPropertiesKHR</code>::<code>maxDescriptorSetAccelerationStructures</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-sType-sType" href="#VUID-VkPipelineLayoutCreateInfo-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pNext-pNext" href="#VUID-VkPipelineLayoutCreateInfo-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-flags-zerobitmask" href="#VUID-VkPipelineLayoutCreateInfo-flags-zerobitmask"></a> <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-parameter" href="#VUID-VkPipelineLayoutCreateInfo-pSetLayouts-parameter"></a> If <code>setLayoutCount</code> is not <code>0</code>, <code>pSetLayouts</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>setLayoutCount</code> valid <a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a> handles</p>
</li>
<li>
<p><a id="VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter" href="#VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter"></a> If <code>pushConstantRangeCount</code> is not <code>0</code>, <code>pPushConstantRanges</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pushConstantRangeCount</code> valid <a href="#VkPushConstantRange">VkPushConstantRange</a> structures</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkPipelineLayoutCreateFlags" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkFlags VkPipelineLayoutCreateFlags;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkPipelineLayoutCreateFlags</code> is a bitmask type for setting a mask, but
is currently reserved for future use.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkPushConstantRange</code> structure is defined as:</p>
</div>
<div id="VkPushConstantRange" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkPushConstantRange {
    VkShaderStageFlags    stageFlags;
    uint32_t              offset;
    uint32_t              size;
} VkPushConstantRange;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>stageFlags</code> is a set of stage flags describing the shader stages
that will access a range of push constants.
If a particular stage is not included in the range, then accessing
members of that range of push constants from the corresponding shader
stage will return undefined values.</p>
</li>
<li>
<p><code>offset</code> and <code>size</code> are the start offset and size, respectively,
consumed by the range.
Both <code>offset</code> and <code>size</code> are in units of bytes and <strong class="purple">must</strong> be a
multiple of 4.
The layout of the push constant variables is specified in the shader.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPushConstantRange-offset-00294" href="#VUID-VkPushConstantRange-offset-00294"></a>
<code>offset</code> <strong class="purple">must</strong> be less than
<code>VkPhysicalDeviceLimits</code>::<code>maxPushConstantsSize</code></p>
</li>
<li>
<p><a id="VUID-VkPushConstantRange-offset-00295" href="#VUID-VkPushConstantRange-offset-00295"></a>
<code>offset</code> <strong class="purple">must</strong> be a multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-VkPushConstantRange-size-00296" href="#VUID-VkPushConstantRange-size-00296"></a>
<code>size</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkPushConstantRange-size-00297" href="#VUID-VkPushConstantRange-size-00297"></a>
<code>size</code> <strong class="purple">must</strong> be a multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-VkPushConstantRange-size-00298" href="#VUID-VkPushConstantRange-size-00298"></a>
<code>size</code> <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPushConstantsSize</code> minus
<code>offset</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkPushConstantRange-stageFlags-parameter" href="#VUID-VkPushConstantRange-stageFlags-parameter"></a> <code>stageFlags</code> <strong class="purple">must</strong> be a valid combination of <a href="chap9.html#VkShaderStageFlagBits">VkShaderStageFlagBits</a> values</p>
</li>
<li>
<p><a id="VUID-VkPushConstantRange-stageFlags-requiredbitmask" href="#VUID-VkPushConstantRange-stageFlags-requiredbitmask"></a> <code>stageFlags</code> <strong class="purple">must</strong> not be <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Once created, pipeline layouts are used as part of pipeline creation (see
<a href="chap9.html#pipelines">Pipelines</a>), as part of binding descriptor sets (see
<a href="#descriptorsets-binding">Descriptor Set Binding</a>), and as part of setting
push constants (see <a href="#descriptorsets-push-constants">Push Constant
Updates</a>).
Pipeline creation accepts a pipeline layout as input, and the layout <strong class="purple">may</strong> be
used to map (set, binding, arrayElement) tuples to implementation resources
or memory locations within a descriptor set.
The assignment of implementation resources depends only on the bindings
defined in the descriptor sets that comprise the pipeline layout, and not on
any shader source.</p>
</div>
<div id="descriptorsets-pipelinelayout-consistency" class="paragraph">
<p>All resource variables <a href="chap8.html#shaders-staticuse">statically used</a> in all shaders
in a pipeline <strong class="purple">must</strong> be declared with a (set,binding,arrayElement) that
exists in the corresponding descriptor set layout and is of an appropriate
descriptor type and includes the set of shader stages it is used by in
<code>stageFlags</code>.
The pipeline layout <strong class="purple">can</strong> include entries that are not used by a particular
pipeline, or that are dead-code eliminated from any of the shaders.
The pipeline layout allows the application to provide a consistent set of
bindings across multiple pipeline compiles, which enables those pipelines to
be compiled in a way that the implementation <strong class="purple">may</strong> cheaply switch pipelines
without reprogramming the bindings.</p>
</div>
<div class="paragraph">
<p>Similarly, the push constant block declared in each shader (if present)
<strong class="purple">must</strong> only place variables at offsets that are each included in a push
constant range with <code>stageFlags</code> including the bit corresponding to the
shader stage that uses it.
The pipeline layout <strong class="purple">can</strong> include ranges or portions of ranges that are not
used by a particular pipeline, or for which the variables have been
dead-code eliminated from any of the shaders.</p>
</div>
<div class="paragraph">
<p>There is a limit on the total number of resources of each type that <strong class="purple">can</strong> be
included in bindings in all descriptor set layouts in a pipeline layout as
shown in <a href="#descriptorsets-pipelinelayout-limits">Pipeline Layout Resource
Limits</a>.
The “Total Resources Available” column gives the limit on the number of
each type of resource that <strong class="purple">can</strong> be included in bindings in all descriptor
sets in the pipeline layout.
Some resource types count against multiple limits.
Additionally, there are limits on the total number of each type of resource
that <strong class="purple">can</strong> be used in any pipeline stage as described in
<a href="chap14.html#interfaces-resources-limits">Shader Resource Limits</a>.</p>
</div>
<table id="descriptorsets-pipelinelayout-limits" class="tableblock frame-all grid-all" style="width: 80%;">
<caption class="title">Table 14. Pipeline Layout Resource Limits</caption>
<colgroup>
<col style="width: 62.7118%;">
<col style="width: 37.2882%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Total Resources Available</th>
<th class="tableblock halign-left valign-top">Resource Types</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle" rowspan="2"><p class="tableblock"><code>maxDescriptorSetSamplers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sampler</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">combined image sampler</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" rowspan="3"><p class="tableblock"><code>maxDescriptorSetSampledImages</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sampled image</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">combined image sampler</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uniform texel buffer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" rowspan="2"><p class="tableblock"><code>maxDescriptorSetStorageImages</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">storage image</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">storage texel buffer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" rowspan="2"><p class="tableblock"><code>maxDescriptorSetUniformBuffers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uniform buffer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uniform buffer dynamic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxDescriptorSetUniformBuffersDynamic</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uniform buffer dynamic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" rowspan="2"><p class="tableblock"><code>maxDescriptorSetStorageBuffers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">storage buffer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">storage buffer dynamic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxDescriptorSetStorageBuffersDynamic</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">storage buffer dynamic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxDescriptorSetInputAttachments</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">input attachment</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxDescriptorSetAccelerationStructures</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">acceleration structure</p></td>
</tr>
</tbody>
</table>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To destroy a pipeline layout, call:</p>
</div>
<div id="vkDestroyPipelineLayout" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> vkDestroyPipelineLayout(
    VkDevice                                    device,
    VkPipelineLayout                            pipelineLayout,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that destroys the pipeline layout.</p>
</li>
<li>
<p><code>pipelineLayout</code> is the pipeline layout to destroy.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap10.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyPipelineLayout-pipelineLayout-00299" href="#VUID-vkDestroyPipelineLayout-pipelineLayout-00299"></a>
If <code>VkAllocationCallbacks</code> were provided when <code>pipelineLayout</code>
was created, a compatible set of callbacks <strong class="purple">must</strong> be provided here</p>
</li>
<li>
<p><a id="VUID-vkDestroyPipelineLayout-pipelineLayout-00300" href="#VUID-vkDestroyPipelineLayout-pipelineLayout-00300"></a>
If no <code>VkAllocationCallbacks</code> were provided when
<code>pipelineLayout</code> was created, <code>pAllocator</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-vkDestroyPipelineLayout-pipelineLayout-02004" href="#VUID-vkDestroyPipelineLayout-pipelineLayout-02004"></a>
<code>pipelineLayout</code> <strong class="purple">must</strong> not have been passed to any <code>vkCmd*</code>
command for any command buffers that are still in the
<a href="chap5.html#commandbuffers-lifecycle">recording state</a> when
<code>vkDestroyPipelineLayout</code> is called</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyPipelineLayout-device-parameter" href="#VUID-vkDestroyPipelineLayout-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyPipelineLayout-pipelineLayout-parameter" href="#VUID-vkDestroyPipelineLayout-pipelineLayout-parameter"></a> If <code>pipelineLayout</code> is not <a href="chap44.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>pipelineLayout</code> <strong class="purple">must</strong> be a valid <a href="#VkPipelineLayout">VkPipelineLayout</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyPipelineLayout-pAllocator-parameter" href="#VUID-vkDestroyPipelineLayout-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap10.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkDestroyPipelineLayout-pipelineLayout-parent" href="#VUID-vkDestroyPipelineLayout-pipelineLayout-parent"></a> If <code>pipelineLayout</code> is a valid handle, it <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>pipelineLayout</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="descriptorsets-compatibility"><a class="anchor" href="#descriptorsets-compatibility"></a>Pipeline Layout Compatibility</h5>
<div class="paragraph">
<p>Two pipeline layouts are defined to be “compatible for
<a href="#descriptorsets-push-constants">push constants</a>” if they were created
with identical push constant ranges.
Two pipeline layouts are defined to be “compatible for set N” if they were
created with <em>identically defined</em> descriptor set layouts for sets zero
through N, and if they were created with identical push constant ranges.</p>
</div>
<div class="paragraph">
<p>When binding a descriptor set (see <a href="#descriptorsets-binding">Descriptor Set
Binding</a>) to set number N, if the previously bound descriptor sets for sets
zero through N-1 were all bound using compatible pipeline layouts, then
performing this binding does not disturb any of the lower numbered sets.
If, additionally, the previous bound descriptor set for set N was bound
using a pipeline layout compatible for set N, then the bindings in sets
numbered greater than N are also not disturbed.</p>
</div>
<div class="paragraph">
<p>Similarly, when binding a pipeline, the pipeline <strong class="purple">can</strong> correctly access any
previously bound descriptor sets which were bound with compatible pipeline
layouts, as long as all lower numbered sets were also bound with compatible
layouts.</p>
</div>
<div class="paragraph">
<p>Layout compatibility means that descriptor sets <strong class="purple">can</strong> be bound to a command
buffer for use by any pipeline created with a compatible pipeline layout,
and without having bound a particular pipeline first.
It also means that descriptor sets <strong class="purple">can</strong> remain valid across a pipeline
change, and the same resources will be accessible to the newly bound
pipeline.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Implementor’s Note</div>
<div class="paragraph">
<p>A consequence of layout compatibility is that when the implementation
compiles a pipeline layout and maps pipeline resources to implementation
resources, the mechanism for set N <strong class="purple">should</strong> only be a function of sets
[0..N].</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Place the least frequently changing descriptor sets near the start of the
pipeline layout, and place the descriptor sets representing the most
frequently changing resources near the end.
When pipelines are switched, only the descriptor set bindings that have been
invalidated will need to be updated and the remainder of the descriptor set
bindings will remain in place.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The maximum number of descriptor sets that <strong class="purple">can</strong> be bound to a pipeline
layout is queried from physical device properties (see
<code>maxBoundDescriptorSets</code> in <a href="chap35.html#limits">Limits</a>).</p>
</div>
<div class="listingblock">
<div class="title">API example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">const</span> VkDescriptorSetLayout layouts[] = { layout1, layout2 };

<span class="directive">const</span> VkPushConstantRange ranges[] =
{
    {
        VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,    <span class="comment">// stageFlags</span>
        <span class="integer">0</span>,                                      <span class="comment">// offset</span>
        <span class="integer">4</span>                                       <span class="comment">// size</span>
    },

    {
        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,  <span class="comment">// stageFlags</span>
        <span class="integer">4</span>,                                      <span class="comment">// offset</span>
        <span class="integer">4</span>                                       <span class="comment">// size</span>
    },
};

<span class="directive">const</span> VkPipelineLayoutCreateInfo createInfo =
{
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,  <span class="comment">// sType</span>
    <span class="predefined-constant">NULL</span>,                                           <span class="comment">// pNext</span>
    <span class="integer">0</span>,                                              <span class="comment">// flags</span>
    <span class="integer">2</span>,                                              <span class="comment">// setLayoutCount</span>
    layouts,                                        <span class="comment">// pSetLayouts</span>
    <span class="integer">2</span>,                                              <span class="comment">// pushConstantRangeCount</span>
    ranges                                          <span class="comment">// pPushConstantRanges</span>
};

VkPipelineLayout myPipelineLayout;
myResult = vkCreatePipelineLayout(
    myDevice,
    &amp;createInfo,
    <span class="predefined-constant">NULL</span>,
    &amp;myPipelineLayout);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-allocation"><a class="anchor" href="#descriptorsets-allocation"></a>13.2.3. Allocation of Descriptor Sets</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>A <em>descriptor pool</em> maintains a pool of descriptors, from which descriptor
sets are allocated.
Descriptor pools are externally synchronized, meaning that the application
<strong class="purple">must</strong> not allocate and/or free descriptor sets from the same pool in
multiple threads simultaneously.</p>
</div>
<div class="paragraph">
<p>Descriptor pools are represented by <code>VkDescriptorPool</code> handles:</p>
</div>
<div id="VkDescriptorPool" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To create a descriptor pool object, call:</p>
</div>
<div id="vkCreateDescriptorPool" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateDescriptorPool(
    VkDevice                                    device,
    <span class="directive">const</span> VkDescriptorPoolCreateInfo*           pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkDescriptorPool*                           pDescriptorPool);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that creates the descriptor pool.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to a <a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a>
structure specifying the state of the descriptor pool object.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap10.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
<li>
<p><code>pDescriptorPool</code> is a pointer to a <a href="#VkDescriptorPool">VkDescriptorPool</a> handle in
which the resulting descriptor pool object is returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap10.html#memory-allocation">Memory Allocation</a> chapter.</p>
</div>
<div class="paragraph">
<p>The created descriptor pool is returned in <code>pDescriptorPool</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateDescriptorPool-device-parameter" href="#VUID-vkCreateDescriptorPool-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorPool-pCreateInfo-parameter" href="#VUID-vkCreateDescriptorPool-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorPool-pAllocator-parameter" href="#VUID-vkCreateDescriptorPool-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap10.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorPool-pDescriptorPool-parameter" href="#VUID-vkCreateDescriptorPool-pDescriptorPool-parameter"></a> <code>pDescriptorPool</code> <strong class="purple">must</strong> be a valid pointer to a <a href="#VkDescriptorPool">VkDescriptorPool</a> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Additional information about the pool is passed in a
<code>VkDescriptorPoolCreateInfo</code> structure:</p>
</div>
<div id="VkDescriptorPoolCreateInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorPoolCreateInfo {
    VkStructureType                sType;
    <span class="directive">const</span> <span class="directive">void</span>*                    pNext;
    VkDescriptorPoolCreateFlags    flags;
    uint32_t                       maxSets;
    uint32_t                       poolSizeCount;
    <span class="directive">const</span> VkDescriptorPoolSize*    pPoolSizes;
} VkDescriptorPoolCreateInfo;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is a bitmask of <a href="#VkDescriptorPoolCreateFlagBits">VkDescriptorPoolCreateFlagBits</a>
specifying certain supported operations on the pool.</p>
</li>
<li>
<p><code>maxSets</code> is the maximum number of descriptor sets that <strong class="purple">can</strong> be
allocated from the pool.</p>
</li>
<li>
<p><code>poolSizeCount</code> is the number of elements in <code>pPoolSizes</code>.</p>
</li>
<li>
<p><code>pPoolSizes</code> is a pointer to an array of <a href="#VkDescriptorPoolSize">VkDescriptorPoolSize</a>
structures, each containing a descriptor type and number of descriptors
of that type to be allocated in the pool.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If multiple <code>VkDescriptorPoolSize</code> structures appear in the
<code>pPoolSizes</code> array then the pool will be created with enough storage for
the total number of descriptors of each type.</p>
</div>
<div class="paragraph">
<p>Fragmentation of a descriptor pool is possible and <strong class="purple">may</strong> lead to descriptor
set allocation failures.
A failure due to fragmentation is defined as failing a descriptor set
allocation despite the sum of all outstanding descriptor set allocations
from the pool plus the requested allocation requiring no more than the total
number of descriptors requested at pool creation.
Implementations provide certain guarantees of when fragmentation <strong class="purple">must</strong> not
cause allocation failure, as described below.</p>
</div>
<div class="paragraph">
<p>If a descriptor pool has not had any descriptor sets freed since it was
created or most recently reset then fragmentation <strong class="purple">must</strong> not cause an
allocation failure (note that this is always the case for a pool created
without the <code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code> bit
set).
Additionally, if all sets allocated from the pool since it was created or
most recently reset use the same number of descriptors (of each type) and
the requested allocation also uses that same number of descriptors (of each
type), then fragmentation <strong class="purple">must</strong> not cause an allocation failure.</p>
</div>
<div class="paragraph">
<p>If an allocation failure occurs due to fragmentation, an application <strong class="purple">can</strong>
create an additional descriptor pool to perform further descriptor set
allocations.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-maxSets-00301" href="#VUID-VkDescriptorPoolCreateInfo-maxSets-00301"></a>
<code>maxSets</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-sType-sType" href="#VUID-VkDescriptorPoolCreateInfo-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-pNext-pNext" href="#VUID-VkDescriptorPoolCreateInfo-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-flags-parameter" href="#VUID-VkDescriptorPoolCreateInfo-flags-parameter"></a> <code>flags</code> <strong class="purple">must</strong> be a valid combination of <a href="#VkDescriptorPoolCreateFlagBits">VkDescriptorPoolCreateFlagBits</a> values</p>
</li>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-pPoolSizes-parameter" href="#VUID-VkDescriptorPoolCreateInfo-pPoolSizes-parameter"></a> <code>pPoolSizes</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>poolSizeCount</code> valid <a href="#VkDescriptorPoolSize">VkDescriptorPoolSize</a> structures</p>
</li>
<li>
<p><a id="VUID-VkDescriptorPoolCreateInfo-poolSizeCount-arraylength" href="#VUID-VkDescriptorPoolCreateInfo-poolSizeCount-arraylength"></a> <code>poolSizeCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Bits which <strong class="purple">can</strong> be set in <a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a>::<code>flags</code> to
enable operations on a descriptor pool are:</p>
</div>
<div id="VkDescriptorPoolCreateFlagBits" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">enum</span> VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = <span class="hex">0x00000001</span>,
    VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = <span class="hex">0x7FFFFFFF</span>
} VkDescriptorPoolCreateFlagBits;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code> specifies that
descriptor sets <strong class="purple">can</strong> return their individual allocations to the pool,
i.e. all of <a href="#vkAllocateDescriptorSets">vkAllocateDescriptorSets</a>, <a href="#vkFreeDescriptorSets">vkFreeDescriptorSets</a>,
and <a href="#vkResetDescriptorPool">vkResetDescriptorPool</a> are allowed.
Otherwise, descriptor sets allocated from the pool <strong class="purple">must</strong> not be
individually freed back to the pool, i.e. only
<a href="#vkAllocateDescriptorSets">vkAllocateDescriptorSets</a> and <a href="#vkResetDescriptorPool">vkResetDescriptorPool</a> are
allowed.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkDescriptorPoolCreateFlags" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkFlags VkDescriptorPoolCreateFlags;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkDescriptorPoolCreateFlags</code> is a bitmask type for setting a mask of
zero or more <a href="#VkDescriptorPoolCreateFlagBits">VkDescriptorPoolCreateFlagBits</a>.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDescriptorPoolSize</code> structure is defined as:</p>
</div>
<div id="VkDescriptorPoolSize" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorPoolSize {
    VkDescriptorType    type;
    uint32_t            descriptorCount;
} VkDescriptorPoolSize;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>type</code> is the type of descriptor.</p>
</li>
<li>
<p><code>descriptorCount</code> is the number of descriptors of that type to
allocate.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>When creating a descriptor pool that will contain descriptors for combined
image samplers of multi-planar formats, an application needs to account for
non-trivial descriptor consumption when choosing the <code>descriptorCount</code>
value, as indicated by
<a href="chap37.html#VkSamplerYcbcrConversionImageFormatProperties">VkSamplerYcbcrConversionImageFormatProperties</a>::<code>combinedImageSamplerDescriptorCount</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorPoolSize-descriptorCount-00302" href="#VUID-VkDescriptorPoolSize-descriptorCount-00302"></a>
<code>descriptorCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorPoolSize-type-parameter" href="#VUID-VkDescriptorPoolSize-type-parameter"></a> <code>type</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorType">VkDescriptorType</a> value</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To destroy a descriptor pool, call:</p>
</div>
<div id="vkDestroyDescriptorPool" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> vkDestroyDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that destroys the descriptor pool.</p>
</li>
<li>
<p><code>descriptorPool</code> is the descriptor pool to destroy.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap10.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a pool is destroyed, all descriptor sets allocated from the pool are
implicitly freed and become invalid.
Descriptor sets allocated from a given pool do not need to be freed before
destroying that descriptor pool.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyDescriptorPool-descriptorPool-00303" href="#VUID-vkDestroyDescriptorPool-descriptorPool-00303"></a>
All submitted commands that refer to <code>descriptorPool</code> (via any
allocated descriptor sets) <strong class="purple">must</strong> have completed execution</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorPool-descriptorPool-00304" href="#VUID-vkDestroyDescriptorPool-descriptorPool-00304"></a>
If <code>VkAllocationCallbacks</code> were provided when <code>descriptorPool</code>
was created, a compatible set of callbacks <strong class="purple">must</strong> be provided here</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorPool-descriptorPool-00305" href="#VUID-vkDestroyDescriptorPool-descriptorPool-00305"></a>
If no <code>VkAllocationCallbacks</code> were provided when
<code>descriptorPool</code> was created, <code>pAllocator</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyDescriptorPool-device-parameter" href="#VUID-vkDestroyDescriptorPool-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorPool-descriptorPool-parameter" href="#VUID-vkDestroyDescriptorPool-descriptorPool-parameter"></a> If <code>descriptorPool</code> is not <a href="chap44.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>descriptorPool</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorPool">VkDescriptorPool</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorPool-pAllocator-parameter" href="#VUID-vkDestroyDescriptorPool-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap10.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorPool-descriptorPool-parent" href="#VUID-vkDestroyDescriptorPool-descriptorPool-parent"></a> If <code>descriptorPool</code> is a valid handle, it <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>descriptorPool</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Descriptor sets are allocated from descriptor pool objects, and are
represented by <code>VkDescriptorSet</code> handles:</p>
</div>
<div id="VkDescriptorSet" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSet)</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To allocate descriptor sets from a descriptor pool, call:</p>
</div>
<div id="vkAllocateDescriptorSets" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkAllocateDescriptorSets(
    VkDevice                                    device,
    <span class="directive">const</span> VkDescriptorSetAllocateInfo*          pAllocateInfo,
    VkDescriptorSet*                            pDescriptorSets);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that owns the descriptor pool.</p>
</li>
<li>
<p><code>pAllocateInfo</code> is a pointer to a <a href="#VkDescriptorSetAllocateInfo">VkDescriptorSetAllocateInfo</a>
structure describing parameters of the allocation.</p>
</li>
<li>
<p><code>pDescriptorSets</code> is a pointer to an array of <a href="#VkDescriptorSet">VkDescriptorSet</a>
handles in which the resulting descriptor set objects are returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The allocated descriptor sets are returned in <code>pDescriptorSets</code>.</p>
</div>
<div class="paragraph">
<p>When a descriptor set is allocated, the initial state is largely
uninitialized and all descriptors are undefined.
Descriptors also become undefined if the underlying resource is destroyed.
Descriptor sets containing undefined descriptors <strong class="purple">can</strong> still be bound and
used, subject to the following conditions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Descriptors that are <a href="chap8.html#shaders-staticuse">statically used</a> <strong class="purple">must</strong> have
been populated before the descriptor set is
<a href="#descriptorsets-binding">consumed</a>.</p>
</li>
<li>
<p>Entries that are not used by a pipeline <strong class="purple">can</strong> have undefined
descriptors.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a call to <code>vkAllocateDescriptorSets</code> would cause the total number of
descriptor sets allocated from the pool to exceed the value of
<a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a>::<code>maxSets</code> used to create
<code>pAllocateInfo-&gt;descriptorPool</code>, then the allocation <strong class="purple">may</strong> fail due to
lack of space in the descriptor pool.
Similarly, the allocation <strong class="purple">may</strong> fail due to lack of space if the call to
<code>vkAllocateDescriptorSets</code> would cause the number of any given
descriptor type to exceed the sum of all the <code>descriptorCount</code> members
of each element of <a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a>::<code>pPoolSizes</code> with a
<code>member</code> equal to that type.</p>
</div>
<div class="paragraph">
<p>If the allocation fails due to no more space in the descriptor pool, and not
because of system or device memory exhaustion, then
<code>VK_ERROR_OUT_OF_POOL_MEMORY</code> <strong class="purple">must</strong> be returned.</p>
</div>
<div class="paragraph">
<p><code>vkAllocateDescriptorSets</code> <strong class="purple">can</strong> be used to create multiple descriptor
sets.
If the creation of any of those descriptor sets fails, then the
implementation <strong class="purple">must</strong> destroy all successfully created descriptor set objects
from this command, set all entries of the <code>pDescriptorSets</code> array to
<a href="chap44.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a> and return the error.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkAllocateDescriptorSets-device-parameter" href="#VUID-vkAllocateDescriptorSets-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkAllocateDescriptorSets-pAllocateInfo-parameter" href="#VUID-vkAllocateDescriptorSets-pAllocateInfo-parameter"></a> <code>pAllocateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkDescriptorSetAllocateInfo">VkDescriptorSetAllocateInfo</a> structure</p>
</li>
<li>
<p><a id="VUID-vkAllocateDescriptorSets-pDescriptorSets-parameter" href="#VUID-vkAllocateDescriptorSets-pDescriptorSets-parameter"></a> <code>pDescriptorSets</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>pAllocateInfo</code>::descriptorSetCount <a href="#VkDescriptorSet">VkDescriptorSet</a> handles</p>
</li>
<li>
<p><a id="VUID-vkAllocateDescriptorSets-pAllocateInfo::descriptorSetCount-arraylength" href="#VUID-vkAllocateDescriptorSets-pAllocateInfo::descriptorSetCount-arraylength"></a> The value referenced by <code>pAllocateInfo</code>::<code>descriptorSetCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>pAllocateInfo</code>::descriptorPool <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_FRAGMENTED_POOL</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_POOL_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDescriptorSetAllocateInfo</code> structure is defined as:</p>
</div>
<div id="VkDescriptorSetAllocateInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorSetAllocateInfo {
    VkStructureType                 sType;
    <span class="directive">const</span> <span class="directive">void</span>*                     pNext;
    VkDescriptorPool                descriptorPool;
    uint32_t                        descriptorSetCount;
    <span class="directive">const</span> VkDescriptorSetLayout*    pSetLayouts;
} VkDescriptorSetAllocateInfo;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>descriptorPool</code> is the pool which the sets will be allocated from.</p>
</li>
<li>
<p><code>descriptorSetCount</code> determines the number of descriptor sets to be
allocated from the pool.</p>
</li>
<li>
<p><code>pSetLayouts</code> is a pointer to an array of descriptor set layouts,
with each member specifying how the corresponding descriptor set is
allocated.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-pSetLayouts-00308" href="#VUID-VkDescriptorSetAllocateInfo-pSetLayouts-00308"></a>
Each element of <code>pSetLayouts</code> <strong class="purple">must</strong> not have been created with
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code> set</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-sType-sType" href="#VUID-VkDescriptorSetAllocateInfo-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-pNext-pNext" href="#VUID-VkDescriptorSetAllocateInfo-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-descriptorPool-parameter" href="#VUID-VkDescriptorSetAllocateInfo-descriptorPool-parameter"></a> <code>descriptorPool</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorPool">VkDescriptorPool</a> handle</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-pSetLayouts-parameter" href="#VUID-VkDescriptorSetAllocateInfo-pSetLayouts-parameter"></a> <code>pSetLayouts</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorSetCount</code> valid <a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a> handles</p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-arraylength" href="#VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-arraylength"></a> <code>descriptorSetCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorSetAllocateInfo-commonparent" href="#VUID-VkDescriptorSetAllocateInfo-commonparent"></a> Both of <code>descriptorPool</code>, and the elements of <code>pSetLayouts</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap4.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To free allocated descriptor sets, call:</p>
</div>
<div id="vkFreeDescriptorSets" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkFreeDescriptorSets(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    <span class="directive">const</span> VkDescriptorSet*                      pDescriptorSets);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that owns the descriptor pool.</p>
</li>
<li>
<p><code>descriptorPool</code> is the descriptor pool from which the descriptor
sets were allocated.</p>
</li>
<li>
<p><code>descriptorSetCount</code> is the number of elements in the
<code>pDescriptorSets</code> array.</p>
</li>
<li>
<p><code>pDescriptorSets</code> is a pointer to an array of handles to
<a href="#VkDescriptorSet">VkDescriptorSet</a> objects.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>After calling <code>vkFreeDescriptorSets</code>, all descriptor sets in
<code>pDescriptorSets</code> are invalid.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkFreeDescriptorSets-pDescriptorSets-00309" href="#VUID-vkFreeDescriptorSets-pDescriptorSets-00309"></a>
All submitted commands that refer to any element of
<code>pDescriptorSets</code> <strong class="purple">must</strong> have completed execution</p>
</li>
<li>
<p><a id="VUID-vkFreeDescriptorSets-pDescriptorSets-00310" href="#VUID-vkFreeDescriptorSets-pDescriptorSets-00310"></a>
<code>pDescriptorSets</code> <strong class="purple">must</strong> be a valid pointer to an array of
<code>descriptorSetCount</code> <code>VkDescriptorSet</code> handles, each element of
which <strong class="purple">must</strong> either be a valid handle or <a href="chap44.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a></p>
</li>
<li>
<p><a id="VUID-vkFreeDescriptorSets-pDescriptorSets-00311" href="#VUID-vkFreeDescriptorSets-pDescriptorSets-00311"></a>
Each valid handle in <code>pDescriptorSets</code> <strong class="purple">must</strong> have been allocated
from <code>descriptorPool</code></p>
</li>
<li>
<p><a id="VUID-vkFreeDescriptorSets-descriptorPool-00312" href="#VUID-vkFreeDescriptorSets-descriptorPool-00312"></a>
<code>descriptorPool</code> <strong class="purple">must</strong> have been created with the
<code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code> flag</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkFreeDescriptorSets-device-parameter" href="#VUID-vkFreeDescriptorSets-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkFreeDescriptorSets-descriptorPool-parameter" href="#VUID-vkFreeDescriptorSets-descriptorPool-parameter"></a> <code>descriptorPool</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorPool">VkDescriptorPool</a> handle</p>
</li>
<li>
<p><a id="VUID-vkFreeDescriptorSets-descriptorSetCount-arraylength" href="#VUID-vkFreeDescriptorSets-descriptorSetCount-arraylength"></a> <code>descriptorSetCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-vkFreeDescriptorSets-descriptorPool-parent" href="#VUID-vkFreeDescriptorSets-descriptorPool-parent"></a> <code>descriptorPool</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
<li>
<p><a id="VUID-vkFreeDescriptorSets-pDescriptorSets-parent" href="#VUID-vkFreeDescriptorSets-pDescriptorSets-parent"></a> Each element of <code>pDescriptorSets</code> that is a valid handle <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>descriptorPool</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>descriptorPool</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to each member of <code>pDescriptorSets</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To return all descriptor sets allocated from a given pool to the pool,
rather than freeing individual descriptor sets, call:</p>
</div>
<div id="vkResetDescriptorPool" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkResetDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that owns the descriptor pool.</p>
</li>
<li>
<p><code>descriptorPool</code> is the descriptor pool to be reset.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Resetting a descriptor pool recycles all of the resources from all of the
descriptor sets allocated from the descriptor pool back to the descriptor
pool, and the descriptor sets are implicitly freed.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkResetDescriptorPool-descriptorPool-00313" href="#VUID-vkResetDescriptorPool-descriptorPool-00313"></a>
All uses of <code>descriptorPool</code> (via any allocated descriptor sets)
<strong class="purple">must</strong> have completed execution</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkResetDescriptorPool-device-parameter" href="#VUID-vkResetDescriptorPool-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkResetDescriptorPool-descriptorPool-parameter" href="#VUID-vkResetDescriptorPool-descriptorPool-parameter"></a> <code>descriptorPool</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorPool">VkDescriptorPool</a> handle</p>
</li>
<li>
<p><a id="VUID-vkResetDescriptorPool-flags-zerobitmask" href="#VUID-vkResetDescriptorPool-flags-zerobitmask"></a> <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
<li>
<p><a id="VUID-vkResetDescriptorPool-descriptorPool-parent" href="#VUID-vkResetDescriptorPool-descriptorPool-parent"></a> <code>descriptorPool</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>descriptorPool</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to any <code>VkDescriptorSet</code> objects allocated from <code>descriptorPool</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkDescriptorPoolResetFlags" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkFlags VkDescriptorPoolResetFlags;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkDescriptorPoolResetFlags</code> is a bitmask type for setting a mask, but
is currently reserved for future use.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-updates"><a class="anchor" href="#descriptorsets-updates"></a>13.2.4. Descriptor Set Updates</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Once allocated, descriptor sets <strong class="purple">can</strong> be updated with a combination of write
and copy operations.
To update descriptor sets, call:</p>
</div>
<div id="vkUpdateDescriptorSets" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> vkUpdateDescriptorSets(
    VkDevice                                    device,
    uint32_t                                    descriptorWriteCount,
    <span class="directive">const</span> VkWriteDescriptorSet*                 pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    <span class="directive">const</span> VkCopyDescriptorSet*                  pDescriptorCopies);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that updates the descriptor sets.</p>
</li>
<li>
<p><code>descriptorWriteCount</code> is the number of elements in the
<code>pDescriptorWrites</code> array.</p>
</li>
<li>
<p><code>pDescriptorWrites</code> is a pointer to an array of
<a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> structures describing the descriptor sets to
write to.</p>
</li>
<li>
<p><code>descriptorCopyCount</code> is the number of elements in the
<code>pDescriptorCopies</code> array.</p>
</li>
<li>
<p><code>pDescriptorCopies</code> is a pointer to an array of
<a href="#VkCopyDescriptorSet">VkCopyDescriptorSet</a> structures describing the descriptor sets to
copy between.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The operations described by <code>pDescriptorWrites</code> are performed first,
followed by the operations described by <code>pDescriptorCopies</code>.
Within each array, the operations are performed in the order they appear in
the array.</p>
</div>
<div class="paragraph">
<p>Each element in the <code>pDescriptorWrites</code> array describes an operation
updating the descriptor set using descriptors for resources specified in the
structure.</p>
</div>
<div class="paragraph">
<p>Each element in the <code>pDescriptorCopies</code> array is a
<a href="#VkCopyDescriptorSet">VkCopyDescriptorSet</a> structure describing an operation copying
descriptors between sets.</p>
</div>
<div class="paragraph">
<p>If the <code>dstSet</code> member of any element of <code>pDescriptorWrites</code> or
<code>pDescriptorCopies</code> is bound, accessed, or modified by any command that
was recorded to a command buffer which is currently in the
<a href="chap5.html#commandbuffers-lifecycle">recording or executable state</a>,
that command buffer becomes <a href="chap5.html#commandbuffers-lifecycle">invalid</a>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkUpdateDescriptorSets-dstSet-00314" href="#VUID-vkUpdateDescriptorSets-dstSet-00314"></a>
The <code>dstSet</code> member of each element of <code>pDescriptorWrites</code> or
<code>pDescriptorCopies</code> <strong class="purple">must</strong> not be used by any command that was
recorded to a command buffer which is in the <a href="chap5.html#commandbuffers-lifecycle">pending state</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkUpdateDescriptorSets-device-parameter" href="#VUID-vkUpdateDescriptorSets-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkUpdateDescriptorSets-pDescriptorWrites-parameter" href="#VUID-vkUpdateDescriptorSets-pDescriptorWrites-parameter"></a> If <code>descriptorWriteCount</code> is not <code>0</code>, <code>pDescriptorWrites</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorWriteCount</code> valid <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> structures</p>
</li>
<li>
<p><a id="VUID-vkUpdateDescriptorSets-pDescriptorCopies-parameter" href="#VUID-vkUpdateDescriptorSets-pDescriptorCopies-parameter"></a> If <code>descriptorCopyCount</code> is not <code>0</code>, <code>pDescriptorCopies</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorCopyCount</code> valid <a href="#VkCopyDescriptorSet">VkCopyDescriptorSet</a> structures</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>pDescriptorWrites</code>[].dstSet <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to <code>pDescriptorCopies</code>[].dstSet <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkWriteDescriptorSet</code> structure is defined as:</p>
</div>
<div id="VkWriteDescriptorSet" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkWriteDescriptorSet {
    VkStructureType                  sType;
    <span class="directive">const</span> <span class="directive">void</span>*                      pNext;
    VkDescriptorSet                  dstSet;
    uint32_t                         dstBinding;
    uint32_t                         dstArrayElement;
    uint32_t                         descriptorCount;
    VkDescriptorType                 descriptorType;
    <span class="directive">const</span> VkDescriptorImageInfo*     pImageInfo;
    <span class="directive">const</span> VkDescriptorBufferInfo*    pBufferInfo;
    <span class="directive">const</span> VkBufferView*              pTexelBufferView;
} VkWriteDescriptorSet;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>dstSet</code> is the destination descriptor set to update.</p>
</li>
<li>
<p><code>dstBinding</code> is the descriptor binding within that set.</p>
</li>
<li>
<p><code>dstArrayElement</code> is the starting element in that array.</p>
</li>
<li>
<p><code>descriptorCount</code> is the number of descriptors to update (the number
of elements in <code>pImageInfo</code>, <code>pBufferInfo</code>, or
<code>pTexelBufferView</code>
, or a value matching the <code>accelerationStructureCount</code> of a
<a href="#VkWriteDescriptorSetAccelerationStructureKHR">VkWriteDescriptorSetAccelerationStructureKHR</a> structure in the
<code>pNext</code> chain
).</p>
</li>
<li>
<p><code>descriptorType</code> is a <a href="#VkDescriptorType">VkDescriptorType</a> specifying the type of
each descriptor in <code>pImageInfo</code>, <code>pBufferInfo</code>, or
<code>pTexelBufferView</code>, as described below.
It <strong class="purple">must</strong> be the same type as that specified in
<code>VkDescriptorSetLayoutBinding</code> for <code>dstSet</code> at <code>dstBinding</code>.
The type of the descriptor also controls which array the descriptors are
taken from.</p>
</li>
<li>
<p><code>pImageInfo</code> is a pointer to an array of <a href="#VkDescriptorImageInfo">VkDescriptorImageInfo</a>
structures or is ignored, as described below.</p>
</li>
<li>
<p><code>pBufferInfo</code> is a pointer to an array of
<a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a> structures or is ignored, as described
below.</p>
</li>
<li>
<p><code>pTexelBufferView</code> is a pointer to an array of <a href="chap11.html#VkBufferView">VkBufferView</a>
handles as described in the <a href="chap11.html#resources-buffer-views">Buffer Views</a>
section or is ignored, as described below.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Only one of <code>pImageInfo</code>, <code>pBufferInfo</code>, or <code>pTexelBufferView</code>
members is used according to the descriptor type specified in the
<code>descriptorType</code> member of the containing <code>VkWriteDescriptorSet</code>
structure,
or if <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code>, in which case the
source data for the descriptor writes is taken from the
<a href="#VkWriteDescriptorSetAccelerationStructureKHR">VkWriteDescriptorSetAccelerationStructureKHR</a> structure in the
<code>pNext</code> chain of <code>VkWriteDescriptorSet</code>,
as specified below.</p>
</div>
<div id="descriptorsets-updates-consecutive" class="paragraph">
<p>If the <code>dstBinding</code> has fewer than <code>descriptorCount</code> array elements
remaining starting from <code>dstArrayElement</code>, then the remainder will be
used to update the subsequent binding - <span class="eq"><code>dstBinding</code>+1</span> starting at
array element zero.
If a binding has a <code>descriptorCount</code> of zero, it is skipped.
This behavior applies recursively, with the update affecting consecutive
bindings as needed to update all <code>descriptorCount</code> descriptors.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWriteDescriptorSet-dstBinding-00315" href="#VUID-VkWriteDescriptorSet-dstBinding-00315"></a>
<code>dstBinding</code> <strong class="purple">must</strong> be less than or equal to the maximum value of
<code>binding</code> of all <a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a> structures
specified when <code>dstSet</code>’s descriptor set layout was created</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-dstBinding-00316" href="#VUID-VkWriteDescriptorSet-dstBinding-00316"></a>
<code>dstBinding</code> <strong class="purple">must</strong> be a binding with a non-zero
<code>descriptorCount</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorCount-00317" href="#VUID-VkWriteDescriptorSet-descriptorCount-00317"></a>
All consecutive bindings updated via a single <code>VkWriteDescriptorSet</code>
structure, except those with a <code>descriptorCount</code> of zero, <strong class="purple">must</strong> have
identical <code>descriptorType</code> and <code>stageFlags</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorCount-00318" href="#VUID-VkWriteDescriptorSet-descriptorCount-00318"></a>
All consecutive bindings updated via a single <code>VkWriteDescriptorSet</code>
structure, except those with a <code>descriptorCount</code> of zero, <strong class="purple">must</strong> all
either use immutable samplers or <strong class="purple">must</strong> all not use immutable samplers</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00319" href="#VUID-VkWriteDescriptorSet-descriptorType-00319"></a>
<code>descriptorType</code> <strong class="purple">must</strong> match the type of <code>dstBinding</code> within
<code>dstSet</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-dstSet-00320" href="#VUID-VkWriteDescriptorSet-dstSet-00320"></a>
<code>dstSet</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorSet">VkDescriptorSet</a> handle</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-dstArrayElement-00321" href="#VUID-VkWriteDescriptorSet-dstArrayElement-00321"></a>
The sum of <code>dstArrayElement</code> and <code>descriptorCount</code> <strong class="purple">must</strong> be less
than or equal to the number of array elements in the descriptor set
binding specified by <code>dstBinding</code>, and all applicable consecutive
bindings, as described by <a href="#descriptorsets-updates-consecutive">consecutive binding updates</a></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00322" href="#VUID-VkWriteDescriptorSet-descriptorType-00322"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>,
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, or
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>, <code>pImageInfo</code> <strong class="purple">must</strong> be a
valid pointer to an array of <code>descriptorCount</code> valid
<code>VkDescriptorImageInfo</code> structures</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00323" href="#VUID-VkWriteDescriptorSet-descriptorType-00323"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>
or <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>, <code>pTexelBufferView</code>
<strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorCount</code> valid
<code>VkBufferView</code> handles</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00324" href="#VUID-VkWriteDescriptorSet-descriptorType-00324"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>,
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, <code>pBufferInfo</code> <strong class="purple">must</strong>
be a valid pointer to an array of <code>descriptorCount</code> valid
<code>VkDescriptorBufferInfo</code> structures</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00325" href="#VUID-VkWriteDescriptorSet-descriptorType-00325"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> or
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and <code>dstSet</code> was
not allocated with a layout that included immutable samplers for
<code>dstBinding</code> with <code>descriptorType</code>, the <code>sampler</code> member of
each element of <code>pImageInfo</code> <strong class="purple">must</strong> be a valid <code>VkSampler</code> object</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00326" href="#VUID-VkWriteDescriptorSet-descriptorType-00326"></a>
If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, or
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>, the <code>imageView</code> and
<code>imageLayout</code> members of each element of <code>pImageInfo</code> <strong class="purple">must</strong> be a
valid <code>VkImageView</code> and <a href="chap11.html#VkImageLayout">VkImageLayout</a>, respectively</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-02382" href="#VUID-VkWriteDescriptorSet-descriptorType-02382"></a>
If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code>, the <code>pNext</code>
chain <strong class="purple">must</strong> include a <a href="#VkWriteDescriptorSetAccelerationStructureKHR">VkWriteDescriptorSetAccelerationStructureKHR</a>
structure whose <code>accelerationStructureCount</code> member equals
<code>descriptorCount</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-01946" href="#VUID-VkWriteDescriptorSet-descriptorType-01946"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, then
the <code>imageView</code> member of each <code>pImageInfo</code> element <strong class="purple">must</strong> have
been created without a <code>VkSamplerYcbcrConversionInfo</code> structure in
its <code>pNext</code> chain</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-02738" href="#VUID-VkWriteDescriptorSet-descriptorType-02738"></a>
If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and if any element of
<code>pImageInfo</code> has a <code>imageView</code> member that was created with a
<code>VkSamplerYcbcrConversionInfo</code> structure in its <code>pNext</code> chain,
then <code>dstSet</code> <strong class="purple">must</strong> have been allocated with a layout that included
immutable samplers for <code>dstBinding</code>, and the corresponding immutable
sampler <strong class="purple">must</strong> have been created with an <em>identically defined</em>
<code>VkSamplerYcbcrConversionInfo</code> object</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-01948" href="#VUID-VkWriteDescriptorSet-descriptorType-01948"></a>
If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and <code>dstSet</code> was
allocated with a layout that included immutable samplers for
<code>dstBinding</code>, then the <code>imageView</code> member of each element of
<code>pImageInfo</code> which corresponds to an immutable sampler that enables
<a href="chap12.html#samplers-YCbCr-conversion">sampler Y′C<sub>B</sub>C<sub>R</sub> conversion</a> <strong class="purple">must</strong> have been
created with a <code>VkSamplerYcbcrConversionInfo</code> structure in its
<code>pNext</code> chain with an <em>identically defined</em>
<code>VkSamplerYcbcrConversionInfo</code> to the corresponding immutable
sampler</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-01402" href="#VUID-VkWriteDescriptorSet-descriptorType-01402"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, for
each descriptor that will be accessed via load or store operations the
<code>imageLayout</code> member for corresponding elements of <code>pImageInfo</code>
<strong class="purple">must</strong> be <code>VK_IMAGE_LAYOUT_GENERAL</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00327" href="#VUID-VkWriteDescriptorSet-descriptorType-00327"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, the <code>offset</code> member
of each element of <code>pBufferInfo</code> <strong class="purple">must</strong> be a multiple of
<code>VkPhysicalDeviceLimits</code>::<code>minUniformBufferOffsetAlignment</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00328" href="#VUID-VkWriteDescriptorSet-descriptorType-00328"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, the <code>offset</code> member
of each element of <code>pBufferInfo</code> <strong class="purple">must</strong> be a multiple of
<code>VkPhysicalDeviceLimits</code>::<code>minStorageBufferOffsetAlignment</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00329" href="#VUID-VkWriteDescriptorSet-descriptorType-00329"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>,
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>, or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, and the <code>buffer</code>
member of any element of <code>pBufferInfo</code> is the handle of a non-sparse
buffer, then that buffer <strong class="purple">must</strong> be bound completely and contiguously to a
single <code>VkDeviceMemory</code> object</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00330" href="#VUID-VkWriteDescriptorSet-descriptorType-00330"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, the <code>buffer</code> member
of each element of <code>pBufferInfo</code> <strong class="purple">must</strong> have been created with
<code>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</code> set</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00331" href="#VUID-VkWriteDescriptorSet-descriptorType-00331"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, the <code>buffer</code> member
of each element of <code>pBufferInfo</code> <strong class="purple">must</strong> have been created with
<code>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</code> set</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00332" href="#VUID-VkWriteDescriptorSet-descriptorType-00332"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, the <code>range</code> member
of each element of <code>pBufferInfo</code>, or the effective range if
<code>range</code> is <code>VK_WHOLE_SIZE</code>, <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxUniformBufferRange</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00333" href="#VUID-VkWriteDescriptorSet-descriptorType-00333"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, the <code>range</code> member
of each element of <code>pBufferInfo</code>, or the effective range if
<code>range</code> is <code>VK_WHOLE_SIZE</code>, <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxStorageBufferRange</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00334" href="#VUID-VkWriteDescriptorSet-descriptorType-00334"></a>
If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>, the <code>VkBuffer</code> that
each element of <code>pTexelBufferView</code> was created from <strong class="purple">must</strong> have been
created with <code>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</code> set</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00335" href="#VUID-VkWriteDescriptorSet-descriptorType-00335"></a>
If <code>descriptorType</code> is
<code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>, the <code>VkBuffer</code> that
each element of <code>pTexelBufferView</code> was created from <strong class="purple">must</strong> have been
created with <code>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</code> set</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00336" href="#VUID-VkWriteDescriptorSet-descriptorType-00336"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code> or
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>, the <code>imageView</code> member of
each element of <code>pImageInfo</code> <strong class="purple">must</strong> have been created with the
identity swizzle</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00337" href="#VUID-VkWriteDescriptorSet-descriptorType-00337"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code> or
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, the <code>imageView</code>
member of each element of <code>pImageInfo</code> <strong class="purple">must</strong> have been created with
<code>VK_IMAGE_USAGE_SAMPLED_BIT</code> set</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-01403" href="#VUID-VkWriteDescriptorSet-descriptorType-01403"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code> or
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, the <code>imageLayout</code>
member of each element of <code>pImageInfo</code> <strong class="purple">must</strong> be a member of the list
given in <a href="#descriptorsets-sampledimage">Sampled Image</a> or
<a href="#descriptorsets-combinedimagesampler">Combined Image Sampler</a>,
corresponding to its type</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00338" href="#VUID-VkWriteDescriptorSet-descriptorType-00338"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>,
the <code>imageView</code> member of each element of <code>pImageInfo</code> <strong class="purple">must</strong>
have been created with <code>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</code> set</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-00339" href="#VUID-VkWriteDescriptorSet-descriptorType-00339"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, the
<code>imageView</code> member of each element of <code>pImageInfo</code> <strong class="purple">must</strong> have
been created with <code>VK_IMAGE_USAGE_STORAGE_BIT</code> set</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-02752" href="#VUID-VkWriteDescriptorSet-descriptorType-02752"></a>
If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>, then
<code>dstSet</code> <strong class="purple">must</strong> not have been allocated with a layout that included
immutable samplers for <code>dstBinding</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWriteDescriptorSet-sType-sType" href="#VUID-VkWriteDescriptorSet-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-pNext-pNext" href="#VUID-VkWriteDescriptorSet-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code> or a pointer to a valid instance of <a href="#VkWriteDescriptorSetAccelerationStructureKHR">VkWriteDescriptorSetAccelerationStructureKHR</a></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-sType-unique" href="#VUID-VkWriteDescriptorSet-sType-unique"></a> The <code>sType</code> value of each struct in the <code>pNext</code> chain <strong class="purple">must</strong> be unique</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorType-parameter" href="#VUID-VkWriteDescriptorSet-descriptorType-parameter"></a> <code>descriptorType</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorType">VkDescriptorType</a> value</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-descriptorCount-arraylength" href="#VUID-VkWriteDescriptorSet-descriptorCount-arraylength"></a> <code>descriptorCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSet-commonparent" href="#VUID-VkWriteDescriptorSet-commonparent"></a> Both of <code>dstSet</code>, and the elements of <code>pTexelBufferView</code> that are valid handles of non-ignored parameters <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap4.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The type of descriptors in a descriptor set is specified by
<a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>descriptorType</code>, which <strong class="purple">must</strong> be one of the
values:</p>
</div>
<div id="VkDescriptorType" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">enum</span> VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = <span class="integer">0</span>,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = <span class="integer">1</span>,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = <span class="integer">2</span>,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = <span class="integer">3</span>,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = <span class="integer">4</span>,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = <span class="integer">5</span>,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = <span class="integer">6</span>,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = <span class="integer">7</span>,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = <span class="integer">8</span>,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = <span class="integer">9</span>,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = <span class="integer">10</span>,
    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = <span class="integer">1000165000</span>,
    VK_DESCRIPTOR_TYPE_MAX_ENUM = <span class="hex">0x7FFFFFFF</span>
} VkDescriptorType;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_DESCRIPTOR_TYPE_SAMPLER</code> specifies a <a href="#descriptorsets-sampler">sampler descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> specifies a
<a href="#descriptorsets-combinedimagesampler">combined image sampler
descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code> specifies a
<a href="#descriptorsets-sampledimage">sampled image descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code> specifies a
<a href="#descriptorsets-storageimage">storage image descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> specifies a
<a href="#descriptorsets-uniformtexelbuffer">uniform texel buffer descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> specifies a
<a href="#descriptorsets-storagetexelbuffer">storage texel buffer descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> specifies a
<a href="#descriptorsets-uniformbuffer">uniform buffer descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> specifies a
<a href="#descriptorsets-storagebuffer">storage buffer descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> specifies a
<a href="#descriptorsets-uniformbufferdynamic">dynamic uniform buffer
descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> specifies a
<a href="#descriptorsets-storagebufferdynamic">dynamic storage buffer
descriptor</a>.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> specifies an
<a href="#descriptorsets-inputattachment">input attachment descriptor</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a descriptor set is updated via elements of <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>,
members of <code>pImageInfo</code>, <code>pBufferInfo</code> and <code>pTexelBufferView</code>
are only accessed by the implementation when they correspond to descriptor
type being defined - otherwise they are ignored.
The members accessed are as follows for each descriptor type:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>, only the <code>sampler</code> member of
each element of <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>pImageInfo</code> is
accessed.</p>
</li>
<li>
<p>For <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, or
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>, only the <code>imageView</code> and
<code>imageLayout</code> members of each element of
<a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>pImageInfo</code> are accessed.</p>
</li>
<li>
<p>For <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, all members of each
element of <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>pImageInfo</code> are accessed.</p>
</li>
<li>
<p>For <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>,
<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, or
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, all members of each
element of <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>pBufferInfo</code> are accessed.</p>
</li>
<li>
<p>For <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> or
<code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>, each element of
<a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>pTexelBufferView</code> is accessed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When updating descriptors with a <code>descriptorType</code> of
<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code>, none of the
<code>pImageInfo</code>, <code>pBufferInfo</code>, or <code>pTexelBufferView</code> members are
accessed, instead the source data of the descriptor update operation is
taken from the <a href="#VkWriteDescriptorSetAccelerationStructureKHR">VkWriteDescriptorSetAccelerationStructureKHR</a> structure
in the <code>pNext</code> chain of <code>VkWriteDescriptorSet</code>.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDescriptorBufferInfo</code> structure is defined as:</p>
</div>
<div id="VkDescriptorBufferInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorBufferInfo {
    VkBuffer        buffer;
    VkDeviceSize    offset;
    VkDeviceSize    range;
} VkDescriptorBufferInfo;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>buffer</code> is the buffer resource.</p>
</li>
<li>
<p><code>offset</code> is the offset in bytes from the start of <code>buffer</code>.
Access to buffer memory via this descriptor uses addressing that is
relative to this starting offset.</p>
</li>
<li>
<p><code>range</code> is the size in bytes that is used for this descriptor
update, or <code>VK_WHOLE_SIZE</code> to use the range from <code>offset</code> to the
end of the buffer.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>When setting <code>range</code> to <code>VK_WHOLE_SIZE</code>, the effective range <strong class="purple">must</strong>
not be larger than the maximum range for the descriptor type
(<a href="chap35.html#limits-maxUniformBufferRange"><code>maxUniformBufferRange</code></a> or
<a href="chap35.html#limits-maxStorageBufferRange"><code>maxStorageBufferRange</code></a>).
This means that <code>VK_WHOLE_SIZE</code> is not typically useful in the common
case where uniform buffer descriptors are suballocated from a buffer that is
much larger than <code>maxUniformBufferRange</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> and
<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> descriptor types,
<code>offset</code> is the base offset from which the dynamic offset is applied and
<code>range</code> is the static size used for all dynamic offsets.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorBufferInfo-offset-00340" href="#VUID-VkDescriptorBufferInfo-offset-00340"></a>
<code>offset</code> <strong class="purple">must</strong> be less than the size of <code>buffer</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorBufferInfo-range-00341" href="#VUID-VkDescriptorBufferInfo-range-00341"></a>
If <code>range</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>range</code> <strong class="purple">must</strong> be
greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorBufferInfo-range-00342" href="#VUID-VkDescriptorBufferInfo-range-00342"></a>
If <code>range</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>range</code> <strong class="purple">must</strong> be
less than or equal to the size of <code>buffer</code> minus <code>offset</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorBufferInfo-buffer-parameter" href="#VUID-VkDescriptorBufferInfo-buffer-parameter"></a> <code>buffer</code> <strong class="purple">must</strong> be a valid <a href="chap11.html#VkBuffer">VkBuffer</a> handle</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDescriptorImageInfo</code> structure is defined as:</p>
</div>
<div id="VkDescriptorImageInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorImageInfo {
    VkSampler        sampler;
    VkImageView      imageView;
    VkImageLayout    imageLayout;
} VkDescriptorImageInfo;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sampler</code> is a sampler handle, and is used in descriptor updates for
types <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> and
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> if the binding being
updated does not use immutable samplers.</p>
</li>
<li>
<p><code>imageView</code> is an image view handle, and is used in descriptor
updates for types <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>.</p>
</li>
<li>
<p><code>imageLayout</code> is the layout that the image subresources accessible
from <code>imageView</code> will be in at the time this descriptor is accessed.
<code>imageLayout</code> is used in descriptor updates for types
<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>,
<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and
<code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Members of <code>VkDescriptorImageInfo</code> that are not used in an update (as
described above) are ignored.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorImageInfo-imageView-00343" href="#VUID-VkDescriptorImageInfo-imageView-00343"></a>
<code>imageView</code> <strong class="purple">must</strong> not be 2D or 2D array image view created from a 3D
image</p>
</li>
<li>
<p><a id="VUID-VkDescriptorImageInfo-imageView-01976" href="#VUID-VkDescriptorImageInfo-imageView-01976"></a>
If <code>imageView</code> is created from a depth/stencil image, the
<code>aspectMask</code> used to create the <code>imageView</code> <strong class="purple">must</strong> include either
<code>VK_IMAGE_ASPECT_DEPTH_BIT</code> or <code>VK_IMAGE_ASPECT_STENCIL_BIT</code> but
not both</p>
</li>
<li>
<p><a id="VUID-VkDescriptorImageInfo-imageLayout-00344" href="#VUID-VkDescriptorImageInfo-imageLayout-00344"></a>
<code>imageLayout</code> <strong class="purple">must</strong> match the actual <a href="chap11.html#VkImageLayout">VkImageLayout</a> of each
subresource accessible from <code>imageView</code> at the time this descriptor
is accessed as defined by the <a href="chap11.html#resources-image-layouts-matching-rule">image layout matching rules</a></p>
</li>
<li>
<p><a id="VUID-VkDescriptorImageInfo-sampler-01564" href="#VUID-VkDescriptorImageInfo-sampler-01564"></a>
If <code>sampler</code> is used and the <a href="chap36.html#VkFormat">VkFormat</a> of the image is a
<a href="chap36.html#formats-requiring-sampler-ycbcr-conversion">multi-planar format</a>, the
image <strong class="purple">must</strong> have been created with
<code>VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT</code>, and the <code>aspectMask</code> of
the <code>imageView</code> <strong class="purple">must</strong> be <code>VK_IMAGE_ASPECT_PLANE_0_BIT</code>,
<code>VK_IMAGE_ASPECT_PLANE_1_BIT</code> or (for three-plane formats only)
<code>VK_IMAGE_ASPECT_PLANE_2_BIT</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorImageInfo-commonparent" href="#VUID-VkDescriptorImageInfo-commonparent"></a> Both of <code>imageView</code>, and <code>sampler</code> that are valid handles of non-ignored parameters <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap4.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkWriteDescriptorSetAccelerationStructureKHR</code> structure is defined
as:</p>
</div>
<div id="VkWriteDescriptorSetAccelerationStructureKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkWriteDescriptorSetAccelerationStructureKHR {
    VkStructureType                      sType;
    <span class="directive">const</span> <span class="directive">void</span>*                          pNext;
    uint32_t                             accelerationStructureCount;
    <span class="directive">const</span> VkAccelerationStructureKHR*    pAccelerationStructures;
} VkWriteDescriptorSetAccelerationStructureKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>accelerationStructureCount</code> is the number of elements in
<code>pAccelerationStructures</code>.</p>
</li>
<li>
<p><code>pAccelerationStructures</code> are the acceleration structures to update.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-02236" href="#VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-02236"></a>
<code>accelerationStructureCount</code> <strong class="purple">must</strong> be equal to <code>descriptorCount</code>
in the extended structure</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-02764" href="#VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-02764"></a>
Each acceleration structure in <code>pAccelerationStructures</code> <strong class="purple">must</strong> have
been created with <code>VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureKHR-sType-sType" href="#VUID-VkWriteDescriptorSetAccelerationStructureKHR-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR</code></p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-parameter" href="#VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-parameter"></a> <code>pAccelerationStructures</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>accelerationStructureCount</code> valid <a href="chap11.html#VkAccelerationStructureKHR">VkAccelerationStructureKHR</a> handles</p>
</li>
<li>
<p><a id="VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-arraylength" href="#VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-arraylength"></a> <code>accelerationStructureCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkCopyDescriptorSet</code> structure is defined as:</p>
</div>
<div id="VkCopyDescriptorSet" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkCopyDescriptorSet {
    VkStructureType    sType;
    <span class="directive">const</span> <span class="directive">void</span>*        pNext;
    VkDescriptorSet    srcSet;
    uint32_t           srcBinding;
    uint32_t           srcArrayElement;
    VkDescriptorSet    dstSet;
    uint32_t           dstBinding;
    uint32_t           dstArrayElement;
    uint32_t           descriptorCount;
} VkCopyDescriptorSet;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>srcSet</code>, <code>srcBinding</code>, and <code>srcArrayElement</code> are the source
set, binding, and array element, respectively.</p>
</li>
<li>
<p><code>dstSet</code>, <code>dstBinding</code>, and <code>dstArrayElement</code> are the
destination set, binding, and array element, respectively.</p>
</li>
<li>
<p><code>descriptorCount</code> is the number of descriptors to copy from the
source to destination.
If <code>descriptorCount</code> is greater than the number of remaining array
elements in the source or destination binding, those affect consecutive
bindings in a manner similar to <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> above.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcBinding-00345" href="#VUID-VkCopyDescriptorSet-srcBinding-00345"></a>
<code>srcBinding</code> <strong class="purple">must</strong> be a valid binding within <code>srcSet</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcArrayElement-00346" href="#VUID-VkCopyDescriptorSet-srcArrayElement-00346"></a>
The sum of <code>srcArrayElement</code> and <code>descriptorCount</code> <strong class="purple">must</strong> be less
than or equal to the number of array elements in the descriptor set
binding specified by <code>srcBinding</code>, and all applicable consecutive
bindings, as described by <a href="#descriptorsets-updates-consecutive">consecutive binding updates</a></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-dstBinding-00347" href="#VUID-VkCopyDescriptorSet-dstBinding-00347"></a>
<code>dstBinding</code> <strong class="purple">must</strong> be a valid binding within <code>dstSet</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-dstArrayElement-00348" href="#VUID-VkCopyDescriptorSet-dstArrayElement-00348"></a>
The sum of <code>dstArrayElement</code> and <code>descriptorCount</code> <strong class="purple">must</strong> be less
than or equal to the number of array elements in the descriptor set
binding specified by <code>dstBinding</code>, and all applicable consecutive
bindings, as described by <a href="#descriptorsets-updates-consecutive">consecutive binding updates</a></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-dstBinding-02632" href="#VUID-VkCopyDescriptorSet-dstBinding-02632"></a>
The type of <code>dstBinding</code> within <code>dstSet</code> <strong class="purple">must</strong> be equal to the
type of <code>srcBinding</code> within <code>srcSet</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcSet-00349" href="#VUID-VkCopyDescriptorSet-srcSet-00349"></a>
If <code>srcSet</code> is equal to <code>dstSet</code>, then the source and
destination ranges of descriptors <strong class="purple">must</strong> not overlap, where the ranges
<strong class="purple">may</strong> include array elements from consecutive bindings as described by
<a href="#descriptorsets-updates-consecutive">consecutive binding updates</a></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-dstBinding-02753" href="#VUID-VkCopyDescriptorSet-dstBinding-02753"></a>
If the descriptor type of the descriptor set binding specified by
<code>dstBinding</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>, then <code>dstSet</code>
<strong class="purple">must</strong> not have been allocated with a layout that included immutable
samplers for <code>dstBinding</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkCopyDescriptorSet-sType-sType" href="#VUID-VkCopyDescriptorSet-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-pNext-pNext" href="#VUID-VkCopyDescriptorSet-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-srcSet-parameter" href="#VUID-VkCopyDescriptorSet-srcSet-parameter"></a> <code>srcSet</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorSet">VkDescriptorSet</a> handle</p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-dstSet-parameter" href="#VUID-VkCopyDescriptorSet-dstSet-parameter"></a> <code>dstSet</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorSet">VkDescriptorSet</a> handle</p>
</li>
<li>
<p><a id="VUID-VkCopyDescriptorSet-commonparent" href="#VUID-VkCopyDescriptorSet-commonparent"></a> Both of <code>dstSet</code>, and <code>srcSet</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap4.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-updates-with-template"><a class="anchor" href="#descriptorsets-updates-with-template"></a>13.2.5. Descriptor Update Templates</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>A descriptor update template specifies a mapping from descriptor update
information in host memory to descriptors in a descriptor set.
It is designed to avoid passing redundant information to the driver when
frequently updating the same set of descriptors in descriptor sets.</p>
</div>
<div class="paragraph">
<p>Descriptor update template objects are represented by
<code>VkDescriptorUpdateTemplate</code> handles:</p>
</div>
<div id="VkDescriptorUpdateTemplate" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorUpdateTemplate)</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorUpdateTemplateKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkDescriptorUpdateTemplate VkDescriptorUpdateTemplateKHR;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_descriptor_set_updates_with_templates"><a class="anchor" href="#_descriptor_set_updates_with_templates"></a>13.2.6. Descriptor Set Updates with Templates</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Updating a large <code>VkDescriptorSet</code> array <strong class="purple">can</strong> be an expensive operation
since an application <strong class="purple">must</strong> specify one <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> structure
for each descriptor or descriptor array to update, each of which
re-specifies the same state when updating the same descriptor in multiple
descriptor sets.
For cases when an application wishes to update the same set of descriptors
in multiple descriptor sets allocated using the same
<code>VkDescriptorSetLayout</code>, <a href="#vkUpdateDescriptorSetWithTemplate">vkUpdateDescriptorSetWithTemplate</a> <strong class="purple">can</strong> be
used as a replacement for <a href="#vkUpdateDescriptorSets">vkUpdateDescriptorSets</a>.</p>
</div>
<div class="paragraph">
<p><code>VkDescriptorUpdateTemplate</code> allows implementations to convert a set of
descriptor update operations on a single descriptor set to an internal
format that, in conjunction with <a href="#vkUpdateDescriptorSetWithTemplate">vkUpdateDescriptorSetWithTemplate</a>
or <a href="#vkCmdPushDescriptorSetWithTemplateKHR">vkCmdPushDescriptorSetWithTemplateKHR</a>
, <strong class="purple">can</strong> be more efficient compared to calling <a href="#vkUpdateDescriptorSets">vkUpdateDescriptorSets</a>
or <a href="#vkCmdPushDescriptorSetKHR">vkCmdPushDescriptorSetKHR</a>
.
The descriptors themselves are not specified in the
<code>VkDescriptorUpdateTemplate</code>, rather, offsets into an application
provided pointer to host memory are specified, which are combined with a
pointer passed to <a href="#vkUpdateDescriptorSetWithTemplate">vkUpdateDescriptorSetWithTemplate</a>
or <a href="#vkCmdPushDescriptorSetWithTemplateKHR">vkCmdPushDescriptorSetWithTemplateKHR</a>
.
This allows large batches of updates to be executed without having to
convert application data structures into a strictly-defined Vulkan data
structure.</p>
</div>
<div class="paragraph">
<p>To create a descriptor update template, call:</p>
</div>
<div id="vkCreateDescriptorUpdateTemplateKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkResult vkCreateDescriptorUpdateTemplateKHR(
    VkDevice                                    device,
    <span class="directive">const</span> VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator,
    VkDescriptorUpdateTemplate*                 pDescriptorUpdateTemplate);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that creates the descriptor update
template.</p>
</li>
<li>
<p><code>pCreateInfo</code> is a pointer to a
<a href="#VkDescriptorUpdateTemplateCreateInfo">VkDescriptorUpdateTemplateCreateInfo</a> structure specifying the set
of descriptors to update with a single call to
<a href="#vkCmdPushDescriptorSetWithTemplateKHR">vkCmdPushDescriptorSetWithTemplateKHR</a> or
<a href="#vkUpdateDescriptorSetWithTemplate">vkUpdateDescriptorSetWithTemplate</a>.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap10.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
<li>
<p><code>pDescriptorUpdateTemplate</code> is a pointer to a
<code>VkDescriptorUpdateTemplate</code> handle in which the resulting
descriptor update template object is returned.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCreateDescriptorUpdateTemplate-device-parameter" href="#VUID-vkCreateDescriptorUpdateTemplate-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorUpdateTemplate-pCreateInfo-parameter" href="#VUID-vkCreateDescriptorUpdateTemplate-pCreateInfo-parameter"></a> <code>pCreateInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkDescriptorUpdateTemplateCreateInfo">VkDescriptorUpdateTemplateCreateInfo</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorUpdateTemplate-pAllocator-parameter" href="#VUID-vkCreateDescriptorUpdateTemplate-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap10.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkCreateDescriptorUpdateTemplate-pDescriptorUpdateTemplate-parameter" href="#VUID-vkCreateDescriptorUpdateTemplate-pDescriptorUpdateTemplate-parameter"></a> <code>pDescriptorUpdateTemplate</code> <strong class="purple">must</strong> be a valid pointer to a <a href="#VkDescriptorUpdateTemplate">VkDescriptorUpdateTemplate</a> handle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Return Codes</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="chap2.html#fundamentals-successcodes">Success</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_SUCCESS</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="chap2.html#fundamentals-errorcodes">Failure</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>VK_ERROR_OUT_OF_HOST_MEMORY</code></p>
</li>
<li>
<p><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <a href="#VkDescriptorUpdateTemplateCreateInfo">VkDescriptorUpdateTemplateCreateInfo</a> structure is defined as:</p>
</div>
<div id="VkDescriptorUpdateTemplateCreateInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorUpdateTemplateCreateInfo {
    VkStructureType                           sType;
    <span class="directive">const</span> <span class="directive">void</span>*                               pNext;
    VkDescriptorUpdateTemplateCreateFlags     flags;
    uint32_t                                  descriptorUpdateEntryCount;
    <span class="directive">const</span> VkDescriptorUpdateTemplateEntry*    pDescriptorUpdateEntries;
    VkDescriptorUpdateTemplateType            templateType;
    VkDescriptorSetLayout                     descriptorSetLayout;
    VkPipelineBindPoint                       pipelineBindPoint;
    VkPipelineLayout                          pipelineLayout;
    uint32_t                                  set;
} VkDescriptorUpdateTemplateCreateInfo;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorUpdateTemplateCreateInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkDescriptorUpdateTemplateCreateInfo VkDescriptorUpdateTemplateCreateInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>flags</code> is reserved for future use.</p>
</li>
<li>
<p><code>descriptorUpdateEntryCount</code> is the number of elements in the
<code>pDescriptorUpdateEntries</code> array.</p>
</li>
<li>
<p><code>pDescriptorUpdateEntries</code> is a pointer to an array of
<a href="#VkDescriptorUpdateTemplateEntry">VkDescriptorUpdateTemplateEntry</a> structures describing the
descriptors to be updated by the descriptor update template.</p>
</li>
<li>
<p><code>templateType</code> Specifies the type of the descriptor update template.
If set to <code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET</code> it
<strong class="purple">can</strong> only be used to update descriptor sets with a fixed
<code>descriptorSetLayout</code>.
If set to <code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code>
it <strong class="purple">can</strong> only be used to push descriptor sets using the provided
<code>pipelineBindPoint</code>, <code>pipelineLayout</code>, and <code>set</code> number.</p>
</li>
<li>
<p><code>descriptorSetLayout</code> is the descriptor set layout the parameter
update template will be used with.
All descriptor sets which are going to be updated through the newly
created descriptor update template <strong class="purple">must</strong> be created with this layout.
<code>descriptorSetLayout</code> is the descriptor set layout used to build the
descriptor update template.
All descriptor sets which are going to be updated through the newly
created descriptor update template <strong class="purple">must</strong> be created with a layout that
matches (is the same as, or defined identically to) this layout.
This parameter is ignored if <code>templateType</code> is not
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET</code>.</p>
</li>
<li>
<p><code>pipelineBindPoint</code> is a <a href="chap9.html#VkPipelineBindPoint">VkPipelineBindPoint</a> indicating
whether the descriptors will be used by graphics pipelines or compute
pipelines.
This parameter is ignored if <code>templateType</code> is not
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code></p>
</li>
<li>
<p><code>pipelineLayout</code> is a <a href="#VkPipelineLayout">VkPipelineLayout</a> object used to program
the bindings.
This parameter is ignored if <code>templateType</code> is not
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code></p>
</li>
<li>
<p><code>set</code> is the set number of the descriptor set in the pipeline layout
that will be updated.
This parameter is ignored if <code>templateType</code> is not
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code></p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00350" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00350"></a>
If <code>templateType</code> is
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET</code>,
<code>descriptorSetLayout</code> <strong class="purple">must</strong> be a valid <code>VkDescriptorSetLayout</code>
handle</p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00351" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00351"></a>
If <code>templateType</code> is
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code>,
<code>pipelineBindPoint</code> <strong class="purple">must</strong> be a valid <a href="chap9.html#VkPipelineBindPoint">VkPipelineBindPoint</a> value</p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00352" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00352"></a>
If <code>templateType</code> is
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code>,
<code>pipelineLayout</code> <strong class="purple">must</strong> be a valid <code>VkPipelineLayout</code> handle</p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00353" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00353"></a>
If <code>templateType</code> is
<code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code>, <code>set</code>
<strong class="purple">must</strong> be the unique set number in the pipeline layout that uses a
descriptor set layout that was created with
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-sType-sType" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-pNext-pNext" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-flags-zerobitmask" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-flags-zerobitmask"></a> <code>flags</code> <strong class="purple">must</strong> be <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-pDescriptorUpdateEntries-parameter" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-pDescriptorUpdateEntries-parameter"></a> <code>pDescriptorUpdateEntries</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorUpdateEntryCount</code> valid <a href="#VkDescriptorUpdateTemplateEntry">VkDescriptorUpdateTemplateEntry</a> structures</p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-parameter" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-parameter"></a> <code>templateType</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorUpdateTemplateType">VkDescriptorUpdateTemplateType</a> value</p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-descriptorUpdateEntryCount-arraylength" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-descriptorUpdateEntryCount-arraylength"></a> <code>descriptorUpdateEntryCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateCreateInfo-commonparent" href="#VUID-VkDescriptorUpdateTemplateCreateInfo-commonparent"></a> Both of <code>descriptorSetLayout</code>, and <code>pipelineLayout</code> that are valid handles of non-ignored parameters <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap4.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div id="VkDescriptorUpdateTemplateCreateFlags" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkFlags VkDescriptorUpdateTemplateCreateFlags;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorUpdateTemplateCreateFlagsKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkDescriptorUpdateTemplateCreateFlags VkDescriptorUpdateTemplateCreateFlagsKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkDescriptorUpdateTemplateCreateFlags</code> is a bitmask type for setting a
mask, but is currently reserved for future use.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The descriptor update template type is determined by the
<a href="#VkDescriptorUpdateTemplateCreateInfo">VkDescriptorUpdateTemplateCreateInfo</a>::<code>templateType</code> property,
which takes the following values:</p>
</div>
<div id="VkDescriptorUpdateTemplateType" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">enum</span> VkDescriptorUpdateTemplateType {
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = <span class="integer">0</span>,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = <span class="integer">1</span>,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = <span class="hex">0x7FFFFFFF</span>
} VkDescriptorUpdateTemplateType;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorUpdateTemplateTypeKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkDescriptorUpdateTemplateType VkDescriptorUpdateTemplateTypeKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET</code> specifies that
the descriptor update template will be used for descriptor set updates
only.</p>
</li>
<li>
<p><code>VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR</code> specifies
that the descriptor update template will be used for push descriptor
updates only.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkDescriptorUpdateTemplateEntry</code> structure is defined as:</p>
</div>
<div id="VkDescriptorUpdateTemplateEntry" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkDescriptorUpdateTemplateEntry {
    uint32_t            dstBinding;
    uint32_t            dstArrayElement;
    uint32_t            descriptorCount;
    VkDescriptorType    descriptorType;
    size_t              offset;
    size_t              stride;
} VkDescriptorUpdateTemplateEntry;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkDescriptorUpdateTemplateEntryKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkDescriptorUpdateTemplateEntry VkDescriptorUpdateTemplateEntryKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>dstBinding</code> is the descriptor binding to update when using this
descriptor update template.</p>
</li>
<li>
<p><code>dstArrayElement</code> is the starting element in the array belonging to
<code>dstBinding</code>.</p>
</li>
<li>
<p><code>descriptorCount</code> is the number of descriptors to update.
If <code>descriptorCount</code> is greater than the number of remaining array
elements in the destination binding, those affect consecutive bindings
in a manner similar to <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> above.</p>
</li>
<li>
<p><code>descriptorType</code> is a <a href="#VkDescriptorType">VkDescriptorType</a> specifying the type of
the descriptor.</p>
</li>
<li>
<p><code>offset</code> is the offset in bytes of the first binding in the raw data
structure.</p>
</li>
<li>
<p><code>stride</code> is the stride in bytes between two consecutive array
elements of the descriptor update informations in the raw data
structure.
The actual pointer ptr for each array element j of update entry i is
computed using the following formula:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">    <span class="directive">const</span> <span class="predefined-type">char</span> *ptr = (<span class="directive">const</span> <span class="predefined-type">char</span> *)pData + pDescriptorUpdateEntries[i].offset + j * pDescriptorUpdateEntries[i].stride</code></pre>
</div>
</div>
<div class="paragraph">
<p>The stride is useful in case the bindings are stored in structs along with
other data.</p>
</div>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateEntry-dstBinding-00354" href="#VUID-VkDescriptorUpdateTemplateEntry-dstBinding-00354"></a>
<code>dstBinding</code> <strong class="purple">must</strong> be a valid binding in the descriptor set layout
implicitly specified when using a descriptor update template to update
descriptors</p>
</li>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateEntry-dstArrayElement-00355" href="#VUID-VkDescriptorUpdateTemplateEntry-dstArrayElement-00355"></a>
<code>dstArrayElement</code> and <code>descriptorCount</code> <strong class="purple">must</strong> be less than or
equal to the number of array elements in the descriptor set binding
implicitly specified when using a descriptor update template to update
descriptors, and all applicable consecutive bindings, as described by
<a href="#descriptorsets-updates-consecutive">consecutive binding updates</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkDescriptorUpdateTemplateEntry-descriptorType-parameter" href="#VUID-VkDescriptorUpdateTemplateEntry-descriptorType-parameter"></a> <code>descriptorType</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorType">VkDescriptorType</a> value</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To destroy a descriptor update template, call:</p>
</div>
<div id="vkDestroyDescriptorUpdateTemplateKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> vkDestroyDescriptorUpdateTemplateKHR(
    VkDevice                                    device,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    <span class="directive">const</span> VkAllocationCallbacks*                pAllocator);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that has been used to create the
descriptor update template</p>
</li>
<li>
<p><code>descriptorUpdateTemplate</code> is the descriptor update template to
destroy.</p>
</li>
<li>
<p><code>pAllocator</code> controls host memory allocation as described in the
<a href="chap10.html#memory-allocation">Memory Allocation</a> chapter.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00356" href="#VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00356"></a>
If <code>VkAllocationCallbacks</code> were provided when
<code>descriptorSetLayout</code> was created, a compatible set of callbacks
<strong class="purple">must</strong> be provided here</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00357" href="#VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00357"></a>
If no <code>VkAllocationCallbacks</code> were provided when
<code>descriptorSetLayout</code> was created, <code>pAllocator</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkDestroyDescriptorUpdateTemplate-device-parameter" href="#VUID-vkDestroyDescriptorUpdateTemplate-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parameter" href="#VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parameter"></a> If <code>descriptorUpdateTemplate</code> is not <a href="chap44.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>descriptorUpdateTemplate</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorUpdateTemplate">VkDescriptorUpdateTemplate</a> handle</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorUpdateTemplate-pAllocator-parameter" href="#VUID-vkDestroyDescriptorUpdateTemplate-pAllocator-parameter"></a> If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="chap10.html#VkAllocationCallbacks">VkAllocationCallbacks</a> structure</p>
</li>
<li>
<p><a id="VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parent" href="#VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parent"></a> If <code>descriptorUpdateTemplate</code> is a valid handle, it <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>descriptorUpdateTemplate</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Once a <code>VkDescriptorUpdateTemplate</code> has been created, descriptor sets
<strong class="purple">can</strong> be updated by calling:</p>
</div>
<div id="vkUpdateDescriptorSetWithTemplateKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> vkUpdateDescriptorSetWithTemplateKHR(
    VkDevice                                    device,
    VkDescriptorSet                             descriptorSet,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    <span class="directive">const</span> <span class="directive">void</span>*                                 pData);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that updates the descriptor sets.</p>
</li>
<li>
<p><code>descriptorSet</code> is the descriptor set to update</p>
</li>
<li>
<p><code>descriptorUpdateTemplate</code> is a <a href="#VkDescriptorUpdateTemplate">VkDescriptorUpdateTemplate</a>
object specifying the update mapping between <code>pData</code> and the
descriptor set to update.</p>
</li>
<li>
<p><code>pData</code> is a pointer to memory containing one or more
<a href="#VkDescriptorImageInfo">VkDescriptorImageInfo</a>, <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a>, or
<a href="chap11.html#VkBufferView">VkBufferView</a> structures used to write the descriptors.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkUpdateDescriptorSetWithTemplate-pData-01685" href="#VUID-vkUpdateDescriptorSetWithTemplate-pData-01685"></a>
<code>pData</code> <strong class="purple">must</strong> be a valid pointer to a memory containing one or more
valid instances of <a href="#VkDescriptorImageInfo">VkDescriptorImageInfo</a>,
<a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a>, or <a href="chap11.html#VkBufferView">VkBufferView</a> in a layout defined
by <code>descriptorUpdateTemplate</code> when it was created with
<a href="#vkCreateDescriptorUpdateTemplate">vkCreateDescriptorUpdateTemplate</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkUpdateDescriptorSetWithTemplate-device-parameter" href="#VUID-vkUpdateDescriptorSetWithTemplate-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkUpdateDescriptorSetWithTemplate-descriptorSet-parameter" href="#VUID-vkUpdateDescriptorSetWithTemplate-descriptorSet-parameter"></a> <code>descriptorSet</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorSet">VkDescriptorSet</a> handle</p>
</li>
<li>
<p><a id="VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parameter" href="#VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parameter"></a> <code>descriptorUpdateTemplate</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorUpdateTemplate">VkDescriptorUpdateTemplate</a> handle</p>
</li>
<li>
<p><a id="VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parent" href="#VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parent"></a> <code>descriptorUpdateTemplate</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from <code>device</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>descriptorSet</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">API example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">struct</span> AppBufferView {
    VkBufferView bufferView;
    uint32_t     applicationRelatedInformation;
};

<span class="keyword">struct</span> AppDataStructure
{
    VkDescriptorImageInfo  imageInfo;          <span class="comment">// a single image info</span>
    VkDescriptorBufferInfo bufferInfoArray[<span class="integer">3</span>]; <span class="comment">// 3 buffer infos in an array</span>
    AppBufferView          bufferView[<span class="integer">2</span>];      <span class="comment">// An application defined structure containing a bufferView</span>
    <span class="comment">// ... some more application related data</span>
};

<span class="directive">const</span> VkDescriptorUpdateTemplateEntry descriptorUpdateTemplateEntries[] =
{
    <span class="comment">// binding to a single image descriptor</span>
    {
        <span class="integer">0</span>,                                           <span class="comment">// binding</span>
        <span class="integer">0</span>,                                           <span class="comment">// dstArrayElement</span>
        <span class="integer">1</span>,                                           <span class="comment">// descriptorCount</span>
        VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,   <span class="comment">// descriptorType</span>
        offsetof(AppDataStructure, imageInfo),       <span class="comment">// offset</span>
        <span class="integer">0</span>                                            <span class="comment">// stride is not required if descriptorCount is 1</span>
    },

    <span class="comment">// binding to an array of buffer descriptors</span>
    {
        <span class="integer">1</span>,                                           <span class="comment">// binding</span>
        <span class="integer">0</span>,                                           <span class="comment">// dstArrayElement</span>
        <span class="integer">3</span>,                                           <span class="comment">// descriptorCount</span>
        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,           <span class="comment">// descriptorType</span>
        offsetof(AppDataStructure, bufferInfoArray), <span class="comment">// offset</span>
        <span class="keyword">sizeof</span>(VkDescriptorBufferInfo)               <span class="comment">// stride, descriptor buffer infos are compact</span>
    },

    <span class="comment">// binding to an array of buffer views</span>
    {
        <span class="integer">2</span>,                                           <span class="comment">// binding</span>
        <span class="integer">0</span>,                                           <span class="comment">// dstArrayElement</span>
        <span class="integer">2</span>,                                           <span class="comment">// descriptorCount</span>
        VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,     <span class="comment">// descriptorType</span>
        offsetof(AppDataStructure, bufferView) +
          offsetof(AppBufferView, bufferView),       <span class="comment">// offset</span>
        <span class="keyword">sizeof</span>(AppBufferView)                        <span class="comment">// stride, bufferViews do not have to be compact</span>
    },
};

<span class="comment">// create a descriptor update template for descriptor set updates</span>
<span class="directive">const</span> VkDescriptorUpdateTemplateCreateInfo createInfo =
{
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,  <span class="comment">// sType</span>
    <span class="predefined-constant">NULL</span>,                                                      <span class="comment">// pNext</span>
    <span class="integer">0</span>,                                                         <span class="comment">// flags</span>
    <span class="integer">3</span>,                                                         <span class="comment">// descriptorUpdateEntryCount</span>
    descriptorUpdateTemplateEntries,                           <span class="comment">// pDescriptorUpdateEntries</span>
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,         <span class="comment">// templateType</span>
    myLayout,                                                  <span class="comment">// descriptorSetLayout</span>
    <span class="integer">0</span>,                                                         <span class="comment">// pipelineBindPoint, ignored by given templateType</span>
    <span class="integer">0</span>,                                                         <span class="comment">// pipelineLayout, ignored by given templateType</span>
    <span class="integer">0</span>,                                                         <span class="comment">// set, ignored by given templateType</span>
};

VkDescriptorUpdateTemplate myDescriptorUpdateTemplate;
myResult = vkCreateDescriptorUpdateTemplate(
    myDevice,
    &amp;createInfo,
    <span class="predefined-constant">NULL</span>,
    &amp;myDescriptorUpdateTemplate);
}


AppDataStructure appData;

<span class="comment">// fill appData here or cache it in your engine</span>
vkUpdateDescriptorSetWithTemplate(myDevice, myDescriptorSet, myDescriptorUpdateTemplate, &amp;appData);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-binding"><a class="anchor" href="#descriptorsets-binding"></a>13.2.7. Descriptor Set Binding</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To bind one or more descriptor sets to a command buffer, call:</p>
</div>
<div id="vkCmdBindDescriptorSets" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> vkCmdBindDescriptorSets(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    <span class="directive">const</span> VkDescriptorSet*                      pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    <span class="directive">const</span> uint32_t*                             pDynamicOffsets);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>commandBuffer</code> is the command buffer that the descriptor sets will
be bound to.</p>
</li>
<li>
<p><code>pipelineBindPoint</code> is a <a href="chap9.html#VkPipelineBindPoint">VkPipelineBindPoint</a> indicating
whether the descriptors will be used by graphics pipelines or compute
pipelines.
There is a separate set of bind points for each of graphics and compute,
so binding one does not disturb the other.</p>
</li>
<li>
<p><code>layout</code> is a <a href="#VkPipelineLayout">VkPipelineLayout</a> object used to program the
bindings.</p>
</li>
<li>
<p><code>firstSet</code> is the set number of the first descriptor set to be
bound.</p>
</li>
<li>
<p><code>descriptorSetCount</code> is the number of elements in the
<code>pDescriptorSets</code> array.</p>
</li>
<li>
<p><code>pDescriptorSets</code> is a pointer to an array of handles to
<a href="#VkDescriptorSet">VkDescriptorSet</a> objects describing the descriptor sets to write
to.</p>
</li>
<li>
<p><code>dynamicOffsetCount</code> is the number of dynamic offsets in the
<code>pDynamicOffsets</code> array.</p>
</li>
<li>
<p><code>pDynamicOffsets</code> is a pointer to an array of <code>uint32_t</code> values
specifying dynamic offsets.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>vkCmdBindDescriptorSets</code> causes the sets numbered [<code>firstSet</code>..
<code>firstSet</code>+<code>descriptorSetCount</code>-1] to use the bindings stored in
<code>pDescriptorSets</code>[0..descriptorSetCount-1] for subsequent rendering
commands (either compute or graphics, according to the
<code>pipelineBindPoint</code>).
Any bindings that were previously applied via these sets are no longer
valid.</p>
</div>
<div class="paragraph">
<p>Once bound, a descriptor set affects rendering of subsequent graphics or
compute commands in the command buffer until a different set is bound to the
same set number, or else until the set is disturbed as described in
<a href="#descriptorsets-compatibility">Pipeline Layout Compatibility</a>.</p>
</div>
<div class="paragraph">
<p>A compatible descriptor set <strong class="purple">must</strong> be bound for all set numbers that any
shaders in a pipeline access, at the time that a draw or dispatch command is
recorded to execute using that pipeline.
However, if none of the shaders in a pipeline statically use any bindings
with a particular set number, then no descriptor set need be bound for that
set number, even if the pipeline layout includes a non-trivial descriptor
set layout for that set number.</p>
</div>
<div id="descriptorsets-binding-dynamicoffsets" class="paragraph">
<p>If any of the sets being bound include dynamic uniform or storage buffers,
then <code>pDynamicOffsets</code> includes one element for each array element in
each dynamic descriptor type binding in each set.
Values are taken from <code>pDynamicOffsets</code> in an order such that all
entries for set N come before set N+1; within a set, entries are ordered by
the binding numbers in the descriptor set layouts; and within a binding
array, elements are in order.
<code>dynamicOffsetCount</code> <strong class="purple">must</strong> equal the total number of dynamic descriptors
in the sets being bound.</p>
</div>
<div class="paragraph">
<p>The effective offset used for dynamic uniform and storage buffer bindings is
the sum of the relative offset taken from <code>pDynamicOffsets</code>, and the
base address of the buffer plus base offset in the descriptor set.
The range of the dynamic uniform and storage buffer bindings is the buffer
range as specified in the descriptor set.</p>
</div>
<div class="paragraph">
<p>Each of the <code>pDescriptorSets</code> <strong class="purple">must</strong> be compatible with the pipeline
layout specified by <code>layout</code>.
The layout used to program the bindings <strong class="purple">must</strong> also be compatible with the
pipeline used in subsequent graphics or compute commands, as defined in the
<a href="#descriptorsets-compatibility">Pipeline Layout Compatibility</a> section.</p>
</div>
<div class="paragraph">
<p>The descriptor set contents bound by a call to <code>vkCmdBindDescriptorSets</code>
<strong class="purple">may</strong> be consumed at the following times:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>during host execution of the command, or during shader execution of the
resulting draws and dispatches, or any time in between.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Thus, the contents of a descriptor set binding <strong class="purple">must</strong> not be altered
(overwritten by an update command, or freed) between the first point in time
that it <strong class="purple">may</strong> be consumed, and when the command completes executing on the
queue.</p>
</div>
<div class="paragraph">
<p>The contents of <code>pDynamicOffsets</code> are consumed immediately during
execution of <code>vkCmdBindDescriptorSets</code>.
Once all pending uses have completed, it is legal to update and reuse a
descriptor set.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pDescriptorSets-00358" href="#VUID-vkCmdBindDescriptorSets-pDescriptorSets-00358"></a>
Each element of <code>pDescriptorSets</code> <strong class="purple">must</strong> have been allocated with a
<code>VkDescriptorSetLayout</code> that matches (is the same as, or identically
defined as) the <code>VkDescriptorSetLayout</code> at set <em>n</em> in <code>layout</code>,
where <em>n</em> is the sum of <code>firstSet</code> and the index into
<code>pDescriptorSets</code></p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-dynamicOffsetCount-00359" href="#VUID-vkCmdBindDescriptorSets-dynamicOffsetCount-00359"></a>
<code>dynamicOffsetCount</code> <strong class="purple">must</strong> be equal to the total number of dynamic
descriptors in <code>pDescriptorSets</code></p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-firstSet-00360" href="#VUID-vkCmdBindDescriptorSets-firstSet-00360"></a>
The sum of <code>firstSet</code> and <code>descriptorSetCount</code> <strong class="purple">must</strong> be less
than or equal to <a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a>::<code>setLayoutCount</code>
provided when <code>layout</code> was created</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pipelineBindPoint-00361" href="#VUID-vkCmdBindDescriptorSets-pipelineBindPoint-00361"></a>
<code>pipelineBindPoint</code> <strong class="purple">must</strong> be supported by the <code>commandBuffer</code>’s
parent <code>VkCommandPool</code>’s queue family</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01971" href="#VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01971"></a>
Each element of <code>pDynamicOffsets</code> which corresponds to a descriptor
binding with type <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> <strong class="purple">must</strong>
be a multiple of
<code>VkPhysicalDeviceLimits</code>::<code>minUniformBufferOffsetAlignment</code></p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01972" href="#VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01972"></a>
Each element of <code>pDynamicOffsets</code> which corresponds to a descriptor
binding with type <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> <strong class="purple">must</strong>
be a multiple of
<code>VkPhysicalDeviceLimits</code>::<code>minStorageBufferOffsetAlignment</code></p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pDescriptorSets-01979" href="#VUID-vkCmdBindDescriptorSets-pDescriptorSets-01979"></a>
For each dynamic uniform or storage buffer binding in
<code>pDescriptorSets</code>, the sum of the effective offset, as defined
above, and the range of the binding <strong class="purple">must</strong> be less than or equal to the
size of the buffer</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-commandBuffer-parameter" href="#VUID-vkCmdBindDescriptorSets-commandBuffer-parameter"></a> <code>commandBuffer</code> <strong class="purple">must</strong> be a valid <a href="chap5.html#VkCommandBuffer">VkCommandBuffer</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pipelineBindPoint-parameter" href="#VUID-vkCmdBindDescriptorSets-pipelineBindPoint-parameter"></a> <code>pipelineBindPoint</code> <strong class="purple">must</strong> be a valid <a href="chap9.html#VkPipelineBindPoint">VkPipelineBindPoint</a> value</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-layout-parameter" href="#VUID-vkCmdBindDescriptorSets-layout-parameter"></a> <code>layout</code> <strong class="purple">must</strong> be a valid <a href="#VkPipelineLayout">VkPipelineLayout</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pDescriptorSets-parameter" href="#VUID-vkCmdBindDescriptorSets-pDescriptorSets-parameter"></a> <code>pDescriptorSets</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorSetCount</code> valid <a href="#VkDescriptorSet">VkDescriptorSet</a> handles</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-pDynamicOffsets-parameter" href="#VUID-vkCmdBindDescriptorSets-pDynamicOffsets-parameter"></a> If <code>dynamicOffsetCount</code> is not <code>0</code>, <code>pDynamicOffsets</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>dynamicOffsetCount</code> <code>uint32_t</code> values</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-commandBuffer-recording" href="#VUID-vkCmdBindDescriptorSets-commandBuffer-recording"></a> <code>commandBuffer</code> <strong class="purple">must</strong> be in the <a href="chap5.html#commandbuffers-lifecycle">recording state</a></p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-commandBuffer-cmdpool" href="#VUID-vkCmdBindDescriptorSets-commandBuffer-cmdpool"></a> The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> support graphics, or compute operations</p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-descriptorSetCount-arraylength" href="#VUID-vkCmdBindDescriptorSets-descriptorSetCount-arraylength"></a> <code>descriptorSetCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-vkCmdBindDescriptorSets-commonparent" href="#VUID-vkCmdBindDescriptorSets-commonparent"></a> Each of <code>commandBuffer</code>, <code>layout</code>, and the elements of <code>pDescriptorSets</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap4.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>commandBuffer</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Command Properties</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><a href="chap5.html#VkCommandBufferLevel">Command Buffer Levels</a></th>
<th class="tableblock halign-left valign-top"><a href="chap7.html#vkCmdBeginRenderPass">Render Pass Scope</a></th>
<th class="tableblock halign-left valign-top"><a href="chap4.html#VkQueueFlagBits">Supported Queue Types</a></th>
<th class="tableblock halign-left valign-top"><a href="chap6.html#synchronization-pipeline-stages-types">Pipeline Type</a></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br>
Secondary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br>
Compute</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="descriptorsets-push-descriptors"><a class="anchor" href="#descriptorsets-push-descriptors"></a>13.2.8. Push Descriptor Updates</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>In addition to allocating descriptor sets and binding them to a command
buffer, an application <strong class="purple">can</strong> record descriptor updates into the command
buffer.</p>
</div>
<div class="paragraph">
<p>To push descriptor updates into a command buffer, call:</p>
</div>
<div id="vkCmdPushDescriptorSetKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> vkCmdPushDescriptorSetKHR(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    uint32_t                                    descriptorWriteCount,
    <span class="directive">const</span> VkWriteDescriptorSet*                 pDescriptorWrites);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>commandBuffer</code> is the command buffer that the descriptors will be
recorded in.</p>
</li>
<li>
<p><code>pipelineBindPoint</code> is a <a href="chap9.html#VkPipelineBindPoint">VkPipelineBindPoint</a> indicating
whether the descriptors will be used by graphics pipelines or compute
pipelines.
There is a separate set of push descriptor bindings for each of graphics
and compute, so binding one does not disturb the other.</p>
</li>
<li>
<p><code>layout</code> is a <a href="#VkPipelineLayout">VkPipelineLayout</a> object used to program the
bindings.</p>
</li>
<li>
<p><code>set</code> is the set number of the descriptor set in the pipeline layout
that will be updated.</p>
</li>
<li>
<p><code>descriptorWriteCount</code> is the number of elements in the
<code>pDescriptorWrites</code> array.</p>
</li>
<li>
<p><code>pDescriptorWrites</code> is a pointer to an array of
<a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> structures describing the descriptors to be
updated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Push descriptors</em> are a small bank of descriptors whose storage is
internally managed by the command buffer rather than being written into a
descriptor set and later bound to a command buffer.
Push descriptors allow for incremental updates of descriptors without
managing the lifetime of descriptor sets.</p>
</div>
<div class="paragraph">
<p>When a command buffer begins recording, all push descriptors are undefined.
Push descriptors <strong class="purple">can</strong> be updated incrementally and cause shaders to use the
updated descriptors for subsequent rendering commands (either compute or
graphics, according to the <code>pipelineBindPoint</code>) until the descriptor is
overwritten, or else until the set is disturbed as described in
<a href="#descriptorsets-compatibility">Pipeline Layout Compatibility</a>.
When the set is disturbed or push descriptors with a different descriptor
set layout are set, all push descriptors are undefined.</p>
</div>
<div class="paragraph">
<p>Push descriptors that are <a href="chap8.html#shaders-staticuse">statically used</a> by a
pipeline <strong class="purple">must</strong> not be undefined at the time that a draw or dispatch command
is recorded to execute using that pipeline.
This includes immutable sampler descriptors, which <strong class="purple">must</strong> be pushed before
they are accessed by a pipeline (the immutable samplers are pushed, rather
than the samplers in <code>pDescriptorWrites</code>).
Push descriptors that are not statically used <strong class="purple">can</strong> remain undefined.</p>
</div>
<div class="paragraph">
<p>Push descriptors do not use dynamic offsets.
Instead, the corresponding non-dynamic descriptor types <strong class="purple">can</strong> be used and the
<code>offset</code> member of <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a> <strong class="purple">can</strong> be changed each
time the descriptor is written.</p>
</div>
<div class="paragraph">
<p>Each element of <code>pDescriptorWrites</code> is interpreted as in
<a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>, except the <code>dstSet</code> member is ignored.</p>
</div>
<div class="paragraph">
<p>To push an immutable sampler, use a <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> with
<code>dstBinding</code> and <code>dstArrayElement</code> selecting the immutable sampler’s
binding.
If the descriptor type is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>, the
<code>pImageInfo</code> parameter is ignored and the immutable sampler is taken
from the push descriptor set layout in the pipeline layout.
If the descriptor type is <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>,
the <code>sampler</code> member of the <code>pImageInfo</code> parameter is ignored and
the immutable sampler is taken from the push descriptor set layout in the
pipeline layout.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-00363" href="#VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-00363"></a>
<code>pipelineBindPoint</code> <strong class="purple">must</strong> be supported by the <code>commandBuffer</code>’s
parent <code>VkCommandPool</code>’s queue family</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-set-00364" href="#VUID-vkCmdPushDescriptorSetKHR-set-00364"></a>
<code>set</code> <strong class="purple">must</strong> be less than
<a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a>::<code>setLayoutCount</code> provided when
<code>layout</code> was created</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-set-00365" href="#VUID-vkCmdPushDescriptorSetKHR-set-00365"></a>
<code>set</code> <strong class="purple">must</strong> be the unique set number in the pipeline layout that
uses a descriptor set layout that was created with
<code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-commandBuffer-parameter" href="#VUID-vkCmdPushDescriptorSetKHR-commandBuffer-parameter"></a> <code>commandBuffer</code> <strong class="purple">must</strong> be a valid <a href="chap5.html#VkCommandBuffer">VkCommandBuffer</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-parameter" href="#VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-parameter"></a> <code>pipelineBindPoint</code> <strong class="purple">must</strong> be a valid <a href="chap9.html#VkPipelineBindPoint">VkPipelineBindPoint</a> value</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-layout-parameter" href="#VUID-vkCmdPushDescriptorSetKHR-layout-parameter"></a> <code>layout</code> <strong class="purple">must</strong> be a valid <a href="#VkPipelineLayout">VkPipelineLayout</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-pDescriptorWrites-parameter" href="#VUID-vkCmdPushDescriptorSetKHR-pDescriptorWrites-parameter"></a> <code>pDescriptorWrites</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>descriptorWriteCount</code> valid <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> structures</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-commandBuffer-recording" href="#VUID-vkCmdPushDescriptorSetKHR-commandBuffer-recording"></a> <code>commandBuffer</code> <strong class="purple">must</strong> be in the <a href="chap5.html#commandbuffers-lifecycle">recording state</a></p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-commandBuffer-cmdpool" href="#VUID-vkCmdPushDescriptorSetKHR-commandBuffer-cmdpool"></a> The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> support graphics, or compute operations</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-descriptorWriteCount-arraylength" href="#VUID-vkCmdPushDescriptorSetKHR-descriptorWriteCount-arraylength"></a> <code>descriptorWriteCount</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetKHR-commonparent" href="#VUID-vkCmdPushDescriptorSetKHR-commonparent"></a> Both of <code>commandBuffer</code>, and <code>layout</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap4.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>commandBuffer</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Command Properties</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><a href="chap5.html#VkCommandBufferLevel">Command Buffer Levels</a></th>
<th class="tableblock halign-left valign-top"><a href="chap7.html#vkCmdBeginRenderPass">Render Pass Scope</a></th>
<th class="tableblock halign-left valign-top"><a href="chap4.html#VkQueueFlagBits">Supported Queue Types</a></th>
<th class="tableblock halign-left valign-top"><a href="chap6.html#synchronization-pipeline-stages-types">Pipeline Type</a></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br>
Secondary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br>
Compute</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_push_descriptor_updates_with_descriptor_update_templates"><a class="anchor" href="#_push_descriptor_updates_with_descriptor_update_templates"></a>13.2.9. Push Descriptor Updates with Descriptor Update Templates</h4>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>It is also possible to use a descriptor update template to specify the push
descriptors to update.
To do so, call:</p>
</div>
<div id="vkCmdPushDescriptorSetWithTemplateKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> vkCmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer                             commandBuffer,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    <span class="directive">const</span> <span class="directive">void</span>*                                 pData);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>commandBuffer</code> is the command buffer that the descriptors will be
recorded in.</p>
</li>
<li>
<p><code>descriptorUpdateTemplate</code> is a descriptor update template defining
how to interpret the descriptor information in <code>pData</code>.</p>
</li>
<li>
<p><code>layout</code> is a <a href="#VkPipelineLayout">VkPipelineLayout</a> object used to program the
bindings.
It <strong class="purple">must</strong> be compatible with the layout used to create the
<code>descriptorUpdateTemplate</code> handle.</p>
</li>
<li>
<p><code>set</code> is the set number of the descriptor set in the pipeline layout
that will be updated.
This <strong class="purple">must</strong> be the same number used to create the
<code>descriptorUpdateTemplate</code> handle.</p>
</li>
<li>
<p><code>pData</code> is a pointer to memory containing descriptors for the
templated update.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-00366" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-00366"></a>
The <code>pipelineBindPoint</code> specified during the creation of the
descriptor update template <strong class="purple">must</strong> be supported by the
<code>commandBuffer</code>’s parent <code>VkCommandPool</code>’s queue family</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-pData-01686" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-pData-01686"></a>
<code>pData</code> <strong class="purple">must</strong> be a valid pointer to a memory containing one or more
valid instances of <a href="#VkDescriptorImageInfo">VkDescriptorImageInfo</a>,
<a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a>, or <a href="chap11.html#VkBufferView">VkBufferView</a> in a layout defined
by <code>descriptorUpdateTemplate</code> when it was created with
<a href="#vkCreateDescriptorUpdateTemplateKHR">vkCreateDescriptorUpdateTemplateKHR</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-parameter" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-parameter"></a> <code>commandBuffer</code> <strong class="purple">must</strong> be a valid <a href="chap5.html#VkCommandBuffer">VkCommandBuffer</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-descriptorUpdateTemplate-parameter" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-descriptorUpdateTemplate-parameter"></a> <code>descriptorUpdateTemplate</code> <strong class="purple">must</strong> be a valid <a href="#VkDescriptorUpdateTemplate">VkDescriptorUpdateTemplate</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-layout-parameter" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-layout-parameter"></a> <code>layout</code> <strong class="purple">must</strong> be a valid <a href="#VkPipelineLayout">VkPipelineLayout</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-recording" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-recording"></a> <code>commandBuffer</code> <strong class="purple">must</strong> be in the <a href="chap5.html#commandbuffers-lifecycle">recording state</a></p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-cmdpool" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-cmdpool"></a> The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> support graphics, or compute operations</p>
</li>
<li>
<p><a id="VUID-vkCmdPushDescriptorSetWithTemplateKHR-commonparent" href="#VUID-vkCmdPushDescriptorSetWithTemplateKHR-commonparent"></a> Each of <code>commandBuffer</code>, <code>descriptorUpdateTemplate</code>, and <code>layout</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap4.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>commandBuffer</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Command Properties</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><a href="chap5.html#VkCommandBufferLevel">Command Buffer Levels</a></th>
<th class="tableblock halign-left valign-top"><a href="chap7.html#vkCmdBeginRenderPass">Render Pass Scope</a></th>
<th class="tableblock halign-left valign-top"><a href="chap4.html#VkQueueFlagBits">Supported Queue Types</a></th>
<th class="tableblock halign-left valign-top"><a href="chap6.html#synchronization-pipeline-stages-types">Pipeline Type</a></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br>
Secondary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br>
Compute</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="listingblock">
<div class="title">API example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">struct</span> AppDataStructure
{
    VkDescriptorImageInfo  imageInfo;          <span class="comment">// a single image info</span>
    <span class="comment">// ... some more application related data</span>
};

<span class="directive">const</span> VkDescriptorUpdateTemplateEntry descriptorUpdateTemplateEntries[] =
{
    <span class="comment">// binding to a single image descriptor</span>
    {
        <span class="integer">0</span>,                                           <span class="comment">// binding</span>
        <span class="integer">0</span>,                                           <span class="comment">// dstArrayElement</span>
        <span class="integer">1</span>,                                           <span class="comment">// descriptorCount</span>
        VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,   <span class="comment">// descriptorType</span>
        offsetof(AppDataStructure, imageInfo),       <span class="comment">// offset</span>
        <span class="integer">0</span>                                            <span class="comment">// stride is not required if descriptorCount is 1</span>
    }
};

<span class="comment">// create a descriptor update template for descriptor set updates</span>
<span class="directive">const</span> VkDescriptorUpdateTemplateCreateInfo createInfo =
{
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,  <span class="comment">// sType</span>
    <span class="predefined-constant">NULL</span>,                                                      <span class="comment">// pNext</span>
    <span class="integer">0</span>,                                                         <span class="comment">// flags</span>
    <span class="integer">1</span>,                                                         <span class="comment">// descriptorUpdateEntryCount</span>
    descriptorUpdateTemplateEntries,                           <span class="comment">// pDescriptorUpdateEntries</span>
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,   <span class="comment">// templateType</span>
    <span class="integer">0</span>,                                                         <span class="comment">// descriptorSetLayout, ignored by given templateType</span>
    VK_PIPELINE_BIND_POINT_GRAPHICS,                           <span class="comment">// pipelineBindPoint</span>
    myPipelineLayout,                                          <span class="comment">// pipelineLayout</span>
    <span class="integer">0</span>,                                                         <span class="comment">// set</span>
};

VkDescriptorUpdateTemplate myDescriptorUpdateTemplate;
myResult = vkCreateDescriptorUpdateTemplate(
    myDevice,
    &amp;createInfo,
    <span class="predefined-constant">NULL</span>,
    &amp;myDescriptorUpdateTemplate);
}

AppDataStructure appData;
<span class="comment">// fill appData here or cache it in your engine</span>
vkCmdPushDescriptorSetWithTemplateKHR(myCmdBuffer, myDescriptorUpdateTemplate, myPipelineLayout, <span class="integer">0</span>,&amp;appData);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_push_constant_updates"><a class="anchor" href="#_push_constant_updates"></a>13.2.10. Push Constant Updates</h4>
<div id="descriptorsets-push-constants" class="paragraph">
<p>As described above in section <a href="#descriptorsets-pipelinelayout">Pipeline
Layouts</a>, the pipeline layout defines shader push constants which are
updated via Vulkan commands rather than via writes to memory or copy
commands.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Push constants represent a high speed path to modify constant data in
pipelines that is expected to outperform memory-backed resource updates.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The values of push constants are undefined at the start of a command
buffer.</p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To update push constants, call:</p>
</div>
<div id="vkCmdPushConstants" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> vkCmdPushConstants(
    VkCommandBuffer                             commandBuffer,
    VkPipelineLayout                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    <span class="directive">const</span> <span class="directive">void</span>*                                 pValues);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>commandBuffer</code> is the command buffer in which the push constant
update will be recorded.</p>
</li>
<li>
<p><code>layout</code> is the pipeline layout used to program the push constant
updates.</p>
</li>
<li>
<p><code>stageFlags</code> is a bitmask of <a href="chap9.html#VkShaderStageFlagBits">VkShaderStageFlagBits</a> specifying
the shader stages that will use the push constants in the updated range.</p>
</li>
<li>
<p><code>offset</code> is the start offset of the push constant range to update,
in units of bytes.</p>
</li>
<li>
<p><code>size</code> is the size of the push constant range to update, in units of
bytes.</p>
</li>
<li>
<p><code>pValues</code> is a pointer to an array of <code>size</code> bytes containing
the new push constant values.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>As <code>stageFlags</code> needs to include all flags the relevant push constant
ranges were created with, any flags that are not supported by the queue
family that the <a href="chap5.html#VkCommandPool">VkCommandPool</a> used to allocate <code>commandBuffer</code> was
created on are ignored.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdPushConstants-offset-01795" href="#VUID-vkCmdPushConstants-offset-01795"></a>
For each byte in the range specified by <code>offset</code> and <code>size</code> and
for each shader stage in <code>stageFlags</code>, there <strong class="purple">must</strong> be a push
constant range in <code>layout</code> that includes that byte and that stage</p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-offset-01796" href="#VUID-vkCmdPushConstants-offset-01796"></a>
For each byte in the range specified by <code>offset</code> and <code>size</code> and
for each push constant range that overlaps that byte, <code>stageFlags</code>
<strong class="purple">must</strong> include all stages in that push constant range’s
<a href="#VkPushConstantRange">VkPushConstantRange</a>::<code>stageFlags</code></p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-offset-00368" href="#VUID-vkCmdPushConstants-offset-00368"></a>
<code>offset</code> <strong class="purple">must</strong> be a multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-size-00369" href="#VUID-vkCmdPushConstants-size-00369"></a>
<code>size</code> <strong class="purple">must</strong> be a multiple of <code>4</code></p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-offset-00370" href="#VUID-vkCmdPushConstants-offset-00370"></a>
<code>offset</code> <strong class="purple">must</strong> be less than
<code>VkPhysicalDeviceLimits</code>::<code>maxPushConstantsSize</code></p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-size-00371" href="#VUID-vkCmdPushConstants-size-00371"></a>
<code>size</code> <strong class="purple">must</strong> be less than or equal to
<code>VkPhysicalDeviceLimits</code>::<code>maxPushConstantsSize</code> minus
<code>offset</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkCmdPushConstants-commandBuffer-parameter" href="#VUID-vkCmdPushConstants-commandBuffer-parameter"></a> <code>commandBuffer</code> <strong class="purple">must</strong> be a valid <a href="chap5.html#VkCommandBuffer">VkCommandBuffer</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-layout-parameter" href="#VUID-vkCmdPushConstants-layout-parameter"></a> <code>layout</code> <strong class="purple">must</strong> be a valid <a href="#VkPipelineLayout">VkPipelineLayout</a> handle</p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-stageFlags-parameter" href="#VUID-vkCmdPushConstants-stageFlags-parameter"></a> <code>stageFlags</code> <strong class="purple">must</strong> be a valid combination of <a href="chap9.html#VkShaderStageFlagBits">VkShaderStageFlagBits</a> values</p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-stageFlags-requiredbitmask" href="#VUID-vkCmdPushConstants-stageFlags-requiredbitmask"></a> <code>stageFlags</code> <strong class="purple">must</strong> not be <code>0</code></p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-pValues-parameter" href="#VUID-vkCmdPushConstants-pValues-parameter"></a> <code>pValues</code> <strong class="purple">must</strong> be a valid pointer to an array of <code>size</code> bytes</p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-commandBuffer-recording" href="#VUID-vkCmdPushConstants-commandBuffer-recording"></a> <code>commandBuffer</code> <strong class="purple">must</strong> be in the <a href="chap5.html#commandbuffers-lifecycle">recording state</a></p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-commandBuffer-cmdpool" href="#VUID-vkCmdPushConstants-commandBuffer-cmdpool"></a> The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> support graphics, or compute operations</p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-size-arraylength" href="#VUID-vkCmdPushConstants-size-arraylength"></a> <code>size</code> <strong class="purple">must</strong> be greater than <code>0</code></p>
</li>
<li>
<p><a id="VUID-vkCmdPushConstants-commonparent" href="#VUID-vkCmdPushConstants-commonparent"></a> Both of <code>commandBuffer</code>, and <code>layout</code> <strong class="purple">must</strong> have been created, allocated, or retrieved from the same <a href="chap4.html#VkDevice">VkDevice</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Host Synchronization</div>
<div class="ulist">
<ul>
<li>
<p>Host access to <code>commandBuffer</code> <strong class="purple">must</strong> be externally synchronized</p>
</li>
<li>
<p>Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong class="purple">must</strong> be externally synchronized</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Command Properties</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><a href="chap5.html#VkCommandBufferLevel">Command Buffer Levels</a></th>
<th class="tableblock halign-left valign-top"><a href="chap7.html#vkCmdBeginRenderPass">Render Pass Scope</a></th>
<th class="tableblock halign-left valign-top"><a href="chap4.html#VkQueueFlagBits">Supported Queue Types</a></th>
<th class="tableblock halign-left valign-top"><a href="chap6.html#synchronization-pipeline-stages-types">Pipeline Type</a></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br>
Secondary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br>
Compute</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_physical_storage_buffer_access"><a class="anchor" href="#_physical_storage_buffer_access"></a>13.3. Physical Storage Buffer Access</h3>
<div id="descriptorsets-physical-storage-buffer" class="openblock">
<div class="content">
<div class="paragraph">
<p>To query a 64-bit buffer device address value through which buffer memory
<strong class="purple">can</strong> be accessed in a shader, call:</p>
</div>
<div id="vkGetBufferDeviceAddressKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">VkDeviceAddress vkGetBufferDeviceAddressKHR(
    VkDevice                                    device,
    <span class="directive">const</span> VkBufferDeviceAddressInfo*            pInfo);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that the buffer was created on.</p>
</li>
<li>
<p><code>pInfo</code> is a pointer to a <a href="#VkBufferDeviceAddressInfo">VkBufferDeviceAddressInfo</a> structure
specifying the buffer to retrieve an address for.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The 64-bit return value is an address of the start of <code>pInfo-&gt;buffer</code>.
The address range starting at this value and whose size is the size of the
buffer <strong class="purple">can</strong> be used in a shader to access the memory bound to that buffer,
using the
<code>SPV_KHR_physical_storage_buffer</code> extension
and the <code>PhysicalStorageBuffer</code> storage class.
For example, this value <strong class="purple">can</strong> be stored in a uniform buffer, and the shader
<strong class="purple">can</strong> read the value from the uniform buffer and use it to do a dependent
read/write to this buffer.
A value of zero is reserved as a “null” pointer and <strong class="purple">must</strong> not be returned
as a valid buffer device address.
All loads, stores, and atomics in a shader through
<code>PhysicalStorageBuffer</code> pointers <strong class="purple">must</strong> access addresses in the address
range of some buffer.</p>
</div>
<div class="paragraph">
<p>If the buffer was created with a non-zero value of
<a href="chap11.html#VkBufferOpaqueCaptureAddressCreateInfo">VkBufferOpaqueCaptureAddressCreateInfo</a>::<code>opaqueCaptureAddress</code>
the return value will be the same address that was returned at capture time.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetBufferDeviceAddress-bufferDeviceAddress-03324" href="#VUID-vkGetBufferDeviceAddress-bufferDeviceAddress-03324"></a>
The <a href="chap34.html#features-bufferDeviceAddress">bufferDeviceAddress</a> or
<a href="#features-bufferDeviceAddressEXT"><code>VkPhysicalDeviceBufferDeviceAddressFeaturesEXT</code>::<code>bufferDeviceAddress</code></a>
feature <strong class="purple">must</strong> be enabled</p>
</li>
<li>
<p><a id="VUID-vkGetBufferDeviceAddress-device-03325" href="#VUID-vkGetBufferDeviceAddress-device-03325"></a>
If <code>device</code> was created with multiple physical devices, then the
<a href="chap34.html#features-bufferDeviceAddressMultiDevice">bufferDeviceAddressMultiDevice</a>
or
<a href="#features-bufferDeviceAddressMultiDeviceEXT"><code>VkPhysicalDeviceBufferDeviceAddressFeaturesEXT</code>::<code>bufferDeviceAddressMultiDevice</code></a>
feature <strong class="purple">must</strong> be enabled</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetBufferDeviceAddress-device-parameter" href="#VUID-vkGetBufferDeviceAddress-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkGetBufferDeviceAddress-pInfo-parameter" href="#VUID-vkGetBufferDeviceAddress-pInfo-parameter"></a> <code>pInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkBufferDeviceAddressInfo">VkBufferDeviceAddressInfo</a> structure</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>The <code>VkBufferDeviceAddressInfo</code> structure is defined as:</p>
</div>
<div id="VkBufferDeviceAddressInfo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> VkBufferDeviceAddressInfo {
    VkStructureType    sType;
    <span class="directive">const</span> <span class="directive">void</span>*        pNext;
    VkBuffer           buffer;
} VkBufferDeviceAddressInfo;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the equivalent</p>
</div>
<div id="VkBufferDeviceAddressInfoKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> VkBufferDeviceAddressInfo VkBufferDeviceAddressInfoKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sType</code> is the type of this structure.</p>
</li>
<li>
<p><code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure.</p>
</li>
<li>
<p><code>buffer</code> specifies the buffer whose address is being queried.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkBufferDeviceAddressInfo-buffer-02600" href="#VUID-VkBufferDeviceAddressInfo-buffer-02600"></a>
If <code>buffer</code> is non-sparse and was not created with the
<code>VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT</code> flag, then it
<strong class="purple">must</strong> be bound completely and contiguously to a single
<code>VkDeviceMemory</code> object</p>
</li>
<li>
<p><a id="VUID-VkBufferDeviceAddressInfo-buffer-02601" href="#VUID-VkBufferDeviceAddressInfo-buffer-02601"></a>
<code>buffer</code> <strong class="purple">must</strong> have been created with
<code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-VkBufferDeviceAddressInfo-sType-sType" href="#VUID-VkBufferDeviceAddressInfo-sType-sType"></a> <code>sType</code> <strong class="purple">must</strong> be <code>VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO</code></p>
</li>
<li>
<p><a id="VUID-VkBufferDeviceAddressInfo-pNext-pNext" href="#VUID-VkBufferDeviceAddressInfo-pNext-pNext"></a> <code>pNext</code> <strong class="purple">must</strong> be <code>NULL</code></p>
</li>
<li>
<p><a id="VUID-VkBufferDeviceAddressInfo-buffer-parameter" href="#VUID-VkBufferDeviceAddressInfo-buffer-parameter"></a> <code>buffer</code> <strong class="purple">must</strong> be a valid <a href="chap11.html#VkBuffer">VkBuffer</a> handle</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>To query a 64-bit buffer opaque capture address, call:</p>
</div>
<div id="vkGetBufferOpaqueCaptureAddressKHR" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">uint64_t vkGetBufferOpaqueCaptureAddressKHR(
    VkDevice                                    device,
    <span class="directive">const</span> VkBufferDeviceAddressInfo*            pInfo);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>device</code> is the logical device that the buffer was created on.</p>
</li>
<li>
<p><code>pInfo</code> is a pointer to a <a href="#VkBufferDeviceAddressInfo">VkBufferDeviceAddressInfo</a> structure
specifying the buffer to retrieve an address for.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The 64-bit return value is an opaque capture address of the start of
<code>pInfo-&gt;buffer</code>.</p>
</div>
<div class="paragraph">
<p>If the buffer was created with a non-zero value of
<a href="chap11.html#VkBufferOpaqueCaptureAddressCreateInfo">VkBufferOpaqueCaptureAddressCreateInfo</a>::<code>opaqueCaptureAddress</code> the
return value <strong class="purple">must</strong> be the same address.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetBufferOpaqueCaptureAddress-None-03326" href="#VUID-vkGetBufferOpaqueCaptureAddress-None-03326"></a>
The <a href="chap34.html#features-bufferDeviceAddress">bufferDeviceAddress</a> feature <strong class="purple">must</strong>
be enabled</p>
</li>
<li>
<p><a id="VUID-vkGetBufferOpaqueCaptureAddress-device-03327" href="#VUID-vkGetBufferOpaqueCaptureAddress-device-03327"></a>
If <code>device</code> was created with multiple physical devices, then the
<a href="chap34.html#features-bufferDeviceAddressMultiDevice">bufferDeviceAddressMultiDevice</a>
feature <strong class="purple">must</strong> be enabled</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Valid Usage (Implicit)</div>
<div class="ulist">
<ul>
<li>
<p><a id="VUID-vkGetBufferOpaqueCaptureAddress-device-parameter" href="#VUID-vkGetBufferOpaqueCaptureAddress-device-parameter"></a> <code>device</code> <strong class="purple">must</strong> be a valid <a href="chap4.html#VkDevice">VkDevice</a> handle</p>
</li>
<li>
<p><a id="VUID-vkGetBufferOpaqueCaptureAddress-pInfo-parameter" href="#VUID-vkGetBufferOpaqueCaptureAddress-pInfo-parameter"></a> <code>pInfo</code> <strong class="purple">must</strong> be a valid pointer to a valid <a href="#VkBufferDeviceAddressInfo">VkBufferDeviceAddressInfo</a> structure</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div id="footer">
<div id="footer-text">
Version 1.0.137<br>
Last updated 2020-03-26 01:48:59 -0700
</div>
</div>
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
pre.CodeRay{background:#f7f7f8}
.CodeRay .line-numbers{border-right:1px solid currentColor;opacity:.35;padding:0 .5em 0 0}
.CodeRay span.line-numbers{display:inline-block;margin-right:.75em}
.CodeRay .line-numbers strong{color:#000}
table.CodeRay{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.CodeRay td{vertical-align:top;line-height:inherit}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.code{padding:0 0 0 .75em}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>


</body>
</html>